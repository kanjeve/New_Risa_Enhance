/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../openxmclient/dist/archive_cwrap.js":
/*!*********************************************!*\
  !*** ../openxmclient/dist/archive_cwrap.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsirSession = exports.projectRoot = void 0;
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const pasirser_1 = __webpack_require__(/*! @kanji/pasirser */ "../pasirser/dist/index.js");
// コンパイルされたCプログラムへのパス
exports.projectRoot = path.join(__dirname, '../');
// export const EXECUTOR_PATH = path.join(projectRoot, 'asir-executor');
// console.log(`[DEBUG] Attempting to execute: ${EXECUTOR_PATH}`);
/**
 * Asirとの永続的な対話セッションを管理するクラス
 */
class AsirSession {
    constructor() {
        this.process = null;
        // 現在実行中のコマンドのresolve関数を保持する
        this.responsePromise = null;
        // Asirからの出力を溜めておくバッファ
        this.responseBuffer = '';
    }
    /**
     * Asirセッションを開始する
     * Cラッパープログラムを起動し、通信の準備が整うまで待つ
     */
    start(executorPATH) {
        return new Promise((resolve, reject) => {
            const openxmHome = '/home/kanji/OpenXM';
            const spawnOptions = {
                cwd: executorPATH,
                env: {
                    ...process.env,
                    OpenXM_HOME: openxmHome,
                    PATH: `${openxmHome}/bin:${process.env.PATH || ''}`,
                    LD_LIBRARY_PATH: `${openxmHome}/lib:${process.env.LD_LIBRARY_PATH || ''}`,
                }
            };
            const cprogramPATH = `${executorPATH}/asir-executor`;
            this.process = (0, child_process_1.spawn)(cprogramPATH, [], spawnOptions);
            this.process.on('error', (err) => {
                console.error('Failed to start Asir executor process.', err);
                this.process = null;
                reject(err);
            });
            this.process.stderr?.on('data', (data) => {
                const message = data.toString();
                console.error(`[C stderr]: ${message}`);
                // Cラッパーが接続成功の合図を出したら、起動成功とみなす
                if (message.includes('Connection successful. Ready for commands.')) {
                    resolve();
                }
            });
            this.process.stdout?.on('data', (data) => {
                this.responseBuffer += data.toString();
                const endTag = '<<__END_OF_ASIR_OUTPUT__>>\n';
                if (this.responseBuffer.includes(endTag)) {
                    // 出力終了の目印を見つけたら、結果を処理
                    const result = this.responseBuffer.replace(endTag, '').trim();
                    this.responseBuffer = ''; // バッファをリセット
                    if (this.responsePromise) {
                        this.responsePromise.resolve(result); //待っているPromiseを解決
                        this.responsePromise = null;
                    }
                }
            });
            this.process.on('close', (code) => {
                console.log(`Asir executor process exited with code ${code}`);
                // もしコマンド実行中にプロセスが予期せず終了したら、Promiseをrejectする
                if (this.responsePromise) {
                    this.responsePromise.reject(new Error(`Asir process exited unexpectedly with code ${code}`));
                }
                this.process = null;
            });
        });
    }
    /**
     * 複数行を含む可能性のあるコマンドブロックを受け取り、
     * ASTを使って文（ステートメント）ごとに分割して実行する
     * @param commandBlock 実行したいAsirのコードブロック
     * @returns 最後の文の実行結果
     */
    async execute(commandBlock) {
        // PASIRSERを使ってコードをASTにパースする
        const { ast, errors } = (0, pasirser_1.parseAsirCodeAndBuildAST)(commandBlock);
        // パースエラーがあれば、例外を投げる
        if (errors.length > 0) {
            const errorMessages = errors.map((e) => `Line ${e.line}:${e.column} - ${e.message}`).join('\n');
            throw new Error(`Asir code parsing failed:\n${errorMessages}`);
        }
        const asirProgram = ast;
        const statements = asirProgram.statements;
        if (statements.length === 0) {
            return ""; // 実行する文がなければ空文字を返す
        }
        const allResults = [];
        // 分割した文を一つずつ順番に実行する
        for (const statement of statements) {
            // ASTノードから元のコマンド文字列を復元する
            const command = this.getSourceText(commandBlock, statement);
            // 内部用の単一文実行メソッドを呼び出し、結果を待つ
            const result = await this.executeSingleStatement(command);
            // Asirは代入文などでは空文字列を返すことがあるため、意味のある出力のみを収集
            if (result.trim().length > 0) {
                allResults.push(result);
            }
        }
        // すべての文の結果を改行で連結して返す
        return allResults.join('\n');
    }
    /**
     * ASTノードから元のソーステキストを復元する
     * @param source 全体のソースコード
     * @param node テキストを取得したいASTノード
     * @returns 復元されたソーステキスト
     */
    getSourceText(source, node) {
        // ASTノードの 'loc' プロパティを使って、ソースコードから文のテキストを抽出します。
        // 'loc' には1ベースの行・列番号が含まれています。
        if (!node.loc || typeof node.loc.startLine !== 'number' || typeof node.loc.startColumn !== 'number' || typeof node.loc.endLine !== 'number' || typeof node.loc.endColumn !== 'number') {
            throw new Error('AST node is missing complete location information (loc).');
        }
        const lines = source.split('\n');
        // 1ベースの行/列を0ベースの絶対インデックスに変換します。
        let startIndex = 0;
        for (let i = 0; i < node.loc.startLine - 1; i++) {
            startIndex += lines[i].length + 1; // +1 for the newline character
        }
        startIndex += node.loc.startColumn;
        let endIndex = 0;
        for (let i = 0; i < node.loc.endLine - 1; i++) {
            endIndex += lines[i].length + 1; // +1 for the newline character
        }
        // ASTのendColumnは、文の最後の文字の「次」の位置を指しているようです。
        endIndex += node.loc.endColumn;
        // まず、loc情報に基づいて部分文字列を抽出します。
        let command = source.substring(startIndex, endIndex);
        // パーサーが文の末尾のセミコロンをlocに含めない場合があるため、
        // 手動でチェックして追加します。
        // endIndexがソース文字列の範囲内であり、かつその文字がセミコロンであるかを確認します。
        if (endIndex < source.length && source[endIndex] === ';') {
            command += ';';
        }
        return command;
    }
    /**
     * 単一の文をCラッパーに送信し、結果を待つ（内部ヘルパーメソッド）
     * @param command 末尾にセミコロンが付いた単一のAsirの文
     */
    executeSingleStatement(command) {
        return new Promise((resolve, reject) => {
            if (!this.process || !this.process.stdin) {
                return reject(new Error('Asir session is not running.'));
            }
            if (this.responsePromise) {
                return reject(new Error('Another command is already in progress.'));
            }
            this.responsePromise = { resolve, reject };
            const payload = `${command}\n__EOC__\n`;
            this.process.stdin.write(payload);
        });
    }
    /**
     * 実行中のAsirの計算を中断する
     */
    interrupt() {
        if (this.process) {
            console.log('Sending SIGINT (Ctrl+C) to Asir process...');
            this.process.kill('SIGINT');
            // 中断した場合、現在のコマンドはエラーにもならず、結果も返さない可能性がある
            // responsePromiseをリセットするなどの追加処理が必要になる場合がある
            if (this.responsePromise) {
                this.responsePromise.reject(new Error('Command interrupted by user.'));
                this.responsePromise = null;
            }
        }
    }
    /**
     * Asirセッションを終了する
     */
    close() {
        if (this.process && this.process.stdin) {
            // Cラッパー側で定義した終了コマンドを送信
            this.process.stdin.write('quit_server\n');
        }
    }
}
exports.AsirSession = AsirSession;
//# sourceMappingURL=archive_cwrap.js.map

/***/ }),

/***/ "../openxmclient/dist/index.js":
/*!*************************************!*\
  !*** ../openxmclient/dist/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsirSession = void 0;
var archive_cwrap_1 = __webpack_require__(/*! ./archive_cwrap */ "../openxmclient/dist/archive_cwrap.js");
Object.defineProperty(exports, "AsirSession", ({ enumerable: true, get: function () { return archive_cwrap_1.AsirSession; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../pasirser/dist/.antlr/asirLexer.js":
/*!********************************************!*\
  !*** ../pasirser/dist/.antlr/asirLexer.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Generated from /home/kanji/risaproject/pasirser/asir.g4 by ANTLR 4.13.1
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asirLexer = void 0;
const antlr = __importStar(__webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs"));
class asirLexer extends antlr.Lexer {
    constructor(input) {
        super(input);
        this.interpreter = new antlr.LexerATNSimulator(this, asirLexer._ATN, asirLexer.decisionsToDFA, new antlr.PredictionContextCache());
    }
    get grammarFileName() { return "asir.g4"; }
    get literalNames() { return asirLexer.literalNames; }
    get symbolicNames() { return asirLexer.symbolicNames; }
    get ruleNames() { return asirLexer.ruleNames; }
    get serializedATN() { return asirLexer._serializedATN; }
    get channelNames() { return asirLexer.channelNames; }
    get modeNames() { return asirLexer.modeNames; }
    static get _ATN() {
        if (!asirLexer.__ATN) {
            asirLexer.__ATN = new antlr.ATNDeserializer().deserialize(asirLexer._serializedATN);
        }
        return asirLexer.__ATN;
    }
    get vocabulary() {
        return asirLexer.vocabulary;
    }
}
exports.asirLexer = asirLexer;
asirLexer.DEF = 1;
asirLexer.IF = 2;
asirLexer.FOR = 3;
asirLexer.WHILE = 4;
asirLexer.DO = 5;
asirLexer.ELSE = 6;
asirLexer.RETURN = 7;
asirLexer.CONTINUE = 8;
asirLexer.BREAK = 9;
asirLexer.STRUCT = 10;
asirLexer.MODULE = 11;
asirLexer.ENDMODULE = 12;
asirLexer.EXTERN = 13;
asirLexer.STATIC = 14;
asirLexer.GLOBAL = 15;
asirLexer.LOCAL = 16;
asirLexer.LOCALF = 17;
asirLexer.FUNCTION = 18;
asirLexer.END = 19;
asirLexer.QUIT = 20;
asirLexer.DEBUG = 21;
asirLexer.LTLT = 22;
asirLexer.GTGT = 23;
asirLexer.COLON2 = 24;
asirLexer.INC = 25;
asirLexer.DEC = 26;
asirLexer.PLUSEQ = 27;
asirLexer.MINUSEQ = 28;
asirLexer.MULTEQ = 29;
asirLexer.DIVEQ = 30;
asirLexer.SUREQ = 31;
asirLexer.POWEREQ = 32;
asirLexer.ARROW = 33;
asirLexer.EQ = 34;
asirLexer.NEQ = 35;
asirLexer.LE = 36;
asirLexer.GE = 37;
asirLexer.LT = 38;
asirLexer.GT = 39;
asirLexer.AND = 40;
asirLexer.OR = 41;
asirLexer.NOT = 42;
asirLexer.PLUS = 43;
asirLexer.MINUS = 44;
asirLexer.MULT = 45;
asirLexer.DIV = 46;
asirLexer.SUR = 47;
asirLexer.POWER = 48;
asirLexer.ASSIGN = 49;
asirLexer.BACK = 50;
asirLexer.MID = 51;
asirLexer.LPAREN = 52;
asirLexer.RPAREN = 53;
asirLexer.LBRANCE = 54;
asirLexer.RBRANCE = 55;
asirLexer.LBRACKET = 56;
asirLexer.RBRACKET = 57;
asirLexer.QUESTION = 58;
asirLexer.COLON = 59;
asirLexer.SEMI = 60;
asirLexer.DOLLAR = 61;
asirLexer.COMMA = 62;
asirLexer.HEX = 63;
asirLexer.BIT = 64;
asirLexer.IMAGINARY = 65;
asirLexer.ASGEN = 66;
asirLexer.APGEN = 67;
asirLexer.BEFORE = 68;
asirLexer.BEFORE_N = 69;
asirLexer.QE_1 = 70;
asirLexer.QE_2 = 71;
asirLexer.QE_3 = 72;
asirLexer.QE_4 = 73;
asirLexer.QE_5 = 74;
asirLexer.QE_6 = 75;
asirLexer.QE_7 = 76;
asirLexer.QE_8 = 77;
asirLexer.QE_9 = 78;
asirLexer.QE_10 = 79;
asirLexer.QE_11 = 80;
asirLexer.QE_12 = 81;
asirLexer.QE_IMPL = 82;
asirLexer.QE_REPL = 83;
asirLexer.QE_EQUIV = 84;
asirLexer.ATFUNC = 85;
asirLexer.VAR_2 = 86;
asirLexer.ID = 87;
asirLexer.FLOAT = 88;
asirLexer.INT = 89;
asirLexer.DOT = 90;
asirLexer.PCOMMENT = 91;
asirLexer.PIFDEF = 92;
asirLexer.PIFNDEF = 93;
asirLexer.PIF = 94;
asirLexer.PELSE = 95;
asirLexer.PELIF = 96;
asirLexer.PENDIF = 97;
asirLexer.PINCLUDE = 98;
asirLexer.PDEFINE = 99;
asirLexer.CHARPLUS = 100;
asirLexer.CHAR = 101;
asirLexer.STRING = 102;
asirLexer.NOSTRING = 103;
asirLexer.SYSTEM_PATH_LITERAL = 104;
asirLexer.NEWLINE = 105;
asirLexer.WS = 106;
asirLexer.COMMENT = 107;
asirLexer.LCOMMENT = 108;
asirLexer.channelNames = [
    "DEFAULT_TOKEN_CHANNEL", "HIDDEN"
];
asirLexer.literalNames = [
    null, "'def'", "'if'", "'for'", "'while'", "'do'", "'else'", "'return'",
    "'continue'", "'break'", "'struct'", "'module'", "'endmodule'",
    "'extern'", "'static'", "'global'", "'local'", "'localf'", "'function'",
    "'end'", "'quit'", "'debug'", "'<<'", "'>>'", "'::'", "'++'", "'--'",
    "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'->'", "'=='",
    "'!='", "'<='", "'>='", "'<'", "'>'", "'&&'", "'||'", "'!'", "'+'",
    "'-'", "'*'", "'/'", "'%'", "'^'", "'='", "'`'", "'|'", "'('", "')'",
    "'{'", "'}'", "'['", "']'", "'?'", "':'", "';'", "'$'", "','", null,
    null, "'@i'", "'@s'", "'@p'", "'@@'", null, "'@>='", "'@<='", "'@>'",
    "'@<'", "'@=='", "'@='", "'@!='", "'@!'", "'@&&'", "'@&'", "'@||'",
    "'@|'", "'@impl'", "'@repl'", "'@equiv'", null, "'@'", null, null,
    null, "'.'", null, "'#ifdef'", "'#ifndef'", "'#if'", "'#else'",
    "'#elif'", "'#endif'", "'#include'", "'#define'", "'##'", "'#'"
];
asirLexer.symbolicNames = [
    null, "DEF", "IF", "FOR", "WHILE", "DO", "ELSE", "RETURN", "CONTINUE",
    "BREAK", "STRUCT", "MODULE", "ENDMODULE", "EXTERN", "STATIC", "GLOBAL",
    "LOCAL", "LOCALF", "FUNCTION", "END", "QUIT", "DEBUG", "LTLT", "GTGT",
    "COLON2", "INC", "DEC", "PLUSEQ", "MINUSEQ", "MULTEQ", "DIVEQ",
    "SUREQ", "POWEREQ", "ARROW", "EQ", "NEQ", "LE", "GE", "LT", "GT",
    "AND", "OR", "NOT", "PLUS", "MINUS", "MULT", "DIV", "SUR", "POWER",
    "ASSIGN", "BACK", "MID", "LPAREN", "RPAREN", "LBRANCE", "RBRANCE",
    "LBRACKET", "RBRACKET", "QUESTION", "COLON", "SEMI", "DOLLAR", "COMMA",
    "HEX", "BIT", "IMAGINARY", "ASGEN", "APGEN", "BEFORE", "BEFORE_N",
    "QE_1", "QE_2", "QE_3", "QE_4", "QE_5", "QE_6", "QE_7", "QE_8",
    "QE_9", "QE_10", "QE_11", "QE_12", "QE_IMPL", "QE_REPL", "QE_EQUIV",
    "ATFUNC", "VAR_2", "ID", "FLOAT", "INT", "DOT", "PCOMMENT", "PIFDEF",
    "PIFNDEF", "PIF", "PELSE", "PELIF", "PENDIF", "PINCLUDE", "PDEFINE",
    "CHARPLUS", "CHAR", "STRING", "NOSTRING", "SYSTEM_PATH_LITERAL",
    "NEWLINE", "WS", "COMMENT", "LCOMMENT"
];
asirLexer.modeNames = [
    "DEFAULT_MODE",
];
asirLexer.ruleNames = [
    "DEF", "IF", "FOR", "WHILE", "DO", "ELSE", "RETURN", "CONTINUE",
    "BREAK", "STRUCT", "MODULE", "ENDMODULE", "EXTERN", "STATIC", "GLOBAL",
    "LOCAL", "LOCALF", "FUNCTION", "END", "QUIT", "DEBUG", "LTLT", "GTGT",
    "COLON2", "INC", "DEC", "PLUSEQ", "MINUSEQ", "MULTEQ", "DIVEQ",
    "SUREQ", "POWEREQ", "ARROW", "EQ", "NEQ", "LE", "GE", "LT", "GT",
    "AND", "OR", "NOT", "PLUS", "MINUS", "MULT", "DIV", "SUR", "POWER",
    "ASSIGN", "BACK", "MID", "LPAREN", "RPAREN", "LBRANCE", "RBRANCE",
    "LBRACKET", "RBRACKET", "QUESTION", "COLON", "SEMI", "DOLLAR", "COMMA",
    "HEX", "BIT", "IMAGINARY", "ASGEN", "APGEN", "BEFORE", "BEFORE_N",
    "QE_1", "QE_2", "QE_3", "QE_4", "QE_5", "QE_6", "QE_7", "QE_8",
    "QE_9", "QE_10", "QE_11", "QE_12", "QE_IMPL", "QE_REPL", "QE_EQUIV",
    "ATFUNC", "VAR_2", "ID", "FLOAT", "INT", "DOT", "PCOMMENT", "PIFDEF",
    "PIFNDEF", "PIF", "PELSE", "PELIF", "PENDIF", "PINCLUDE", "PDEFINE",
    "CHARPLUS", "CHAR", "STRING", "NOSTRING", "SYSTEM_PATH_LITERAL",
    "NEWLINE", "WS", "COMMENT", "LCOMMENT", "EXPONENT",
];
asirLexer._serializedATN = [
    4, 0, 108, 758, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5,
    2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2,
    13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7,
    19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
    26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7,
    32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2,
    39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7,
    45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2,
    52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7,
    58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2,
    65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7,
    71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2,
    78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7,
    84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2,
    91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7,
    97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103,
    7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108,
    1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
    1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
    1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9,
    1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11,
    1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12,
    1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14,
    1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16,
    1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
    1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20,
    1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24,
    1, 24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28,
    1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33,
    1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37,
    1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43,
    1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 49, 1, 49,
    1, 50, 1, 50, 1, 51, 1, 51, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1, 56,
    1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62,
    1, 62, 4, 62, 452, 8, 62, 11, 62, 12, 62, 453, 1, 63, 1, 63, 1, 63, 4, 63, 459, 8, 63,
    11, 63, 12, 63, 460, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 67,
    1, 67, 1, 67, 1, 68, 1, 68, 4, 68, 477, 8, 68, 11, 68, 12, 68, 478, 1, 69, 1, 69, 1, 69,
    1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73,
    1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 77,
    1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
    1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83,
    1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 4, 84, 544, 8, 84, 11, 84, 12, 84,
    545, 1, 85, 1, 85, 1, 86, 1, 86, 5, 86, 552, 8, 86, 10, 86, 12, 86, 555, 9, 86, 1, 87,
    4, 87, 558, 8, 87, 11, 87, 12, 87, 559, 1, 87, 1, 87, 5, 87, 564, 8, 87, 10, 87, 12, 87,
    567, 9, 87, 1, 87, 3, 87, 570, 8, 87, 1, 87, 1, 87, 4, 87, 574, 8, 87, 11, 87, 12, 87,
    575, 1, 87, 3, 87, 579, 8, 87, 1, 87, 4, 87, 582, 8, 87, 11, 87, 12, 87, 583, 1, 87, 3,
    87, 587, 8, 87, 1, 88, 4, 88, 590, 8, 88, 11, 88, 12, 88, 591, 1, 89, 1, 89, 1, 90, 1,
    90, 1, 90, 1, 90, 1, 90, 4, 90, 601, 8, 90, 11, 90, 12, 90, 602, 1, 90, 1, 90, 5, 90, 607,
    8, 90, 10, 90, 12, 90, 610, 9, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90,
    1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
    1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94,
    1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96,
    1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98,
    1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101,
    1, 101, 5, 101, 685, 8, 101, 10, 101, 12, 101, 688, 9, 101, 1, 101, 1, 101, 1, 102,
    1, 102, 1, 102, 1, 102, 5, 102, 696, 8, 102, 10, 102, 12, 102, 699, 9, 102, 1, 102,
    1, 102, 1, 103, 1, 103, 4, 103, 705, 8, 103, 11, 103, 12, 103, 706, 1, 103, 1, 103,
    1, 104, 4, 104, 712, 8, 104, 11, 104, 12, 104, 713, 1, 104, 1, 104, 1, 105, 4, 105,
    719, 8, 105, 11, 105, 12, 105, 720, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106,
    5, 106, 729, 8, 106, 10, 106, 12, 106, 732, 9, 106, 1, 106, 1, 106, 1, 106, 1, 106,
    1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 5, 107, 743, 8, 107, 10, 107, 12, 107, 746,
    9, 107, 1, 107, 1, 107, 1, 108, 1, 108, 3, 108, 752, 8, 108, 1, 108, 4, 108, 755, 8,
    108, 11, 108, 12, 108, 756, 2, 608, 730, 0, 109, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13,
    7, 15, 8, 17, 9, 19, 10, 21, 11, 23, 12, 25, 13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18,
    37, 19, 39, 20, 41, 21, 43, 22, 45, 23, 47, 24, 49, 25, 51, 26, 53, 27, 55, 28, 57, 29,
    59, 30, 61, 31, 63, 32, 65, 33, 67, 34, 69, 35, 71, 36, 73, 37, 75, 38, 77, 39, 79, 40,
    81, 41, 83, 42, 85, 43, 87, 44, 89, 45, 91, 46, 93, 47, 95, 48, 97, 49, 99, 50, 101,
    51, 103, 52, 105, 53, 107, 54, 109, 55, 111, 56, 113, 57, 115, 58, 117, 59, 119, 60,
    121, 61, 123, 62, 125, 63, 127, 64, 129, 65, 131, 66, 133, 67, 135, 68, 137, 69, 139,
    70, 141, 71, 143, 72, 145, 73, 147, 74, 149, 75, 151, 76, 153, 77, 155, 78, 157, 79,
    159, 80, 161, 81, 163, 82, 165, 83, 167, 84, 169, 85, 171, 86, 173, 87, 175, 88, 177,
    89, 179, 90, 181, 91, 183, 92, 185, 93, 187, 94, 189, 95, 191, 96, 193, 97, 195, 98,
    197, 99, 199, 100, 201, 101, 203, 102, 205, 103, 207, 104, 209, 105, 211, 106, 213,
    107, 215, 108, 217, 0, 1, 0, 15, 2, 0, 88, 88, 120, 120, 3, 0, 48, 57, 65, 70, 97, 102,
    2, 0, 66, 66, 98, 98, 1, 0, 48, 49, 1, 0, 48, 57, 2, 0, 65, 90, 97, 122, 3, 0, 65, 90, 95,
    95, 97, 122, 4, 0, 48, 57, 65, 90, 95, 95, 97, 122, 2, 0, 9, 9, 32, 32, 2, 0, 34, 34, 92,
    92, 2, 0, 39, 39, 92, 92, 5, 0, 45, 57, 65, 90, 92, 92, 95, 95, 97, 122, 2, 0, 10, 10,
    13, 13, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 783, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0,
    0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0,
    0, 0, 15, 1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0,
    0, 0, 25, 1, 0, 0, 0, 0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0,
    0, 0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0,
    0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0, 49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0,
    0, 0, 55, 1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0, 0, 0, 0, 61, 1, 0, 0, 0, 0, 63, 1, 0, 0,
    0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0, 0, 71, 1, 0, 0, 0, 0, 73, 1, 0, 0,
    0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0, 0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0, 0, 83, 1, 0, 0,
    0, 0, 85, 1, 0, 0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1, 0, 0,
    0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101, 1, 0, 0, 0, 0, 103, 1, 0,
    0, 0, 0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0, 0, 109, 1, 0, 0, 0, 0, 111, 1, 0, 0, 0, 0, 113,
    1, 0, 0, 0, 0, 115, 1, 0, 0, 0, 0, 117, 1, 0, 0, 0, 0, 119, 1, 0, 0, 0, 0, 121, 1, 0, 0, 0,
    0, 123, 1, 0, 0, 0, 0, 125, 1, 0, 0, 0, 0, 127, 1, 0, 0, 0, 0, 129, 1, 0, 0, 0, 0, 131, 1,
    0, 0, 0, 0, 133, 1, 0, 0, 0, 0, 135, 1, 0, 0, 0, 0, 137, 1, 0, 0, 0, 0, 139, 1, 0, 0, 0, 0,
    141, 1, 0, 0, 0, 0, 143, 1, 0, 0, 0, 0, 145, 1, 0, 0, 0, 0, 147, 1, 0, 0, 0, 0, 149, 1, 0,
    0, 0, 0, 151, 1, 0, 0, 0, 0, 153, 1, 0, 0, 0, 0, 155, 1, 0, 0, 0, 0, 157, 1, 0, 0, 0, 0, 159,
    1, 0, 0, 0, 0, 161, 1, 0, 0, 0, 0, 163, 1, 0, 0, 0, 0, 165, 1, 0, 0, 0, 0, 167, 1, 0, 0, 0,
    0, 169, 1, 0, 0, 0, 0, 171, 1, 0, 0, 0, 0, 173, 1, 0, 0, 0, 0, 175, 1, 0, 0, 0, 0, 177, 1,
    0, 0, 0, 0, 179, 1, 0, 0, 0, 0, 181, 1, 0, 0, 0, 0, 183, 1, 0, 0, 0, 0, 185, 1, 0, 0, 0, 0,
    187, 1, 0, 0, 0, 0, 189, 1, 0, 0, 0, 0, 191, 1, 0, 0, 0, 0, 193, 1, 0, 0, 0, 0, 195, 1, 0,
    0, 0, 0, 197, 1, 0, 0, 0, 0, 199, 1, 0, 0, 0, 0, 201, 1, 0, 0, 0, 0, 203, 1, 0, 0, 0, 0, 205,
    1, 0, 0, 0, 0, 207, 1, 0, 0, 0, 0, 209, 1, 0, 0, 0, 0, 211, 1, 0, 0, 0, 0, 213, 1, 0, 0, 0,
    0, 215, 1, 0, 0, 0, 1, 219, 1, 0, 0, 0, 3, 223, 1, 0, 0, 0, 5, 226, 1, 0, 0, 0, 7, 230, 1,
    0, 0, 0, 9, 236, 1, 0, 0, 0, 11, 239, 1, 0, 0, 0, 13, 244, 1, 0, 0, 0, 15, 251, 1, 0, 0, 0,
    17, 260, 1, 0, 0, 0, 19, 266, 1, 0, 0, 0, 21, 273, 1, 0, 0, 0, 23, 280, 1, 0, 0, 0, 25, 290,
    1, 0, 0, 0, 27, 297, 1, 0, 0, 0, 29, 304, 1, 0, 0, 0, 31, 311, 1, 0, 0, 0, 33, 317, 1, 0,
    0, 0, 35, 324, 1, 0, 0, 0, 37, 333, 1, 0, 0, 0, 39, 337, 1, 0, 0, 0, 41, 342, 1, 0, 0, 0,
    43, 348, 1, 0, 0, 0, 45, 351, 1, 0, 0, 0, 47, 354, 1, 0, 0, 0, 49, 357, 1, 0, 0, 0, 51, 360,
    1, 0, 0, 0, 53, 363, 1, 0, 0, 0, 55, 366, 1, 0, 0, 0, 57, 369, 1, 0, 0, 0, 59, 372, 1, 0,
    0, 0, 61, 375, 1, 0, 0, 0, 63, 378, 1, 0, 0, 0, 65, 381, 1, 0, 0, 0, 67, 384, 1, 0, 0, 0,
    69, 387, 1, 0, 0, 0, 71, 390, 1, 0, 0, 0, 73, 393, 1, 0, 0, 0, 75, 396, 1, 0, 0, 0, 77, 398,
    1, 0, 0, 0, 79, 400, 1, 0, 0, 0, 81, 403, 1, 0, 0, 0, 83, 406, 1, 0, 0, 0, 85, 408, 1, 0,
    0, 0, 87, 410, 1, 0, 0, 0, 89, 412, 1, 0, 0, 0, 91, 414, 1, 0, 0, 0, 93, 416, 1, 0, 0, 0,
    95, 418, 1, 0, 0, 0, 97, 420, 1, 0, 0, 0, 99, 422, 1, 0, 0, 0, 101, 424, 1, 0, 0, 0, 103,
    426, 1, 0, 0, 0, 105, 428, 1, 0, 0, 0, 107, 430, 1, 0, 0, 0, 109, 432, 1, 0, 0, 0, 111,
    434, 1, 0, 0, 0, 113, 436, 1, 0, 0, 0, 115, 438, 1, 0, 0, 0, 117, 440, 1, 0, 0, 0, 119,
    442, 1, 0, 0, 0, 121, 444, 1, 0, 0, 0, 123, 446, 1, 0, 0, 0, 125, 448, 1, 0, 0, 0, 127,
    455, 1, 0, 0, 0, 129, 462, 1, 0, 0, 0, 131, 465, 1, 0, 0, 0, 133, 468, 1, 0, 0, 0, 135,
    471, 1, 0, 0, 0, 137, 474, 1, 0, 0, 0, 139, 480, 1, 0, 0, 0, 141, 484, 1, 0, 0, 0, 143,
    488, 1, 0, 0, 0, 145, 491, 1, 0, 0, 0, 147, 494, 1, 0, 0, 0, 149, 498, 1, 0, 0, 0, 151,
    501, 1, 0, 0, 0, 153, 505, 1, 0, 0, 0, 155, 508, 1, 0, 0, 0, 157, 512, 1, 0, 0, 0, 159,
    515, 1, 0, 0, 0, 161, 519, 1, 0, 0, 0, 163, 522, 1, 0, 0, 0, 165, 528, 1, 0, 0, 0, 167,
    534, 1, 0, 0, 0, 169, 541, 1, 0, 0, 0, 171, 547, 1, 0, 0, 0, 173, 549, 1, 0, 0, 0, 175,
    586, 1, 0, 0, 0, 177, 589, 1, 0, 0, 0, 179, 593, 1, 0, 0, 0, 181, 595, 1, 0, 0, 0, 183,
    620, 1, 0, 0, 0, 185, 627, 1, 0, 0, 0, 187, 635, 1, 0, 0, 0, 189, 639, 1, 0, 0, 0, 191,
    645, 1, 0, 0, 0, 193, 651, 1, 0, 0, 0, 195, 658, 1, 0, 0, 0, 197, 667, 1, 0, 0, 0, 199,
    675, 1, 0, 0, 0, 201, 678, 1, 0, 0, 0, 203, 680, 1, 0, 0, 0, 205, 691, 1, 0, 0, 0, 207,
    702, 1, 0, 0, 0, 209, 711, 1, 0, 0, 0, 211, 718, 1, 0, 0, 0, 213, 724, 1, 0, 0, 0, 215,
    738, 1, 0, 0, 0, 217, 749, 1, 0, 0, 0, 219, 220, 5, 100, 0, 0, 220, 221, 5, 101, 0, 0,
    221, 222, 5, 102, 0, 0, 222, 2, 1, 0, 0, 0, 223, 224, 5, 105, 0, 0, 224, 225, 5, 102,
    0, 0, 225, 4, 1, 0, 0, 0, 226, 227, 5, 102, 0, 0, 227, 228, 5, 111, 0, 0, 228, 229, 5,
    114, 0, 0, 229, 6, 1, 0, 0, 0, 230, 231, 5, 119, 0, 0, 231, 232, 5, 104, 0, 0, 232, 233,
    5, 105, 0, 0, 233, 234, 5, 108, 0, 0, 234, 235, 5, 101, 0, 0, 235, 8, 1, 0, 0, 0, 236,
    237, 5, 100, 0, 0, 237, 238, 5, 111, 0, 0, 238, 10, 1, 0, 0, 0, 239, 240, 5, 101, 0, 0,
    240, 241, 5, 108, 0, 0, 241, 242, 5, 115, 0, 0, 242, 243, 5, 101, 0, 0, 243, 12, 1, 0,
    0, 0, 244, 245, 5, 114, 0, 0, 245, 246, 5, 101, 0, 0, 246, 247, 5, 116, 0, 0, 247, 248,
    5, 117, 0, 0, 248, 249, 5, 114, 0, 0, 249, 250, 5, 110, 0, 0, 250, 14, 1, 0, 0, 0, 251,
    252, 5, 99, 0, 0, 252, 253, 5, 111, 0, 0, 253, 254, 5, 110, 0, 0, 254, 255, 5, 116, 0,
    0, 255, 256, 5, 105, 0, 0, 256, 257, 5, 110, 0, 0, 257, 258, 5, 117, 0, 0, 258, 259,
    5, 101, 0, 0, 259, 16, 1, 0, 0, 0, 260, 261, 5, 98, 0, 0, 261, 262, 5, 114, 0, 0, 262,
    263, 5, 101, 0, 0, 263, 264, 5, 97, 0, 0, 264, 265, 5, 107, 0, 0, 265, 18, 1, 0, 0, 0,
    266, 267, 5, 115, 0, 0, 267, 268, 5, 116, 0, 0, 268, 269, 5, 114, 0, 0, 269, 270, 5,
    117, 0, 0, 270, 271, 5, 99, 0, 0, 271, 272, 5, 116, 0, 0, 272, 20, 1, 0, 0, 0, 273, 274,
    5, 109, 0, 0, 274, 275, 5, 111, 0, 0, 275, 276, 5, 100, 0, 0, 276, 277, 5, 117, 0, 0,
    277, 278, 5, 108, 0, 0, 278, 279, 5, 101, 0, 0, 279, 22, 1, 0, 0, 0, 280, 281, 5, 101,
    0, 0, 281, 282, 5, 110, 0, 0, 282, 283, 5, 100, 0, 0, 283, 284, 5, 109, 0, 0, 284, 285,
    5, 111, 0, 0, 285, 286, 5, 100, 0, 0, 286, 287, 5, 117, 0, 0, 287, 288, 5, 108, 0, 0,
    288, 289, 5, 101, 0, 0, 289, 24, 1, 0, 0, 0, 290, 291, 5, 101, 0, 0, 291, 292, 5, 120,
    0, 0, 292, 293, 5, 116, 0, 0, 293, 294, 5, 101, 0, 0, 294, 295, 5, 114, 0, 0, 295, 296,
    5, 110, 0, 0, 296, 26, 1, 0, 0, 0, 297, 298, 5, 115, 0, 0, 298, 299, 5, 116, 0, 0, 299,
    300, 5, 97, 0, 0, 300, 301, 5, 116, 0, 0, 301, 302, 5, 105, 0, 0, 302, 303, 5, 99, 0,
    0, 303, 28, 1, 0, 0, 0, 304, 305, 5, 103, 0, 0, 305, 306, 5, 108, 0, 0, 306, 307, 5, 111,
    0, 0, 307, 308, 5, 98, 0, 0, 308, 309, 5, 97, 0, 0, 309, 310, 5, 108, 0, 0, 310, 30, 1,
    0, 0, 0, 311, 312, 5, 108, 0, 0, 312, 313, 5, 111, 0, 0, 313, 314, 5, 99, 0, 0, 314, 315,
    5, 97, 0, 0, 315, 316, 5, 108, 0, 0, 316, 32, 1, 0, 0, 0, 317, 318, 5, 108, 0, 0, 318,
    319, 5, 111, 0, 0, 319, 320, 5, 99, 0, 0, 320, 321, 5, 97, 0, 0, 321, 322, 5, 108, 0,
    0, 322, 323, 5, 102, 0, 0, 323, 34, 1, 0, 0, 0, 324, 325, 5, 102, 0, 0, 325, 326, 5, 117,
    0, 0, 326, 327, 5, 110, 0, 0, 327, 328, 5, 99, 0, 0, 328, 329, 5, 116, 0, 0, 329, 330,
    5, 105, 0, 0, 330, 331, 5, 111, 0, 0, 331, 332, 5, 110, 0, 0, 332, 36, 1, 0, 0, 0, 333,
    334, 5, 101, 0, 0, 334, 335, 5, 110, 0, 0, 335, 336, 5, 100, 0, 0, 336, 38, 1, 0, 0, 0,
    337, 338, 5, 113, 0, 0, 338, 339, 5, 117, 0, 0, 339, 340, 5, 105, 0, 0, 340, 341, 5,
    116, 0, 0, 341, 40, 1, 0, 0, 0, 342, 343, 5, 100, 0, 0, 343, 344, 5, 101, 0, 0, 344, 345,
    5, 98, 0, 0, 345, 346, 5, 117, 0, 0, 346, 347, 5, 103, 0, 0, 347, 42, 1, 0, 0, 0, 348,
    349, 5, 60, 0, 0, 349, 350, 5, 60, 0, 0, 350, 44, 1, 0, 0, 0, 351, 352, 5, 62, 0, 0, 352,
    353, 5, 62, 0, 0, 353, 46, 1, 0, 0, 0, 354, 355, 5, 58, 0, 0, 355, 356, 5, 58, 0, 0, 356,
    48, 1, 0, 0, 0, 357, 358, 5, 43, 0, 0, 358, 359, 5, 43, 0, 0, 359, 50, 1, 0, 0, 0, 360,
    361, 5, 45, 0, 0, 361, 362, 5, 45, 0, 0, 362, 52, 1, 0, 0, 0, 363, 364, 5, 43, 0, 0, 364,
    365, 5, 61, 0, 0, 365, 54, 1, 0, 0, 0, 366, 367, 5, 45, 0, 0, 367, 368, 5, 61, 0, 0, 368,
    56, 1, 0, 0, 0, 369, 370, 5, 42, 0, 0, 370, 371, 5, 61, 0, 0, 371, 58, 1, 0, 0, 0, 372,
    373, 5, 47, 0, 0, 373, 374, 5, 61, 0, 0, 374, 60, 1, 0, 0, 0, 375, 376, 5, 37, 0, 0, 376,
    377, 5, 61, 0, 0, 377, 62, 1, 0, 0, 0, 378, 379, 5, 94, 0, 0, 379, 380, 5, 61, 0, 0, 380,
    64, 1, 0, 0, 0, 381, 382, 5, 45, 0, 0, 382, 383, 5, 62, 0, 0, 383, 66, 1, 0, 0, 0, 384,
    385, 5, 61, 0, 0, 385, 386, 5, 61, 0, 0, 386, 68, 1, 0, 0, 0, 387, 388, 5, 33, 0, 0, 388,
    389, 5, 61, 0, 0, 389, 70, 1, 0, 0, 0, 390, 391, 5, 60, 0, 0, 391, 392, 5, 61, 0, 0, 392,
    72, 1, 0, 0, 0, 393, 394, 5, 62, 0, 0, 394, 395, 5, 61, 0, 0, 395, 74, 1, 0, 0, 0, 396,
    397, 5, 60, 0, 0, 397, 76, 1, 0, 0, 0, 398, 399, 5, 62, 0, 0, 399, 78, 1, 0, 0, 0, 400,
    401, 5, 38, 0, 0, 401, 402, 5, 38, 0, 0, 402, 80, 1, 0, 0, 0, 403, 404, 5, 124, 0, 0, 404,
    405, 5, 124, 0, 0, 405, 82, 1, 0, 0, 0, 406, 407, 5, 33, 0, 0, 407, 84, 1, 0, 0, 0, 408,
    409, 5, 43, 0, 0, 409, 86, 1, 0, 0, 0, 410, 411, 5, 45, 0, 0, 411, 88, 1, 0, 0, 0, 412,
    413, 5, 42, 0, 0, 413, 90, 1, 0, 0, 0, 414, 415, 5, 47, 0, 0, 415, 92, 1, 0, 0, 0, 416,
    417, 5, 37, 0, 0, 417, 94, 1, 0, 0, 0, 418, 419, 5, 94, 0, 0, 419, 96, 1, 0, 0, 0, 420,
    421, 5, 61, 0, 0, 421, 98, 1, 0, 0, 0, 422, 423, 5, 96, 0, 0, 423, 100, 1, 0, 0, 0, 424,
    425, 5, 124, 0, 0, 425, 102, 1, 0, 0, 0, 426, 427, 5, 40, 0, 0, 427, 104, 1, 0, 0, 0, 428,
    429, 5, 41, 0, 0, 429, 106, 1, 0, 0, 0, 430, 431, 5, 123, 0, 0, 431, 108, 1, 0, 0, 0, 432,
    433, 5, 125, 0, 0, 433, 110, 1, 0, 0, 0, 434, 435, 5, 91, 0, 0, 435, 112, 1, 0, 0, 0, 436,
    437, 5, 93, 0, 0, 437, 114, 1, 0, 0, 0, 438, 439, 5, 63, 0, 0, 439, 116, 1, 0, 0, 0, 440,
    441, 5, 58, 0, 0, 441, 118, 1, 0, 0, 0, 442, 443, 5, 59, 0, 0, 443, 120, 1, 0, 0, 0, 444,
    445, 5, 36, 0, 0, 445, 122, 1, 0, 0, 0, 446, 447, 5, 44, 0, 0, 447, 124, 1, 0, 0, 0, 448,
    449, 5, 48, 0, 0, 449, 451, 7, 0, 0, 0, 450, 452, 7, 1, 0, 0, 451, 450, 1, 0, 0, 0, 452,
    453, 1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 126, 1, 0, 0, 0, 455,
    456, 5, 48, 0, 0, 456, 458, 7, 2, 0, 0, 457, 459, 7, 3, 0, 0, 458, 457, 1, 0, 0, 0, 459,
    460, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 128, 1, 0, 0, 0, 462,
    463, 5, 64, 0, 0, 463, 464, 5, 105, 0, 0, 464, 130, 1, 0, 0, 0, 465, 466, 5, 64, 0, 0,
    466, 467, 5, 115, 0, 0, 467, 132, 1, 0, 0, 0, 468, 469, 5, 64, 0, 0, 469, 470, 5, 112,
    0, 0, 470, 134, 1, 0, 0, 0, 471, 472, 5, 64, 0, 0, 472, 473, 5, 64, 0, 0, 473, 136, 1,
    0, 0, 0, 474, 476, 5, 64, 0, 0, 475, 477, 7, 4, 0, 0, 476, 475, 1, 0, 0, 0, 477, 478, 1,
    0, 0, 0, 478, 476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 138, 1, 0, 0, 0, 480, 481, 5,
    64, 0, 0, 481, 482, 5, 62, 0, 0, 482, 483, 5, 61, 0, 0, 483, 140, 1, 0, 0, 0, 484, 485,
    5, 64, 0, 0, 485, 486, 5, 60, 0, 0, 486, 487, 5, 61, 0, 0, 487, 142, 1, 0, 0, 0, 488, 489,
    5, 64, 0, 0, 489, 490, 5, 62, 0, 0, 490, 144, 1, 0, 0, 0, 491, 492, 5, 64, 0, 0, 492, 493,
    5, 60, 0, 0, 493, 146, 1, 0, 0, 0, 494, 495, 5, 64, 0, 0, 495, 496, 5, 61, 0, 0, 496, 497,
    5, 61, 0, 0, 497, 148, 1, 0, 0, 0, 498, 499, 5, 64, 0, 0, 499, 500, 5, 61, 0, 0, 500, 150,
    1, 0, 0, 0, 501, 502, 5, 64, 0, 0, 502, 503, 5, 33, 0, 0, 503, 504, 5, 61, 0, 0, 504, 152,
    1, 0, 0, 0, 505, 506, 5, 64, 0, 0, 506, 507, 5, 33, 0, 0, 507, 154, 1, 0, 0, 0, 508, 509,
    5, 64, 0, 0, 509, 510, 5, 38, 0, 0, 510, 511, 5, 38, 0, 0, 511, 156, 1, 0, 0, 0, 512, 513,
    5, 64, 0, 0, 513, 514, 5, 38, 0, 0, 514, 158, 1, 0, 0, 0, 515, 516, 5, 64, 0, 0, 516, 517,
    5, 124, 0, 0, 517, 518, 5, 124, 0, 0, 518, 160, 1, 0, 0, 0, 519, 520, 5, 64, 0, 0, 520,
    521, 5, 124, 0, 0, 521, 162, 1, 0, 0, 0, 522, 523, 5, 64, 0, 0, 523, 524, 5, 105, 0, 0,
    524, 525, 5, 109, 0, 0, 525, 526, 5, 112, 0, 0, 526, 527, 5, 108, 0, 0, 527, 164, 1,
    0, 0, 0, 528, 529, 5, 64, 0, 0, 529, 530, 5, 114, 0, 0, 530, 531, 5, 101, 0, 0, 531, 532,
    5, 112, 0, 0, 532, 533, 5, 108, 0, 0, 533, 166, 1, 0, 0, 0, 534, 535, 5, 64, 0, 0, 535,
    536, 5, 101, 0, 0, 536, 537, 5, 113, 0, 0, 537, 538, 5, 117, 0, 0, 538, 539, 5, 105,
    0, 0, 539, 540, 5, 118, 0, 0, 540, 168, 1, 0, 0, 0, 541, 543, 5, 64, 0, 0, 542, 544, 7,
    5, 0, 0, 543, 542, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545, 546, 1,
    0, 0, 0, 546, 170, 1, 0, 0, 0, 547, 548, 5, 64, 0, 0, 548, 172, 1, 0, 0, 0, 549, 553, 7,
    6, 0, 0, 550, 552, 7, 7, 0, 0, 551, 550, 1, 0, 0, 0, 552, 555, 1, 0, 0, 0, 553, 551, 1,
    0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 174, 1, 0, 0, 0, 555, 553, 1, 0, 0, 0, 556, 558, 7,
    4, 0, 0, 557, 556, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 559, 560, 1,
    0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 565, 5, 46, 0, 0, 562, 564, 7, 4, 0, 0, 563, 562, 1,
    0, 0, 0, 564, 567, 1, 0, 0, 0, 565, 563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 569, 1,
    0, 0, 0, 567, 565, 1, 0, 0, 0, 568, 570, 3, 217, 108, 0, 569, 568, 1, 0, 0, 0, 569, 570,
    1, 0, 0, 0, 570, 587, 1, 0, 0, 0, 571, 573, 5, 46, 0, 0, 572, 574, 7, 4, 0, 0, 573, 572,
    1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 573, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 578,
    1, 0, 0, 0, 577, 579, 3, 217, 108, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579,
    587, 1, 0, 0, 0, 580, 582, 7, 4, 0, 0, 581, 580, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583,
    581, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 587, 3, 217, 108, 0,
    586, 557, 1, 0, 0, 0, 586, 571, 1, 0, 0, 0, 586, 581, 1, 0, 0, 0, 587, 176, 1, 0, 0, 0,
    588, 590, 7, 4, 0, 0, 589, 588, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0,
    591, 592, 1, 0, 0, 0, 592, 178, 1, 0, 0, 0, 593, 594, 5, 46, 0, 0, 594, 180, 1, 0, 0, 0,
    595, 596, 5, 35, 0, 0, 596, 597, 5, 105, 0, 0, 597, 598, 5, 102, 0, 0, 598, 600, 1, 0,
    0, 0, 599, 601, 7, 8, 0, 0, 600, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 600, 1, 0,
    0, 0, 602, 603, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 608, 5, 48, 0, 0, 605, 607, 9, 0,
    0, 0, 606, 605, 1, 0, 0, 0, 607, 610, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 608, 606, 1, 0,
    0, 0, 609, 611, 1, 0, 0, 0, 610, 608, 1, 0, 0, 0, 611, 612, 5, 35, 0, 0, 612, 613, 5, 101,
    0, 0, 613, 614, 5, 110, 0, 0, 614, 615, 5, 100, 0, 0, 615, 616, 5, 105, 0, 0, 616, 617,
    5, 102, 0, 0, 617, 618, 1, 0, 0, 0, 618, 619, 6, 90, 0, 0, 619, 182, 1, 0, 0, 0, 620, 621,
    5, 35, 0, 0, 621, 622, 5, 105, 0, 0, 622, 623, 5, 102, 0, 0, 623, 624, 5, 100, 0, 0, 624,
    625, 5, 101, 0, 0, 625, 626, 5, 102, 0, 0, 626, 184, 1, 0, 0, 0, 627, 628, 5, 35, 0, 0,
    628, 629, 5, 105, 0, 0, 629, 630, 5, 102, 0, 0, 630, 631, 5, 110, 0, 0, 631, 632, 5,
    100, 0, 0, 632, 633, 5, 101, 0, 0, 633, 634, 5, 102, 0, 0, 634, 186, 1, 0, 0, 0, 635,
    636, 5, 35, 0, 0, 636, 637, 5, 105, 0, 0, 637, 638, 5, 102, 0, 0, 638, 188, 1, 0, 0, 0,
    639, 640, 5, 35, 0, 0, 640, 641, 5, 101, 0, 0, 641, 642, 5, 108, 0, 0, 642, 643, 5, 115,
    0, 0, 643, 644, 5, 101, 0, 0, 644, 190, 1, 0, 0, 0, 645, 646, 5, 35, 0, 0, 646, 647, 5,
    101, 0, 0, 647, 648, 5, 108, 0, 0, 648, 649, 5, 105, 0, 0, 649, 650, 5, 102, 0, 0, 650,
    192, 1, 0, 0, 0, 651, 652, 5, 35, 0, 0, 652, 653, 5, 101, 0, 0, 653, 654, 5, 110, 0, 0,
    654, 655, 5, 100, 0, 0, 655, 656, 5, 105, 0, 0, 656, 657, 5, 102, 0, 0, 657, 194, 1,
    0, 0, 0, 658, 659, 5, 35, 0, 0, 659, 660, 5, 105, 0, 0, 660, 661, 5, 110, 0, 0, 661, 662,
    5, 99, 0, 0, 662, 663, 5, 108, 0, 0, 663, 664, 5, 117, 0, 0, 664, 665, 5, 100, 0, 0, 665,
    666, 5, 101, 0, 0, 666, 196, 1, 0, 0, 0, 667, 668, 5, 35, 0, 0, 668, 669, 5, 100, 0, 0,
    669, 670, 5, 101, 0, 0, 670, 671, 5, 102, 0, 0, 671, 672, 5, 105, 0, 0, 672, 673, 5,
    110, 0, 0, 673, 674, 5, 101, 0, 0, 674, 198, 1, 0, 0, 0, 675, 676, 5, 35, 0, 0, 676, 677,
    5, 35, 0, 0, 677, 200, 1, 0, 0, 0, 678, 679, 5, 35, 0, 0, 679, 202, 1, 0, 0, 0, 680, 686,
    5, 34, 0, 0, 681, 682, 5, 92, 0, 0, 682, 685, 9, 0, 0, 0, 683, 685, 8, 9, 0, 0, 684, 681,
    1, 0, 0, 0, 684, 683, 1, 0, 0, 0, 685, 688, 1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 687,
    1, 0, 0, 0, 687, 689, 1, 0, 0, 0, 688, 686, 1, 0, 0, 0, 689, 690, 5, 34, 0, 0, 690, 204,
    1, 0, 0, 0, 691, 697, 5, 39, 0, 0, 692, 693, 5, 92, 0, 0, 693, 696, 9, 0, 0, 0, 694, 696,
    8, 10, 0, 0, 695, 692, 1, 0, 0, 0, 695, 694, 1, 0, 0, 0, 696, 699, 1, 0, 0, 0, 697, 695,
    1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 700, 1, 0, 0, 0, 699, 697, 1, 0, 0, 0, 700, 701,
    5, 39, 0, 0, 701, 206, 1, 0, 0, 0, 702, 704, 5, 60, 0, 0, 703, 705, 7, 11, 0, 0, 704, 703,
    1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 704, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708,
    1, 0, 0, 0, 708, 709, 5, 62, 0, 0, 709, 208, 1, 0, 0, 0, 710, 712, 7, 12, 0, 0, 711, 710,
    1, 0, 0, 0, 712, 713, 1, 0, 0, 0, 713, 711, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 715,
    1, 0, 0, 0, 715, 716, 6, 104, 0, 0, 716, 210, 1, 0, 0, 0, 717, 719, 7, 8, 0, 0, 718, 717,
    1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720, 718, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 722,
    1, 0, 0, 0, 722, 723, 6, 105, 0, 0, 723, 212, 1, 0, 0, 0, 724, 725, 5, 47, 0, 0, 725, 726,
    5, 42, 0, 0, 726, 730, 1, 0, 0, 0, 727, 729, 9, 0, 0, 0, 728, 727, 1, 0, 0, 0, 729, 732,
    1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 730, 728, 1, 0, 0, 0, 731, 733, 1, 0, 0, 0, 732, 730,
    1, 0, 0, 0, 733, 734, 5, 42, 0, 0, 734, 735, 5, 47, 0, 0, 735, 736, 1, 0, 0, 0, 736, 737,
    6, 106, 0, 0, 737, 214, 1, 0, 0, 0, 738, 739, 5, 47, 0, 0, 739, 740, 5, 47, 0, 0, 740,
    744, 1, 0, 0, 0, 741, 743, 8, 12, 0, 0, 742, 741, 1, 0, 0, 0, 743, 746, 1, 0, 0, 0, 744,
    742, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 747, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 747,
    748, 6, 107, 0, 0, 748, 216, 1, 0, 0, 0, 749, 751, 7, 13, 0, 0, 750, 752, 7, 14, 0, 0,
    751, 750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 754, 1, 0, 0, 0, 753, 755, 7, 4, 0, 0,
    754, 753, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0,
    757, 218, 1, 0, 0, 0, 27, 0, 453, 460, 478, 545, 553, 559, 565, 569, 575, 578, 583,
    586, 591, 602, 608, 684, 686, 695, 697, 706, 713, 720, 730, 744, 751, 756, 1, 6,
    0, 0
];
asirLexer.vocabulary = new antlr.Vocabulary(asirLexer.literalNames, asirLexer.symbolicNames, []);
asirLexer.decisionsToDFA = asirLexer._ATN.decisionToState.map((ds, index) => new antlr.DFA(ds, index));
//# sourceMappingURL=asirLexer.js.map

/***/ }),

/***/ "../pasirser/dist/.antlr/asirParser.js":
/*!*********************************************!*\
  !*** ../pasirser/dist/.antlr/asirParser.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Generated from /home/kanji/risaproject/pasirser/asir.g4 by ANTLR 4.13.1
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionQuitContext = exports.EndContext = exports.FunctionEndContext = exports.StructContext = exports.FunctionStructContext = exports.BreakContext = exports.FunctionBreakContext = exports.ContinueContext = exports.FunctionContinueContext = exports.ReturnContext = exports.FunctionReturnContext = exports.DoContext = exports.FunctionDoContext = exports.WhileContext = exports.FunctionWhileContext = exports.ForContext = exports.FunctionForContext = exports.IfContext = exports.FunctionIfContext = exports.FormDeclContext = exports.FormDeclarationContext = exports.DefContext = exports.FunctionDefinitionContext = exports.PIfContext = exports.PIncContext = exports.PDefContext = exports.PreprocessorContext = exports.PreChrPlusContext = exports.PreChrContext = exports.PrecharContext = exports.ContinueStatementContext = exports.ForStatementContext = exports.ReturnStatementContext = exports.ExprStatementContext = exports.StructStatementContext = exports.DefinitionStatementContext = exports.PreproStatementContext = exports.IfStatementContext = exports.BreakStatementContext = exports.EmptyLineStatementContext = exports.DebugStatementContext = exports.EndStatementContext = exports.WhileStatementContext = exports.ModuleStatementContext = exports.ForwardDeclStatementContext = exports.DoStatementContext = exports.QuitStatementContext = exports.StatementContext = exports.ProgContext = exports.asirParser = void 0;
exports.DpContext = exports.DpolyContext = exports.OptionPairContext = exports.ElseClauseContext = exports.ElifClauseContext = exports.SystemPathContext = exports.TerminatorContext = exports.ExprlistContext = exports.DottedIdentifierContext = exports.QualifiedNameContext = exports.MulDivSurExprContext = exports.NumberLiteralContext = exports.AddSubExprContext = exports.MemberAccessExprContext = exports.ParenExprContext = exports.PostFixExprContext = exports.QuoteExprContext = exports.DpolyLiteralExprContext = exports.QEImplExprContext = exports.PowerExprContext = exports.QEOrExprContext = exports.OrExprContext = exports.UnarySignExprContext = exports.IdLiteralContext = exports.QECompareExprContext = exports.TernaryExprContext = exports.FunctorCallExprContext = exports.QEAndExprContext = exports.FCallExprContext = exports.VarExprContext = exports.QENotExprContext = exports.PrecharExprContext = exports.ListLiteralExprContext = exports.FactorialExprContext = exports.AssignExprContext = exports.RelationalExprContext = exports.UnaryNotExprContext = exports.StringLiteralExprContext = exports.PreFixExprContext = exports.DottedIdExprContext = exports.IndexAccessExprContext = exports.AndExprContext = exports.ExprContext = exports.ModuleStartContext = exports.ModuleAssignContext = exports.ModuleEndContext = exports.FunctionModuleContext = exports.DebugContext = exports.FunctionDebugContext = exports.QuitContext = void 0;
exports.SentenceContext = exports.Sentence1Context = exports.BlockContext = exports.ListExprContext = exports.ListContext = exports.AtFuncContext = exports.ChFuncContext = exports.FuncContext = exports.IndeterminateContext = exports.BefNContext = exports.BefContext = exports.V2IdContext = exports.IdContext = exports.AsGenNumContext = exports.RatNumContext = exports.HexNumContext = exports.ImaNumContext = exports.ApGenNumContext = exports.BitNumContext = exports.DecNumContext = exports.NumContext = exports.FloatContext = exports.DecimalContext = exports.RatContext = exports.RationalContext = void 0;
const antlr = __importStar(__webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs"));
class asirParser extends antlr.Parser {
    get grammarFileName() { return "asir.g4"; }
    get literalNames() { return asirParser.literalNames; }
    get symbolicNames() { return asirParser.symbolicNames; }
    get ruleNames() { return asirParser.ruleNames; }
    get serializedATN() { return asirParser._serializedATN; }
    createFailedPredicateException(predicate, message) {
        return new antlr.FailedPredicateException(this, predicate, message);
    }
    constructor(input) {
        super(input);
        this.interpreter = new antlr.ParserATNSimulator(this, asirParser._ATN, asirParser.decisionsToDFA, new antlr.PredictionContextCache());
    }
    prog() {
        let localContext = new ProgContext(this.context, this.state);
        this.enterRule(localContext, 0, asirParser.RULE_prog);
        let _la;
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 73;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 125829054) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 267142407) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 484255) !== 0)) {
                    {
                        {
                            this.state = 70;
                            this.statement();
                        }
                    }
                    this.state = 75;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
                this.state = 76;
                this.match(asirParser.EOF);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    statement() {
        let localContext = new StatementContext(this.context, this.state);
        this.enterRule(localContext, 2, asirParser.RULE_statement);
        try {
            this.state = 97;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.LTLT:
                case asirParser.COLON2:
                case asirParser.INC:
                case asirParser.DEC:
                case asirParser.NOT:
                case asirParser.PLUS:
                case asirParser.MINUS:
                case asirParser.BACK:
                case asirParser.LPAREN:
                case asirParser.LBRACKET:
                case asirParser.HEX:
                case asirParser.BIT:
                case asirParser.IMAGINARY:
                case asirParser.ASGEN:
                case asirParser.APGEN:
                case asirParser.BEFORE:
                case asirParser.BEFORE_N:
                case asirParser.ATFUNC:
                case asirParser.VAR_2:
                case asirParser.ID:
                case asirParser.FLOAT:
                case asirParser.INT:
                case asirParser.CHAR:
                case asirParser.STRING:
                case asirParser.NOSTRING:
                    localContext = new ExprStatementContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 78;
                        this.expr(0);
                        this.state = 79;
                        this.terminator();
                    }
                    break;
                case asirParser.SEMI:
                case asirParser.DOLLAR:
                    localContext = new EmptyLineStatementContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 81;
                        this.terminator();
                    }
                    break;
                case asirParser.DEF:
                    localContext = new DefinitionStatementContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 82;
                        this.functionDefinition();
                    }
                    break;
                case asirParser.FUNCTION:
                    localContext = new ForwardDeclStatementContext(localContext);
                    this.enterOuterAlt(localContext, 4);
                    {
                        this.state = 83;
                        this.formDeclaration();
                    }
                    break;
                case asirParser.IF:
                    localContext = new IfStatementContext(localContext);
                    this.enterOuterAlt(localContext, 5);
                    {
                        this.state = 84;
                        this.functionIf();
                    }
                    break;
                case asirParser.FOR:
                    localContext = new ForStatementContext(localContext);
                    this.enterOuterAlt(localContext, 6);
                    {
                        this.state = 85;
                        this.functionFor();
                    }
                    break;
                case asirParser.WHILE:
                    localContext = new WhileStatementContext(localContext);
                    this.enterOuterAlt(localContext, 7);
                    {
                        this.state = 86;
                        this.functionWhile();
                    }
                    break;
                case asirParser.DO:
                    localContext = new DoStatementContext(localContext);
                    this.enterOuterAlt(localContext, 8);
                    {
                        this.state = 87;
                        this.functionDo();
                    }
                    break;
                case asirParser.RETURN:
                    localContext = new ReturnStatementContext(localContext);
                    this.enterOuterAlt(localContext, 9);
                    {
                        this.state = 88;
                        this.functionReturn();
                    }
                    break;
                case asirParser.BREAK:
                    localContext = new BreakStatementContext(localContext);
                    this.enterOuterAlt(localContext, 10);
                    {
                        this.state = 89;
                        this.functionBreak();
                    }
                    break;
                case asirParser.CONTINUE:
                    localContext = new ContinueStatementContext(localContext);
                    this.enterOuterAlt(localContext, 11);
                    {
                        this.state = 90;
                        this.functionContinue();
                    }
                    break;
                case asirParser.STRUCT:
                    localContext = new StructStatementContext(localContext);
                    this.enterOuterAlt(localContext, 12);
                    {
                        this.state = 91;
                        this.functionStruct();
                    }
                    break;
                case asirParser.END:
                    localContext = new EndStatementContext(localContext);
                    this.enterOuterAlt(localContext, 13);
                    {
                        this.state = 92;
                        this.functionEnd();
                    }
                    break;
                case asirParser.QUIT:
                    localContext = new QuitStatementContext(localContext);
                    this.enterOuterAlt(localContext, 14);
                    {
                        this.state = 93;
                        this.functionQuit();
                    }
                    break;
                case asirParser.DEBUG:
                    localContext = new DebugStatementContext(localContext);
                    this.enterOuterAlt(localContext, 15);
                    {
                        this.state = 94;
                        this.functionDebug();
                    }
                    break;
                case asirParser.MODULE:
                case asirParser.ENDMODULE:
                case asirParser.EXTERN:
                case asirParser.STATIC:
                case asirParser.GLOBAL:
                case asirParser.LOCAL:
                case asirParser.LOCALF:
                    localContext = new ModuleStatementContext(localContext);
                    this.enterOuterAlt(localContext, 16);
                    {
                        this.state = 95;
                        this.functionModule();
                    }
                    break;
                case asirParser.PIFDEF:
                case asirParser.PIFNDEF:
                case asirParser.PIF:
                case asirParser.PINCLUDE:
                case asirParser.PDEFINE:
                    localContext = new PreproStatementContext(localContext);
                    this.enterOuterAlt(localContext, 17);
                    {
                        this.state = 96;
                        this.preprocessor();
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    prechar() {
        let localContext = new PrecharContext(this.context, this.state);
        this.enterRule(localContext, 4, asirParser.RULE_prechar);
        try {
            this.state = 104;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.CHAR:
                    localContext = new PreChrContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 99;
                        this.match(asirParser.CHAR);
                        this.state = 100;
                        this.match(asirParser.ID);
                    }
                    break;
                case asirParser.ID:
                    localContext = new PreChrPlusContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 101;
                        this.match(asirParser.ID);
                        this.state = 102;
                        this.match(asirParser.CHARPLUS);
                        this.state = 103;
                        this.match(asirParser.ID);
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    preprocessor() {
        let localContext = new PreprocessorContext(this.context, this.state);
        this.enterRule(localContext, 6, asirParser.RULE_preprocessor);
        let _la;
        try {
            this.state = 147;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.PDEFINE:
                    localContext = new PDefContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 106;
                        this.match(asirParser.PDEFINE);
                        this.state = 107;
                        localContext._name = this.match(asirParser.ID);
                        this.state = 120;
                        this.errorHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this.tokenStream, 5, this.context)) {
                            case 1:
                                {
                                    this.state = 108;
                                    this.match(asirParser.LPAREN);
                                    this.state = 117;
                                    this.errorHandler.sync(this);
                                    _la = this.tokenStream.LA(1);
                                    if (_la === 87) {
                                        {
                                            this.state = 109;
                                            localContext._ID = this.match(asirParser.ID);
                                            localContext._params.push(localContext._ID);
                                            this.state = 114;
                                            this.errorHandler.sync(this);
                                            _la = this.tokenStream.LA(1);
                                            while (_la === 62) {
                                                {
                                                    {
                                                        this.state = 110;
                                                        this.match(asirParser.COMMA);
                                                        this.state = 111;
                                                        localContext._ID = this.match(asirParser.ID);
                                                        localContext._params.push(localContext._ID);
                                                    }
                                                }
                                                this.state = 116;
                                                this.errorHandler.sync(this);
                                                _la = this.tokenStream.LA(1);
                                            }
                                        }
                                    }
                                    this.state = 119;
                                    this.match(asirParser.RPAREN);
                                }
                                break;
                        }
                        this.state = 122;
                        localContext._body = this.expr(0);
                    }
                    break;
                case asirParser.PIFDEF:
                case asirParser.PIFNDEF:
                case asirParser.PIF:
                    localContext = new PIfContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 123;
                        localContext._directive = this.tokenStream.LT(1);
                        _la = this.tokenStream.LA(1);
                        if (!(((((_la - 92)) & ~0x1F) === 0 && ((1 << (_la - 92)) & 7) !== 0))) {
                            localContext._directive = this.errorHandler.recoverInline(this);
                        }
                        else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                        }
                        this.state = 124;
                        localContext._condition = this.expr(0);
                        this.state = 128;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 125829054) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 267142407) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 484255) !== 0)) {
                            {
                                {
                                    this.state = 125;
                                    localContext._statement = this.statement();
                                    localContext._thenSymts.push(localContext._statement);
                                }
                            }
                            this.state = 130;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                        this.state = 134;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while (_la === 96) {
                            {
                                {
                                    this.state = 131;
                                    localContext._elifClause = this.elifClause();
                                    localContext._elifs.push(localContext._elifClause);
                                }
                            }
                            this.state = 136;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                        this.state = 138;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        if (_la === 95) {
                            {
                                this.state = 137;
                                localContext._elseBlk = this.elseClause();
                            }
                        }
                        this.state = 140;
                        this.match(asirParser.PENDIF);
                    }
                    break;
                case asirParser.PINCLUDE:
                    localContext = new PIncContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 142;
                        this.match(asirParser.PINCLUDE);
                        this.state = 145;
                        this.errorHandler.sync(this);
                        switch (this.tokenStream.LA(1)) {
                            case asirParser.SYSTEM_PATH_LITERAL:
                                {
                                    this.state = 143;
                                    localContext._path_sys = this.systemPath();
                                }
                                break;
                            case asirParser.STRING:
                                {
                                    this.state = 144;
                                    localContext._path_loc = this.match(asirParser.STRING);
                                }
                                break;
                            default:
                                throw new antlr.NoViableAltException(this);
                        }
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionDefinition() {
        let localContext = new FunctionDefinitionContext(this.context, this.state);
        this.enterRule(localContext, 8, asirParser.RULE_functionDefinition);
        let _la;
        try {
            localContext = new DefContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 149;
                this.match(asirParser.DEF);
                this.state = 150;
                localContext._name = this.indeterminate();
                this.state = 151;
                this.match(asirParser.LPAREN);
                this.state = 160;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 87) {
                    {
                        this.state = 152;
                        localContext._ID = this.match(asirParser.ID);
                        localContext._params.push(localContext._ID);
                        this.state = 157;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while (_la === 62) {
                            {
                                {
                                    this.state = 153;
                                    this.match(asirParser.COMMA);
                                    this.state = 154;
                                    localContext._ID = this.match(asirParser.ID);
                                    localContext._params.push(localContext._ID);
                                }
                            }
                            this.state = 159;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                    }
                }
                this.state = 162;
                this.match(asirParser.RPAREN);
                this.state = 163;
                localContext._body = this.block();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    formDeclaration() {
        let localContext = new FormDeclarationContext(this.context, this.state);
        this.enterRule(localContext, 10, asirParser.RULE_formDeclaration);
        let _la;
        try {
            localContext = new FormDeclContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 165;
                this.match(asirParser.FUNCTION);
                this.state = 166;
                localContext._name = this.indeterminate();
                this.state = 167;
                this.match(asirParser.LPAREN);
                this.state = 176;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 262149) !== 0)) {
                    {
                        this.state = 168;
                        localContext._indeterminate = this.indeterminate();
                        localContext._params.push(localContext._indeterminate);
                        this.state = 173;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while (_la === 62) {
                            {
                                {
                                    this.state = 169;
                                    this.match(asirParser.COMMA);
                                    this.state = 170;
                                    localContext._indeterminate = this.indeterminate();
                                    localContext._params.push(localContext._indeterminate);
                                }
                            }
                            this.state = 175;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                    }
                }
                this.state = 178;
                this.match(asirParser.RPAREN);
                this.state = 179;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionIf() {
        let localContext = new FunctionIfContext(this.context, this.state);
        this.enterRule(localContext, 12, asirParser.RULE_functionIf);
        try {
            localContext = new IfContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 181;
                this.match(asirParser.IF);
                this.state = 182;
                this.match(asirParser.LPAREN);
                this.state = 183;
                localContext._condition = this.expr(0);
                this.state = 184;
                this.match(asirParser.RPAREN);
                this.state = 185;
                localContext._thenBlock = this.block();
                this.state = 188;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 15, this.context)) {
                    case 1:
                        {
                            this.state = 186;
                            this.match(asirParser.ELSE);
                            this.state = 187;
                            localContext._elseBlock = this.block();
                        }
                        break;
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionFor() {
        let localContext = new FunctionForContext(this.context, this.state);
        this.enterRule(localContext, 14, asirParser.RULE_functionFor);
        let _la;
        try {
            localContext = new ForContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 190;
                this.match(asirParser.FOR);
                this.state = 191;
                this.match(asirParser.LPAREN);
                this.state = 193;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 192;
                        localContext._init = this.exprlist();
                    }
                }
                this.state = 195;
                this.match(asirParser.SEMI);
                this.state = 197;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 196;
                        localContext._cond = this.exprlist();
                    }
                }
                this.state = 199;
                this.match(asirParser.SEMI);
                this.state = 201;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 200;
                        localContext._update = this.exprlist();
                    }
                }
                this.state = 203;
                this.match(asirParser.RPAREN);
                this.state = 204;
                this.block();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionWhile() {
        let localContext = new FunctionWhileContext(this.context, this.state);
        this.enterRule(localContext, 16, asirParser.RULE_functionWhile);
        let _la;
        try {
            localContext = new WhileContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 206;
                this.match(asirParser.WHILE);
                this.state = 207;
                this.match(asirParser.LPAREN);
                this.state = 209;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 208;
                        this.exprlist();
                    }
                }
                this.state = 211;
                this.match(asirParser.RPAREN);
                this.state = 212;
                this.block();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionDo() {
        let localContext = new FunctionDoContext(this.context, this.state);
        this.enterRule(localContext, 18, asirParser.RULE_functionDo);
        let _la;
        try {
            localContext = new DoContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 214;
                this.match(asirParser.DO);
                this.state = 215;
                this.block();
                this.state = 216;
                this.match(asirParser.WHILE);
                this.state = 217;
                this.match(asirParser.LPAREN);
                this.state = 219;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 218;
                        this.exprlist();
                    }
                }
                this.state = 221;
                this.match(asirParser.RPAREN);
                this.state = 222;
                this.match(asirParser.SEMI);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionReturn() {
        let localContext = new FunctionReturnContext(this.context, this.state);
        this.enterRule(localContext, 20, asirParser.RULE_functionReturn);
        let _la;
        try {
            localContext = new ReturnContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 224;
                this.match(asirParser.RETURN);
                this.state = 226;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 225;
                        this.expr(0);
                    }
                }
                this.state = 228;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionContinue() {
        let localContext = new FunctionContinueContext(this.context, this.state);
        this.enterRule(localContext, 22, asirParser.RULE_functionContinue);
        try {
            localContext = new ContinueContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 230;
                this.match(asirParser.CONTINUE);
                this.state = 231;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionBreak() {
        let localContext = new FunctionBreakContext(this.context, this.state);
        this.enterRule(localContext, 24, asirParser.RULE_functionBreak);
        try {
            localContext = new BreakContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 233;
                this.match(asirParser.BREAK);
                this.state = 234;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionStruct() {
        let localContext = new FunctionStructContext(this.context, this.state);
        this.enterRule(localContext, 26, asirParser.RULE_functionStruct);
        let _la;
        try {
            localContext = new StructContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 236;
                this.match(asirParser.STRUCT);
                this.state = 237;
                localContext._name = this.indeterminate();
                this.state = 238;
                this.match(asirParser.LBRANCE);
                this.state = 239;
                localContext._indeterminate = this.indeterminate();
                localContext._members.push(localContext._indeterminate);
                this.state = 244;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while (_la === 62) {
                    {
                        {
                            this.state = 240;
                            this.match(asirParser.COMMA);
                            this.state = 241;
                            localContext._indeterminate = this.indeterminate();
                            localContext._members.push(localContext._indeterminate);
                        }
                    }
                    this.state = 246;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
                this.state = 247;
                this.match(asirParser.RBRANCE);
                this.state = 248;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionEnd() {
        let localContext = new FunctionEndContext(this.context, this.state);
        this.enterRule(localContext, 28, asirParser.RULE_functionEnd);
        try {
            localContext = new EndContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 250;
                this.match(asirParser.END);
                this.state = 251;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionQuit() {
        let localContext = new FunctionQuitContext(this.context, this.state);
        this.enterRule(localContext, 30, asirParser.RULE_functionQuit);
        try {
            localContext = new QuitContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 253;
                this.match(asirParser.QUIT);
                this.state = 254;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionDebug() {
        let localContext = new FunctionDebugContext(this.context, this.state);
        this.enterRule(localContext, 32, asirParser.RULE_functionDebug);
        try {
            localContext = new DebugContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 256;
                this.match(asirParser.DEBUG);
                this.state = 257;
                this.terminator();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    functionModule() {
        let localContext = new FunctionModuleContext(this.context, this.state);
        this.enterRule(localContext, 34, asirParser.RULE_functionModule);
        let _la;
        try {
            this.state = 276;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.EXTERN:
                case asirParser.STATIC:
                case asirParser.GLOBAL:
                case asirParser.LOCAL:
                case asirParser.LOCALF:
                    localContext = new ModuleAssignContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 259;
                        _la = this.tokenStream.LA(1);
                        if (!((((_la) & ~0x1F) === 0 && ((1 << _la) & 253952) !== 0))) {
                            this.errorHandler.recoverInline(this);
                        }
                        else {
                            this.errorHandler.reportMatch(this);
                            this.consume();
                        }
                        this.state = 260;
                        this.indeterminate();
                        this.state = 265;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while (_la === 62) {
                            {
                                {
                                    this.state = 261;
                                    this.match(asirParser.COMMA);
                                    this.state = 262;
                                    this.indeterminate();
                                }
                            }
                            this.state = 267;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                        this.state = 268;
                        this.terminator();
                    }
                    break;
                case asirParser.MODULE:
                    localContext = new ModuleStartContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 270;
                        this.match(asirParser.MODULE);
                        this.state = 271;
                        this.indeterminate();
                        this.state = 272;
                        this.terminator();
                    }
                    break;
                case asirParser.ENDMODULE:
                    localContext = new ModuleEndContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 274;
                        this.match(asirParser.ENDMODULE);
                        this.state = 275;
                        this.terminator();
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    expr(_p) {
        if (_p === undefined) {
            _p = 0;
        }
        let parentContext = this.context;
        let parentState = this.state;
        let localContext = new ExprContext(this.context, parentState);
        let previousContext = localContext;
        let _startState = 36;
        this.enterRecursionRule(localContext, 36, asirParser.RULE_expr, _p);
        let _la;
        try {
            let alternative;
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 353;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 34, this.context)) {
                    case 1:
                        {
                            localContext = new ParenExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 279;
                            this.match(asirParser.LPAREN);
                            this.state = 280;
                            this.expr(0);
                            this.state = 281;
                            this.match(asirParser.RPAREN);
                        }
                        break;
                    case 2:
                        {
                            localContext = new NumberLiteralContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 283;
                            this.num();
                        }
                        break;
                    case 3:
                        {
                            localContext = new IdLiteralContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 284;
                            this.id();
                        }
                        break;
                    case 4:
                        {
                            localContext = new StringLiteralExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 285;
                            this.match(asirParser.STRING);
                        }
                        break;
                    case 5:
                        {
                            localContext = new ListLiteralExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 286;
                            this.list();
                        }
                        break;
                    case 6:
                        {
                            localContext = new DpolyLiteralExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 287;
                            this.dpoly();
                        }
                        break;
                    case 7:
                        {
                            localContext = new PrecharExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 288;
                            this.prechar();
                        }
                        break;
                    case 8:
                        {
                            localContext = new DottedIdExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 289;
                            this.dottedIdentifier();
                        }
                        break;
                    case 9:
                        {
                            localContext = new VarExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 290;
                            this.indeterminate();
                        }
                        break;
                    case 10:
                        {
                            localContext = new FCallExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 292;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if (_la === 24) {
                                {
                                    this.state = 291;
                                    localContext._is_global = this.match(asirParser.COLON2);
                                }
                            }
                            this.state = 294;
                            localContext._path = this.qualifiedName();
                            this.state = 305;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if (_la === 54) {
                                {
                                    this.state = 295;
                                    this.match(asirParser.LBRANCE);
                                    this.state = 296;
                                    localContext._INT = this.match(asirParser.INT);
                                    localContext._diffOrders.push(localContext._INT);
                                    this.state = 301;
                                    this.errorHandler.sync(this);
                                    _la = this.tokenStream.LA(1);
                                    while (_la === 62) {
                                        {
                                            {
                                                this.state = 297;
                                                this.match(asirParser.COMMA);
                                                this.state = 298;
                                                localContext._INT = this.match(asirParser.INT);
                                                localContext._diffOrders.push(localContext._INT);
                                            }
                                        }
                                        this.state = 303;
                                        this.errorHandler.sync(this);
                                        _la = this.tokenStream.LA(1);
                                    }
                                    this.state = 304;
                                    this.match(asirParser.RBRANCE);
                                }
                            }
                            this.state = 307;
                            this.match(asirParser.LPAREN);
                            this.state = 309;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                                {
                                    this.state = 308;
                                    localContext._args = this.exprlist();
                                }
                            }
                            this.state = 320;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if (_la === 51) {
                                {
                                    this.state = 311;
                                    this.match(asirParser.MID);
                                    this.state = 312;
                                    localContext._optionPair = this.optionPair();
                                    localContext._options.push(localContext._optionPair);
                                    this.state = 317;
                                    this.errorHandler.sync(this);
                                    _la = this.tokenStream.LA(1);
                                    while (_la === 62) {
                                        {
                                            {
                                                this.state = 313;
                                                this.match(asirParser.COMMA);
                                                this.state = 314;
                                                localContext._optionPair = this.optionPair();
                                                localContext._options.push(localContext._optionPair);
                                            }
                                        }
                                        this.state = 319;
                                        this.errorHandler.sync(this);
                                        _la = this.tokenStream.LA(1);
                                    }
                                }
                            }
                            this.state = 322;
                            this.match(asirParser.RPAREN);
                        }
                        break;
                    case 11:
                        {
                            localContext = new FunctorCallExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 324;
                            this.match(asirParser.LPAREN);
                            this.state = 325;
                            this.match(asirParser.MULT);
                            this.state = 326;
                            localContext._callee = this.expr(0);
                            this.state = 327;
                            this.match(asirParser.RPAREN);
                            this.state = 328;
                            this.match(asirParser.LPAREN);
                            this.state = 330;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                                {
                                    this.state = 329;
                                    localContext._args = this.exprlist();
                                }
                            }
                            this.state = 341;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                            if (_la === 51) {
                                {
                                    this.state = 332;
                                    this.match(asirParser.MID);
                                    this.state = 333;
                                    localContext._optionPair = this.optionPair();
                                    localContext._options.push(localContext._optionPair);
                                    this.state = 338;
                                    this.errorHandler.sync(this);
                                    _la = this.tokenStream.LA(1);
                                    while (_la === 62) {
                                        {
                                            {
                                                this.state = 334;
                                                this.match(asirParser.COMMA);
                                                this.state = 335;
                                                localContext._optionPair = this.optionPair();
                                                localContext._options.push(localContext._optionPair);
                                            }
                                        }
                                        this.state = 340;
                                        this.errorHandler.sync(this);
                                        _la = this.tokenStream.LA(1);
                                    }
                                }
                            }
                            this.state = 343;
                            this.match(asirParser.RPAREN);
                        }
                        break;
                    case 12:
                        {
                            localContext = new PreFixExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 345;
                            _la = this.tokenStream.LA(1);
                            if (!(_la === 25 || _la === 26)) {
                                this.errorHandler.recoverInline(this);
                            }
                            else {
                                this.errorHandler.reportMatch(this);
                                this.consume();
                            }
                            this.state = 346;
                            this.expr(17);
                        }
                        break;
                    case 13:
                        {
                            localContext = new UnarySignExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 347;
                            _la = this.tokenStream.LA(1);
                            if (!(_la === 43 || _la === 44)) {
                                this.errorHandler.recoverInline(this);
                            }
                            else {
                                this.errorHandler.reportMatch(this);
                                this.consume();
                            }
                            this.state = 348;
                            this.expr(16);
                        }
                        break;
                    case 14:
                        {
                            localContext = new UnaryNotExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 349;
                            this.match(asirParser.NOT);
                            this.state = 350;
                            this.expr(15);
                        }
                        break;
                    case 15:
                        {
                            localContext = new QuoteExprContext(localContext);
                            this.context = localContext;
                            previousContext = localContext;
                            this.state = 351;
                            this.match(asirParser.BACK);
                            this.state = 352;
                            this.expr(3);
                        }
                        break;
                }
                this.context.stop = this.tokenStream.LT(-1);
                this.state = 419;
                this.errorHandler.sync(this);
                alternative = this.interpreter.adaptivePredict(this.tokenStream, 38, this.context);
                while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER) {
                    if (alternative === 1) {
                        if (this.parseListeners != null) {
                            this.triggerExitRuleEvent();
                        }
                        previousContext = localContext;
                        {
                            this.state = 417;
                            this.errorHandler.sync(this);
                            switch (this.interpreter.adaptivePredict(this.tokenStream, 37, this.context)) {
                                case 1:
                                    {
                                        localContext = new PowerExprContext(new ExprContext(parentContext, parentState));
                                        localContext._base = previousContext;
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 355;
                                        if (!(this.precpred(this.context, 14))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 14)");
                                        }
                                        this.state = 356;
                                        this.match(asirParser.POWER);
                                        this.state = 357;
                                        localContext._exponent = this.expr(14);
                                    }
                                    break;
                                case 2:
                                    {
                                        localContext = new MulDivSurExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 358;
                                        if (!(this.precpred(this.context, 13))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 13)");
                                        }
                                        this.state = 359;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(((((_la - 45)) & ~0x1F) === 0 && ((1 << (_la - 45)) & 7) !== 0))) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 360;
                                        this.expr(14);
                                    }
                                    break;
                                case 3:
                                    {
                                        localContext = new AddSubExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 361;
                                        if (!(this.precpred(this.context, 12))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 12)");
                                        }
                                        this.state = 362;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(_la === 43 || _la === 44)) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 363;
                                        this.expr(13);
                                    }
                                    break;
                                case 4:
                                    {
                                        localContext = new RelationalExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 364;
                                        if (!(this.precpred(this.context, 11))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 11)");
                                        }
                                        this.state = 365;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(((((_la - 34)) & ~0x1F) === 0 && ((1 << (_la - 34)) & 63) !== 0))) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 366;
                                        this.expr(12);
                                    }
                                    break;
                                case 5:
                                    {
                                        localContext = new AndExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 367;
                                        if (!(this.precpred(this.context, 10))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 10)");
                                        }
                                        this.state = 368;
                                        this.match(asirParser.AND);
                                        this.state = 369;
                                        this.expr(11);
                                    }
                                    break;
                                case 6:
                                    {
                                        localContext = new OrExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 370;
                                        if (!(this.precpred(this.context, 9))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 9)");
                                        }
                                        this.state = 371;
                                        this.match(asirParser.OR);
                                        this.state = 372;
                                        this.expr(10);
                                    }
                                    break;
                                case 7:
                                    {
                                        localContext = new QECompareExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 373;
                                        if (!(this.precpred(this.context, 8))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 8)");
                                        }
                                        this.state = 374;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(((((_la - 70)) & ~0x1F) === 0 && ((1 << (_la - 70)) & 127) !== 0))) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 375;
                                        this.expr(9);
                                    }
                                    break;
                                case 8:
                                    {
                                        localContext = new QEAndExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 376;
                                        if (!(this.precpred(this.context, 7))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 7)");
                                        }
                                        this.state = 377;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(_la === 78 || _la === 79)) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 378;
                                        this.expr(8);
                                    }
                                    break;
                                case 9:
                                    {
                                        localContext = new QEOrExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 379;
                                        if (!(this.precpred(this.context, 6))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 6)");
                                        }
                                        this.state = 380;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(_la === 80 || _la === 81)) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 381;
                                        this.expr(7);
                                    }
                                    break;
                                case 10:
                                    {
                                        localContext = new QENotExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 382;
                                        if (!(this.precpred(this.context, 5))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 5)");
                                        }
                                        this.state = 383;
                                        this.match(asirParser.QE_8);
                                        this.state = 384;
                                        this.expr(6);
                                    }
                                    break;
                                case 11:
                                    {
                                        localContext = new QEImplExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 385;
                                        if (!(this.precpred(this.context, 4))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 4)");
                                        }
                                        this.state = 386;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(((((_la - 82)) & ~0x1F) === 0 && ((1 << (_la - 82)) & 7) !== 0))) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 387;
                                        this.expr(5);
                                    }
                                    break;
                                case 12:
                                    {
                                        localContext = new AssignExprContext(new ExprContext(parentContext, parentState));
                                        localContext._left = previousContext;
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 388;
                                        if (!(this.precpred(this.context, 1))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 1)");
                                        }
                                        this.state = 389;
                                        localContext._op = this.tokenStream.LT(1);
                                        _la = this.tokenStream.LA(1);
                                        if (!(((((_la - 27)) & ~0x1F) === 0 && ((1 << (_la - 27)) & 4194367) !== 0))) {
                                            localContext._op = this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                        this.state = 390;
                                        localContext._right = this.expr(1);
                                    }
                                    break;
                                case 13:
                                    {
                                        localContext = new MemberAccessExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 391;
                                        if (!(this.precpred(this.context, 21))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 21)");
                                        }
                                        this.state = 394;
                                        this.errorHandler.sync(this);
                                        alternative = 1;
                                        do {
                                            switch (alternative) {
                                                case 1:
                                                    {
                                                        {
                                                            this.state = 392;
                                                            this.match(asirParser.ARROW);
                                                            this.state = 393;
                                                            this.indeterminate();
                                                        }
                                                    }
                                                    break;
                                                default:
                                                    throw new antlr.NoViableAltException(this);
                                            }
                                            this.state = 396;
                                            this.errorHandler.sync(this);
                                            alternative = this.interpreter.adaptivePredict(this.tokenStream, 35, this.context);
                                        } while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER);
                                    }
                                    break;
                                case 14:
                                    {
                                        localContext = new IndexAccessExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 398;
                                        if (!(this.precpred(this.context, 20))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 20)");
                                        }
                                        this.state = 403;
                                        this.errorHandler.sync(this);
                                        alternative = 1;
                                        do {
                                            switch (alternative) {
                                                case 1:
                                                    {
                                                        {
                                                            this.state = 399;
                                                            this.match(asirParser.LBRACKET);
                                                            this.state = 400;
                                                            localContext._expr = this.expr(0);
                                                            localContext._indices.push(localContext._expr);
                                                            this.state = 401;
                                                            this.match(asirParser.RBRACKET);
                                                        }
                                                    }
                                                    break;
                                                default:
                                                    throw new antlr.NoViableAltException(this);
                                            }
                                            this.state = 405;
                                            this.errorHandler.sync(this);
                                            alternative = this.interpreter.adaptivePredict(this.tokenStream, 36, this.context);
                                        } while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER);
                                    }
                                    break;
                                case 15:
                                    {
                                        localContext = new PostFixExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 407;
                                        if (!(this.precpred(this.context, 19))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 19)");
                                        }
                                        this.state = 408;
                                        _la = this.tokenStream.LA(1);
                                        if (!(_la === 25 || _la === 26)) {
                                            this.errorHandler.recoverInline(this);
                                        }
                                        else {
                                            this.errorHandler.reportMatch(this);
                                            this.consume();
                                        }
                                    }
                                    break;
                                case 16:
                                    {
                                        localContext = new FactorialExprContext(new ExprContext(parentContext, parentState));
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 409;
                                        if (!(this.precpred(this.context, 18))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 18)");
                                        }
                                        this.state = 410;
                                        this.match(asirParser.NOT);
                                    }
                                    break;
                                case 17:
                                    {
                                        localContext = new TernaryExprContext(new ExprContext(parentContext, parentState));
                                        localContext._condition = previousContext;
                                        this.pushNewRecursionContext(localContext, _startState, asirParser.RULE_expr);
                                        this.state = 411;
                                        if (!(this.precpred(this.context, 2))) {
                                            throw this.createFailedPredicateException("this.precpred(this.context, 2)");
                                        }
                                        {
                                            this.state = 412;
                                            this.match(asirParser.QUESTION);
                                            this.state = 413;
                                            localContext._consequence = this.expr(0);
                                            this.state = 414;
                                            this.match(asirParser.COLON);
                                            this.state = 415;
                                            localContext._alternative = this.expr(0);
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                    this.state = 421;
                    this.errorHandler.sync(this);
                    alternative = this.interpreter.adaptivePredict(this.tokenStream, 38, this.context);
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.unrollRecursionContexts(parentContext);
        }
        return localContext;
    }
    qualifiedName() {
        let localContext = new QualifiedNameContext(this.context, this.state);
        this.enterRule(localContext, 38, asirParser.RULE_qualifiedName);
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 424;
                this.errorHandler.sync(this);
                switch (this.interpreter.adaptivePredict(this.tokenStream, 39, this.context)) {
                    case 1:
                        {
                            this.state = 422;
                            localContext._moduleName = this.match(asirParser.ID);
                            this.state = 423;
                            this.match(asirParser.DOT);
                        }
                        break;
                }
                this.state = 426;
                localContext._funcName = this.indeterminate();
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    dottedIdentifier() {
        let localContext = new DottedIdentifierContext(this.context, this.state);
        this.enterRule(localContext, 40, asirParser.RULE_dottedIdentifier);
        try {
            let alternative;
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 428;
                this.indeterminate();
                this.state = 431;
                this.errorHandler.sync(this);
                alternative = 1;
                do {
                    switch (alternative) {
                        case 1:
                            {
                                {
                                    this.state = 429;
                                    this.match(asirParser.DOT);
                                    this.state = 430;
                                    this.indeterminate();
                                }
                            }
                            break;
                        default:
                            throw new antlr.NoViableAltException(this);
                    }
                    this.state = 433;
                    this.errorHandler.sync(this);
                    alternative = this.interpreter.adaptivePredict(this.tokenStream, 40, this.context);
                } while (alternative !== 2 && alternative !== antlr.ATN.INVALID_ALT_NUMBER);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    exprlist() {
        let localContext = new ExprlistContext(this.context, this.state);
        this.enterRule(localContext, 42, asirParser.RULE_exprlist);
        let _la;
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 435;
                this.expr(0);
                this.state = 440;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while (_la === 62) {
                    {
                        {
                            this.state = 436;
                            this.match(asirParser.COMMA);
                            this.state = 437;
                            this.expr(0);
                        }
                    }
                    this.state = 442;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    terminator() {
        let localContext = new TerminatorContext(this.context, this.state);
        this.enterRule(localContext, 44, asirParser.RULE_terminator);
        let _la;
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 443;
                _la = this.tokenStream.LA(1);
                if (!(_la === 60 || _la === 61)) {
                    this.errorHandler.recoverInline(this);
                }
                else {
                    this.errorHandler.reportMatch(this);
                    this.consume();
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    systemPath() {
        let localContext = new SystemPathContext(this.context, this.state);
        this.enterRule(localContext, 46, asirParser.RULE_systemPath);
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 445;
                this.match(asirParser.SYSTEM_PATH_LITERAL);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    elifClause() {
        let localContext = new ElifClauseContext(this.context, this.state);
        this.enterRule(localContext, 48, asirParser.RULE_elifClause);
        let _la;
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 447;
                this.match(asirParser.PELIF);
                this.state = 448;
                localContext._condition = this.expr(0);
                this.state = 452;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 125829054) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 267142407) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 484255) !== 0)) {
                    {
                        {
                            this.state = 449;
                            localContext._statement = this.statement();
                            localContext._statements.push(localContext._statement);
                        }
                    }
                    this.state = 454;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    elseClause() {
        let localContext = new ElseClauseContext(this.context, this.state);
        this.enterRule(localContext, 50, asirParser.RULE_elseClause);
        let _la;
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 455;
                this.match(asirParser.PELSE);
                this.state = 459;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 125829054) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 267142407) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 484255) !== 0)) {
                    {
                        {
                            this.state = 456;
                            localContext._statement = this.statement();
                            localContext._statements.push(localContext._statement);
                        }
                    }
                    this.state = 461;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    optionPair() {
        let localContext = new OptionPairContext(this.context, this.state);
        this.enterRule(localContext, 52, asirParser.RULE_optionPair);
        try {
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 462;
                localContext._key = this.indeterminate();
                this.state = 463;
                this.match(asirParser.ASSIGN);
                this.state = 464;
                localContext._value = this.expr(0);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    dpoly() {
        let localContext = new DpolyContext(this.context, this.state);
        this.enterRule(localContext, 54, asirParser.RULE_dpoly);
        let _la;
        try {
            localContext = new DpContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 466;
                this.match(asirParser.LTLT);
                this.state = 467;
                this.match(asirParser.INT);
                this.state = 472;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                while (_la === 62) {
                    {
                        {
                            this.state = 468;
                            this.match(asirParser.COMMA);
                            this.state = 469;
                            this.match(asirParser.INT);
                        }
                    }
                    this.state = 474;
                    this.errorHandler.sync(this);
                    _la = this.tokenStream.LA(1);
                }
                this.state = 477;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 59) {
                    {
                        this.state = 475;
                        this.match(asirParser.COLON);
                        this.state = 476;
                        this.match(asirParser.INT);
                    }
                }
                this.state = 479;
                this.match(asirParser.GTGT);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    rational() {
        let localContext = new RationalContext(this.context, this.state);
        this.enterRule(localContext, 56, asirParser.RULE_rational);
        let _la;
        try {
            localContext = new RatContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 482;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 44) {
                    {
                        this.state = 481;
                        this.match(asirParser.MINUS);
                    }
                }
                this.state = 484;
                this.match(asirParser.INT);
                this.state = 485;
                this.match(asirParser.DIV);
                this.state = 487;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if (_la === 44) {
                    {
                        this.state = 486;
                        this.match(asirParser.MINUS);
                    }
                }
                this.state = 489;
                this.match(asirParser.INT);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    decimal() {
        let localContext = new DecimalContext(this.context, this.state);
        this.enterRule(localContext, 58, asirParser.RULE_decimal);
        let _la;
        try {
            localContext = new FloatContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 491;
                _la = this.tokenStream.LA(1);
                if (!(_la === 88 || _la === 89)) {
                    this.errorHandler.recoverInline(this);
                }
                else {
                    this.errorHandler.reportMatch(this);
                    this.consume();
                }
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    num() {
        let localContext = new NumContext(this.context, this.state);
        this.enterRule(localContext, 60, asirParser.RULE_num);
        try {
            this.state = 500;
            this.errorHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this.tokenStream, 48, this.context)) {
                case 1:
                    localContext = new HexNumContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 493;
                        this.match(asirParser.HEX);
                    }
                    break;
                case 2:
                    localContext = new BitNumContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 494;
                        this.match(asirParser.BIT);
                    }
                    break;
                case 3:
                    localContext = new RatNumContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 495;
                        this.rational();
                    }
                    break;
                case 4:
                    localContext = new DecNumContext(localContext);
                    this.enterOuterAlt(localContext, 4);
                    {
                        this.state = 496;
                        this.decimal();
                    }
                    break;
                case 5:
                    localContext = new ImaNumContext(localContext);
                    this.enterOuterAlt(localContext, 5);
                    {
                        this.state = 497;
                        this.match(asirParser.IMAGINARY);
                    }
                    break;
                case 6:
                    localContext = new AsGenNumContext(localContext);
                    this.enterOuterAlt(localContext, 6);
                    {
                        this.state = 498;
                        this.match(asirParser.ASGEN);
                    }
                    break;
                case 7:
                    localContext = new ApGenNumContext(localContext);
                    this.enterOuterAlt(localContext, 7);
                    {
                        this.state = 499;
                        this.match(asirParser.APGEN);
                    }
                    break;
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    id() {
        let localContext = new IdContext(this.context, this.state);
        this.enterRule(localContext, 62, asirParser.RULE_id);
        try {
            this.state = 505;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.BEFORE:
                    localContext = new BefContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 502;
                        this.match(asirParser.BEFORE);
                    }
                    break;
                case asirParser.BEFORE_N:
                    localContext = new BefNContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 503;
                        this.match(asirParser.BEFORE_N);
                    }
                    break;
                case asirParser.VAR_2:
                    localContext = new V2IdContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 504;
                        this.match(asirParser.VAR_2);
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    indeterminate() {
        let localContext = new IndeterminateContext(this.context, this.state);
        this.enterRule(localContext, 64, asirParser.RULE_indeterminate);
        try {
            this.state = 510;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.ID:
                    localContext = new FuncContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 507;
                        this.match(asirParser.ID);
                    }
                    break;
                case asirParser.ATFUNC:
                    localContext = new AtFuncContext(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 508;
                        this.match(asirParser.ATFUNC);
                    }
                    break;
                case asirParser.NOSTRING:
                    localContext = new ChFuncContext(localContext);
                    this.enterOuterAlt(localContext, 3);
                    {
                        this.state = 509;
                        this.match(asirParser.NOSTRING);
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    list() {
        let localContext = new ListContext(this.context, this.state);
        this.enterRule(localContext, 66, asirParser.RULE_list);
        let _la;
        try {
            localContext = new ListExprContext(localContext);
            this.enterOuterAlt(localContext, 1);
            {
                this.state = 512;
                this.match(asirParser.LBRACKET);
                this.state = 514;
                this.errorHandler.sync(this);
                _la = this.tokenStream.LA(1);
                if ((((_la) & ~0x1F) === 0 && ((1 << _la) & 121634816) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 266355975) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 458783) !== 0)) {
                    {
                        this.state = 513;
                        this.exprlist();
                    }
                }
                this.state = 516;
                this.match(asirParser.RBRACKET);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    block() {
        let localContext = new BlockContext(this.context, this.state);
        this.enterRule(localContext, 68, asirParser.RULE_block);
        let _la;
        try {
            this.state = 527;
            this.errorHandler.sync(this);
            switch (this.tokenStream.LA(1)) {
                case asirParser.LBRANCE:
                    localContext = new SentenceContext(localContext);
                    this.enterOuterAlt(localContext, 1);
                    {
                        this.state = 518;
                        this.match(asirParser.LBRANCE);
                        this.state = 522;
                        this.errorHandler.sync(this);
                        _la = this.tokenStream.LA(1);
                        while ((((_la) & ~0x1F) === 0 && ((1 << _la) & 125829054) !== 0) || ((((_la - 42)) & ~0x1F) === 0 && ((1 << (_la - 42)) & 267142407) !== 0) || ((((_la - 85)) & ~0x1F) === 0 && ((1 << (_la - 85)) & 484255) !== 0)) {
                            {
                                {
                                    this.state = 519;
                                    this.statement();
                                }
                            }
                            this.state = 524;
                            this.errorHandler.sync(this);
                            _la = this.tokenStream.LA(1);
                        }
                        this.state = 525;
                        this.match(asirParser.RBRANCE);
                    }
                    break;
                case asirParser.DEF:
                case asirParser.IF:
                case asirParser.FOR:
                case asirParser.WHILE:
                case asirParser.DO:
                case asirParser.RETURN:
                case asirParser.CONTINUE:
                case asirParser.BREAK:
                case asirParser.STRUCT:
                case asirParser.MODULE:
                case asirParser.ENDMODULE:
                case asirParser.EXTERN:
                case asirParser.STATIC:
                case asirParser.GLOBAL:
                case asirParser.LOCAL:
                case asirParser.LOCALF:
                case asirParser.FUNCTION:
                case asirParser.END:
                case asirParser.QUIT:
                case asirParser.DEBUG:
                case asirParser.LTLT:
                case asirParser.COLON2:
                case asirParser.INC:
                case asirParser.DEC:
                case asirParser.NOT:
                case asirParser.PLUS:
                case asirParser.MINUS:
                case asirParser.BACK:
                case asirParser.LPAREN:
                case asirParser.LBRACKET:
                case asirParser.SEMI:
                case asirParser.DOLLAR:
                case asirParser.HEX:
                case asirParser.BIT:
                case asirParser.IMAGINARY:
                case asirParser.ASGEN:
                case asirParser.APGEN:
                case asirParser.BEFORE:
                case asirParser.BEFORE_N:
                case asirParser.ATFUNC:
                case asirParser.VAR_2:
                case asirParser.ID:
                case asirParser.FLOAT:
                case asirParser.INT:
                case asirParser.PIFDEF:
                case asirParser.PIFNDEF:
                case asirParser.PIF:
                case asirParser.PINCLUDE:
                case asirParser.PDEFINE:
                case asirParser.CHAR:
                case asirParser.STRING:
                case asirParser.NOSTRING:
                    localContext = new Sentence1Context(localContext);
                    this.enterOuterAlt(localContext, 2);
                    {
                        this.state = 526;
                        this.statement();
                    }
                    break;
                default:
                    throw new antlr.NoViableAltException(this);
            }
        }
        catch (re) {
            if (re instanceof antlr.RecognitionException) {
                this.errorHandler.reportError(this, re);
                this.errorHandler.recover(this, re);
            }
            else {
                throw re;
            }
        }
        finally {
            this.exitRule();
        }
        return localContext;
    }
    sempred(localContext, ruleIndex, predIndex) {
        switch (ruleIndex) {
            case 18:
                return this.expr_sempred(localContext, predIndex);
        }
        return true;
    }
    expr_sempred(localContext, predIndex) {
        switch (predIndex) {
            case 0:
                return this.precpred(this.context, 14);
            case 1:
                return this.precpred(this.context, 13);
            case 2:
                return this.precpred(this.context, 12);
            case 3:
                return this.precpred(this.context, 11);
            case 4:
                return this.precpred(this.context, 10);
            case 5:
                return this.precpred(this.context, 9);
            case 6:
                return this.precpred(this.context, 8);
            case 7:
                return this.precpred(this.context, 7);
            case 8:
                return this.precpred(this.context, 6);
            case 9:
                return this.precpred(this.context, 5);
            case 10:
                return this.precpred(this.context, 4);
            case 11:
                return this.precpred(this.context, 1);
            case 12:
                return this.precpred(this.context, 21);
            case 13:
                return this.precpred(this.context, 20);
            case 14:
                return this.precpred(this.context, 19);
            case 15:
                return this.precpred(this.context, 18);
            case 16:
                return this.precpred(this.context, 2);
        }
        return true;
    }
    static get _ATN() {
        if (!asirParser.__ATN) {
            asirParser.__ATN = new antlr.ATNDeserializer().deserialize(asirParser._serializedATN);
        }
        return asirParser.__ATN;
    }
    get vocabulary() {
        return asirParser.vocabulary;
    }
}
exports.asirParser = asirParser;
asirParser.DEF = 1;
asirParser.IF = 2;
asirParser.FOR = 3;
asirParser.WHILE = 4;
asirParser.DO = 5;
asirParser.ELSE = 6;
asirParser.RETURN = 7;
asirParser.CONTINUE = 8;
asirParser.BREAK = 9;
asirParser.STRUCT = 10;
asirParser.MODULE = 11;
asirParser.ENDMODULE = 12;
asirParser.EXTERN = 13;
asirParser.STATIC = 14;
asirParser.GLOBAL = 15;
asirParser.LOCAL = 16;
asirParser.LOCALF = 17;
asirParser.FUNCTION = 18;
asirParser.END = 19;
asirParser.QUIT = 20;
asirParser.DEBUG = 21;
asirParser.LTLT = 22;
asirParser.GTGT = 23;
asirParser.COLON2 = 24;
asirParser.INC = 25;
asirParser.DEC = 26;
asirParser.PLUSEQ = 27;
asirParser.MINUSEQ = 28;
asirParser.MULTEQ = 29;
asirParser.DIVEQ = 30;
asirParser.SUREQ = 31;
asirParser.POWEREQ = 32;
asirParser.ARROW = 33;
asirParser.EQ = 34;
asirParser.NEQ = 35;
asirParser.LE = 36;
asirParser.GE = 37;
asirParser.LT = 38;
asirParser.GT = 39;
asirParser.AND = 40;
asirParser.OR = 41;
asirParser.NOT = 42;
asirParser.PLUS = 43;
asirParser.MINUS = 44;
asirParser.MULT = 45;
asirParser.DIV = 46;
asirParser.SUR = 47;
asirParser.POWER = 48;
asirParser.ASSIGN = 49;
asirParser.BACK = 50;
asirParser.MID = 51;
asirParser.LPAREN = 52;
asirParser.RPAREN = 53;
asirParser.LBRANCE = 54;
asirParser.RBRANCE = 55;
asirParser.LBRACKET = 56;
asirParser.RBRACKET = 57;
asirParser.QUESTION = 58;
asirParser.COLON = 59;
asirParser.SEMI = 60;
asirParser.DOLLAR = 61;
asirParser.COMMA = 62;
asirParser.HEX = 63;
asirParser.BIT = 64;
asirParser.IMAGINARY = 65;
asirParser.ASGEN = 66;
asirParser.APGEN = 67;
asirParser.BEFORE = 68;
asirParser.BEFORE_N = 69;
asirParser.QE_1 = 70;
asirParser.QE_2 = 71;
asirParser.QE_3 = 72;
asirParser.QE_4 = 73;
asirParser.QE_5 = 74;
asirParser.QE_6 = 75;
asirParser.QE_7 = 76;
asirParser.QE_8 = 77;
asirParser.QE_9 = 78;
asirParser.QE_10 = 79;
asirParser.QE_11 = 80;
asirParser.QE_12 = 81;
asirParser.QE_IMPL = 82;
asirParser.QE_REPL = 83;
asirParser.QE_EQUIV = 84;
asirParser.ATFUNC = 85;
asirParser.VAR_2 = 86;
asirParser.ID = 87;
asirParser.FLOAT = 88;
asirParser.INT = 89;
asirParser.DOT = 90;
asirParser.PCOMMENT = 91;
asirParser.PIFDEF = 92;
asirParser.PIFNDEF = 93;
asirParser.PIF = 94;
asirParser.PELSE = 95;
asirParser.PELIF = 96;
asirParser.PENDIF = 97;
asirParser.PINCLUDE = 98;
asirParser.PDEFINE = 99;
asirParser.CHARPLUS = 100;
asirParser.CHAR = 101;
asirParser.STRING = 102;
asirParser.NOSTRING = 103;
asirParser.SYSTEM_PATH_LITERAL = 104;
asirParser.NEWLINE = 105;
asirParser.WS = 106;
asirParser.COMMENT = 107;
asirParser.LCOMMENT = 108;
asirParser.RULE_prog = 0;
asirParser.RULE_statement = 1;
asirParser.RULE_prechar = 2;
asirParser.RULE_preprocessor = 3;
asirParser.RULE_functionDefinition = 4;
asirParser.RULE_formDeclaration = 5;
asirParser.RULE_functionIf = 6;
asirParser.RULE_functionFor = 7;
asirParser.RULE_functionWhile = 8;
asirParser.RULE_functionDo = 9;
asirParser.RULE_functionReturn = 10;
asirParser.RULE_functionContinue = 11;
asirParser.RULE_functionBreak = 12;
asirParser.RULE_functionStruct = 13;
asirParser.RULE_functionEnd = 14;
asirParser.RULE_functionQuit = 15;
asirParser.RULE_functionDebug = 16;
asirParser.RULE_functionModule = 17;
asirParser.RULE_expr = 18;
asirParser.RULE_qualifiedName = 19;
asirParser.RULE_dottedIdentifier = 20;
asirParser.RULE_exprlist = 21;
asirParser.RULE_terminator = 22;
asirParser.RULE_systemPath = 23;
asirParser.RULE_elifClause = 24;
asirParser.RULE_elseClause = 25;
asirParser.RULE_optionPair = 26;
asirParser.RULE_dpoly = 27;
asirParser.RULE_rational = 28;
asirParser.RULE_decimal = 29;
asirParser.RULE_num = 30;
asirParser.RULE_id = 31;
asirParser.RULE_indeterminate = 32;
asirParser.RULE_list = 33;
asirParser.RULE_block = 34;
asirParser.literalNames = [
    null, "'def'", "'if'", "'for'", "'while'", "'do'", "'else'", "'return'",
    "'continue'", "'break'", "'struct'", "'module'", "'endmodule'",
    "'extern'", "'static'", "'global'", "'local'", "'localf'", "'function'",
    "'end'", "'quit'", "'debug'", "'<<'", "'>>'", "'::'", "'++'", "'--'",
    "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'->'", "'=='",
    "'!='", "'<='", "'>='", "'<'", "'>'", "'&&'", "'||'", "'!'", "'+'",
    "'-'", "'*'", "'/'", "'%'", "'^'", "'='", "'`'", "'|'", "'('", "')'",
    "'{'", "'}'", "'['", "']'", "'?'", "':'", "';'", "'$'", "','", null,
    null, "'@i'", "'@s'", "'@p'", "'@@'", null, "'@>='", "'@<='", "'@>'",
    "'@<'", "'@=='", "'@='", "'@!='", "'@!'", "'@&&'", "'@&'", "'@||'",
    "'@|'", "'@impl'", "'@repl'", "'@equiv'", null, "'@'", null, null,
    null, "'.'", null, "'#ifdef'", "'#ifndef'", "'#if'", "'#else'",
    "'#elif'", "'#endif'", "'#include'", "'#define'", "'##'", "'#'"
];
asirParser.symbolicNames = [
    null, "DEF", "IF", "FOR", "WHILE", "DO", "ELSE", "RETURN", "CONTINUE",
    "BREAK", "STRUCT", "MODULE", "ENDMODULE", "EXTERN", "STATIC", "GLOBAL",
    "LOCAL", "LOCALF", "FUNCTION", "END", "QUIT", "DEBUG", "LTLT", "GTGT",
    "COLON2", "INC", "DEC", "PLUSEQ", "MINUSEQ", "MULTEQ", "DIVEQ",
    "SUREQ", "POWEREQ", "ARROW", "EQ", "NEQ", "LE", "GE", "LT", "GT",
    "AND", "OR", "NOT", "PLUS", "MINUS", "MULT", "DIV", "SUR", "POWER",
    "ASSIGN", "BACK", "MID", "LPAREN", "RPAREN", "LBRANCE", "RBRANCE",
    "LBRACKET", "RBRACKET", "QUESTION", "COLON", "SEMI", "DOLLAR", "COMMA",
    "HEX", "BIT", "IMAGINARY", "ASGEN", "APGEN", "BEFORE", "BEFORE_N",
    "QE_1", "QE_2", "QE_3", "QE_4", "QE_5", "QE_6", "QE_7", "QE_8",
    "QE_9", "QE_10", "QE_11", "QE_12", "QE_IMPL", "QE_REPL", "QE_EQUIV",
    "ATFUNC", "VAR_2", "ID", "FLOAT", "INT", "DOT", "PCOMMENT", "PIFDEF",
    "PIFNDEF", "PIF", "PELSE", "PELIF", "PENDIF", "PINCLUDE", "PDEFINE",
    "CHARPLUS", "CHAR", "STRING", "NOSTRING", "SYSTEM_PATH_LITERAL",
    "NEWLINE", "WS", "COMMENT", "LCOMMENT"
];
asirParser.ruleNames = [
    "prog", "statement", "prechar", "preprocessor", "functionDefinition",
    "formDeclaration", "functionIf", "functionFor", "functionWhile",
    "functionDo", "functionReturn", "functionContinue", "functionBreak",
    "functionStruct", "functionEnd", "functionQuit", "functionDebug",
    "functionModule", "expr", "qualifiedName", "dottedIdentifier", "exprlist",
    "terminator", "systemPath", "elifClause", "elseClause", "optionPair",
    "dpoly", "rational", "decimal", "num", "id", "indeterminate", "list",
    "block",
];
asirParser._serializedATN = [
    4, 1, 108, 530, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6,
    7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7,
    13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2,
    20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7,
    26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2,
    33, 7, 33, 2, 34, 7, 34, 1, 0, 5, 0, 72, 8, 0, 10, 0, 12, 0, 75, 9, 0, 1, 0, 1, 0, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 3, 1, 98, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 105, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3,
    1, 3, 1, 3, 5, 3, 113, 8, 3, 10, 3, 12, 3, 116, 9, 3, 3, 3, 118, 8, 3, 1, 3, 3, 3, 121, 8,
    3, 1, 3, 1, 3, 1, 3, 1, 3, 5, 3, 127, 8, 3, 10, 3, 12, 3, 130, 9, 3, 1, 3, 5, 3, 133, 8, 3,
    10, 3, 12, 3, 136, 9, 3, 1, 3, 3, 3, 139, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 146, 8,
    3, 3, 3, 148, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 156, 8, 4, 10, 4, 12, 4, 159,
    9, 4, 3, 4, 161, 8, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 172, 8, 5,
    10, 5, 12, 5, 175, 9, 5, 3, 5, 177, 8, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
    6, 1, 6, 3, 6, 189, 8, 6, 1, 7, 1, 7, 1, 7, 3, 7, 194, 8, 7, 1, 7, 1, 7, 3, 7, 198, 8, 7, 1,
    7, 1, 7, 3, 7, 202, 8, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 210, 8, 8, 1, 8, 1, 8, 1,
    8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 220, 8, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 3, 10, 227,
    8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13,
    1, 13, 1, 13, 5, 13, 243, 8, 13, 10, 13, 12, 13, 246, 9, 13, 1, 13, 1, 13, 1, 13, 1, 14,
    1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17,
    264, 8, 17, 10, 17, 12, 17, 267, 9, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
    1, 17, 3, 17, 277, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 293, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    5, 18, 300, 8, 18, 10, 18, 12, 18, 303, 9, 18, 1, 18, 3, 18, 306, 8, 18, 1, 18, 1, 18,
    3, 18, 310, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 316, 8, 18, 10, 18, 12, 18, 319,
    9, 18, 3, 18, 321, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
    331, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 337, 8, 18, 10, 18, 12, 18, 340, 9, 18,
    3, 18, 342, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    3, 18, 354, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 1, 18, 1, 18, 4, 18, 395, 8, 18, 11, 18, 12, 18, 396, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 4, 18, 404, 8, 18, 11, 18, 12, 18, 405, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 418, 8, 18, 10, 18, 12, 18, 421, 9, 18, 1, 19, 1, 19,
    3, 19, 425, 8, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 4, 20, 432, 8, 20, 11, 20, 12, 20,
    433, 1, 21, 1, 21, 1, 21, 5, 21, 439, 8, 21, 10, 21, 12, 21, 442, 9, 21, 1, 22, 1, 22,
    1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 5, 24, 451, 8, 24, 10, 24, 12, 24, 454, 9, 24, 1, 25,
    1, 25, 5, 25, 458, 8, 25, 10, 25, 12, 25, 461, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27,
    1, 27, 1, 27, 1, 27, 5, 27, 471, 8, 27, 10, 27, 12, 27, 474, 9, 27, 1, 27, 1, 27, 3, 27,
    478, 8, 27, 1, 27, 1, 27, 1, 28, 3, 28, 483, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 488, 8,
    28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 501,
    8, 30, 1, 31, 1, 31, 1, 31, 3, 31, 506, 8, 31, 1, 32, 1, 32, 1, 32, 3, 32, 511, 8, 32, 1,
    33, 1, 33, 3, 33, 515, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 5, 34, 521, 8, 34, 10, 34, 12,
    34, 524, 9, 34, 1, 34, 1, 34, 3, 34, 528, 8, 34, 1, 34, 0, 1, 36, 35, 0, 2, 4, 6, 8, 10,
    12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54,
    56, 58, 60, 62, 64, 66, 68, 0, 13, 1, 0, 92, 94, 1, 0, 13, 17, 1, 0, 25, 26, 1, 0, 43, 44,
    1, 0, 45, 47, 1, 0, 34, 39, 1, 0, 70, 76, 1, 0, 78, 79, 1, 0, 80, 81, 1, 0, 82, 84, 2, 0,
    27, 32, 49, 49, 1, 0, 60, 61, 1, 0, 88, 89, 600, 0, 73, 1, 0, 0, 0, 2, 97, 1, 0, 0, 0, 4,
    104, 1, 0, 0, 0, 6, 147, 1, 0, 0, 0, 8, 149, 1, 0, 0, 0, 10, 165, 1, 0, 0, 0, 12, 181, 1,
    0, 0, 0, 14, 190, 1, 0, 0, 0, 16, 206, 1, 0, 0, 0, 18, 214, 1, 0, 0, 0, 20, 224, 1, 0, 0,
    0, 22, 230, 1, 0, 0, 0, 24, 233, 1, 0, 0, 0, 26, 236, 1, 0, 0, 0, 28, 250, 1, 0, 0, 0, 30,
    253, 1, 0, 0, 0, 32, 256, 1, 0, 0, 0, 34, 276, 1, 0, 0, 0, 36, 353, 1, 0, 0, 0, 38, 424,
    1, 0, 0, 0, 40, 428, 1, 0, 0, 0, 42, 435, 1, 0, 0, 0, 44, 443, 1, 0, 0, 0, 46, 445, 1, 0,
    0, 0, 48, 447, 1, 0, 0, 0, 50, 455, 1, 0, 0, 0, 52, 462, 1, 0, 0, 0, 54, 466, 1, 0, 0, 0,
    56, 482, 1, 0, 0, 0, 58, 491, 1, 0, 0, 0, 60, 500, 1, 0, 0, 0, 62, 505, 1, 0, 0, 0, 64, 510,
    1, 0, 0, 0, 66, 512, 1, 0, 0, 0, 68, 527, 1, 0, 0, 0, 70, 72, 3, 2, 1, 0, 71, 70, 1, 0, 0,
    0, 72, 75, 1, 0, 0, 0, 73, 71, 1, 0, 0, 0, 73, 74, 1, 0, 0, 0, 74, 76, 1, 0, 0, 0, 75, 73,
    1, 0, 0, 0, 76, 77, 5, 0, 0, 1, 77, 1, 1, 0, 0, 0, 78, 79, 3, 36, 18, 0, 79, 80, 3, 44, 22,
    0, 80, 98, 1, 0, 0, 0, 81, 98, 3, 44, 22, 0, 82, 98, 3, 8, 4, 0, 83, 98, 3, 10, 5, 0, 84,
    98, 3, 12, 6, 0, 85, 98, 3, 14, 7, 0, 86, 98, 3, 16, 8, 0, 87, 98, 3, 18, 9, 0, 88, 98, 3,
    20, 10, 0, 89, 98, 3, 24, 12, 0, 90, 98, 3, 22, 11, 0, 91, 98, 3, 26, 13, 0, 92, 98, 3,
    28, 14, 0, 93, 98, 3, 30, 15, 0, 94, 98, 3, 32, 16, 0, 95, 98, 3, 34, 17, 0, 96, 98, 3,
    6, 3, 0, 97, 78, 1, 0, 0, 0, 97, 81, 1, 0, 0, 0, 97, 82, 1, 0, 0, 0, 97, 83, 1, 0, 0, 0, 97,
    84, 1, 0, 0, 0, 97, 85, 1, 0, 0, 0, 97, 86, 1, 0, 0, 0, 97, 87, 1, 0, 0, 0, 97, 88, 1, 0, 0,
    0, 97, 89, 1, 0, 0, 0, 97, 90, 1, 0, 0, 0, 97, 91, 1, 0, 0, 0, 97, 92, 1, 0, 0, 0, 97, 93,
    1, 0, 0, 0, 97, 94, 1, 0, 0, 0, 97, 95, 1, 0, 0, 0, 97, 96, 1, 0, 0, 0, 98, 3, 1, 0, 0, 0, 99,
    100, 5, 101, 0, 0, 100, 105, 5, 87, 0, 0, 101, 102, 5, 87, 0, 0, 102, 103, 5, 100, 0,
    0, 103, 105, 5, 87, 0, 0, 104, 99, 1, 0, 0, 0, 104, 101, 1, 0, 0, 0, 105, 5, 1, 0, 0, 0,
    106, 107, 5, 99, 0, 0, 107, 120, 5, 87, 0, 0, 108, 117, 5, 52, 0, 0, 109, 114, 5, 87,
    0, 0, 110, 111, 5, 62, 0, 0, 111, 113, 5, 87, 0, 0, 112, 110, 1, 0, 0, 0, 113, 116, 1,
    0, 0, 0, 114, 112, 1, 0, 0, 0, 114, 115, 1, 0, 0, 0, 115, 118, 1, 0, 0, 0, 116, 114, 1,
    0, 0, 0, 117, 109, 1, 0, 0, 0, 117, 118, 1, 0, 0, 0, 118, 119, 1, 0, 0, 0, 119, 121, 5,
    53, 0, 0, 120, 108, 1, 0, 0, 0, 120, 121, 1, 0, 0, 0, 121, 122, 1, 0, 0, 0, 122, 148, 3,
    36, 18, 0, 123, 124, 7, 0, 0, 0, 124, 128, 3, 36, 18, 0, 125, 127, 3, 2, 1, 0, 126, 125,
    1, 0, 0, 0, 127, 130, 1, 0, 0, 0, 128, 126, 1, 0, 0, 0, 128, 129, 1, 0, 0, 0, 129, 134,
    1, 0, 0, 0, 130, 128, 1, 0, 0, 0, 131, 133, 3, 48, 24, 0, 132, 131, 1, 0, 0, 0, 133, 136,
    1, 0, 0, 0, 134, 132, 1, 0, 0, 0, 134, 135, 1, 0, 0, 0, 135, 138, 1, 0, 0, 0, 136, 134,
    1, 0, 0, 0, 137, 139, 3, 50, 25, 0, 138, 137, 1, 0, 0, 0, 138, 139, 1, 0, 0, 0, 139, 140,
    1, 0, 0, 0, 140, 141, 5, 97, 0, 0, 141, 148, 1, 0, 0, 0, 142, 145, 5, 98, 0, 0, 143, 146,
    3, 46, 23, 0, 144, 146, 5, 102, 0, 0, 145, 143, 1, 0, 0, 0, 145, 144, 1, 0, 0, 0, 146,
    148, 1, 0, 0, 0, 147, 106, 1, 0, 0, 0, 147, 123, 1, 0, 0, 0, 147, 142, 1, 0, 0, 0, 148,
    7, 1, 0, 0, 0, 149, 150, 5, 1, 0, 0, 150, 151, 3, 64, 32, 0, 151, 160, 5, 52, 0, 0, 152,
    157, 5, 87, 0, 0, 153, 154, 5, 62, 0, 0, 154, 156, 5, 87, 0, 0, 155, 153, 1, 0, 0, 0, 156,
    159, 1, 0, 0, 0, 157, 155, 1, 0, 0, 0, 157, 158, 1, 0, 0, 0, 158, 161, 1, 0, 0, 0, 159,
    157, 1, 0, 0, 0, 160, 152, 1, 0, 0, 0, 160, 161, 1, 0, 0, 0, 161, 162, 1, 0, 0, 0, 162,
    163, 5, 53, 0, 0, 163, 164, 3, 68, 34, 0, 164, 9, 1, 0, 0, 0, 165, 166, 5, 18, 0, 0, 166,
    167, 3, 64, 32, 0, 167, 176, 5, 52, 0, 0, 168, 173, 3, 64, 32, 0, 169, 170, 5, 62, 0,
    0, 170, 172, 3, 64, 32, 0, 171, 169, 1, 0, 0, 0, 172, 175, 1, 0, 0, 0, 173, 171, 1, 0,
    0, 0, 173, 174, 1, 0, 0, 0, 174, 177, 1, 0, 0, 0, 175, 173, 1, 0, 0, 0, 176, 168, 1, 0,
    0, 0, 176, 177, 1, 0, 0, 0, 177, 178, 1, 0, 0, 0, 178, 179, 5, 53, 0, 0, 179, 180, 3, 44,
    22, 0, 180, 11, 1, 0, 0, 0, 181, 182, 5, 2, 0, 0, 182, 183, 5, 52, 0, 0, 183, 184, 3, 36,
    18, 0, 184, 185, 5, 53, 0, 0, 185, 188, 3, 68, 34, 0, 186, 187, 5, 6, 0, 0, 187, 189,
    3, 68, 34, 0, 188, 186, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 13, 1, 0, 0, 0, 190, 191,
    5, 3, 0, 0, 191, 193, 5, 52, 0, 0, 192, 194, 3, 42, 21, 0, 193, 192, 1, 0, 0, 0, 193, 194,
    1, 0, 0, 0, 194, 195, 1, 0, 0, 0, 195, 197, 5, 60, 0, 0, 196, 198, 3, 42, 21, 0, 197, 196,
    1, 0, 0, 0, 197, 198, 1, 0, 0, 0, 198, 199, 1, 0, 0, 0, 199, 201, 5, 60, 0, 0, 200, 202,
    3, 42, 21, 0, 201, 200, 1, 0, 0, 0, 201, 202, 1, 0, 0, 0, 202, 203, 1, 0, 0, 0, 203, 204,
    5, 53, 0, 0, 204, 205, 3, 68, 34, 0, 205, 15, 1, 0, 0, 0, 206, 207, 5, 4, 0, 0, 207, 209,
    5, 52, 0, 0, 208, 210, 3, 42, 21, 0, 209, 208, 1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 211,
    1, 0, 0, 0, 211, 212, 5, 53, 0, 0, 212, 213, 3, 68, 34, 0, 213, 17, 1, 0, 0, 0, 214, 215,
    5, 5, 0, 0, 215, 216, 3, 68, 34, 0, 216, 217, 5, 4, 0, 0, 217, 219, 5, 52, 0, 0, 218, 220,
    3, 42, 21, 0, 219, 218, 1, 0, 0, 0, 219, 220, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0, 221, 222,
    5, 53, 0, 0, 222, 223, 5, 60, 0, 0, 223, 19, 1, 0, 0, 0, 224, 226, 5, 7, 0, 0, 225, 227,
    3, 36, 18, 0, 226, 225, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228, 229,
    3, 44, 22, 0, 229, 21, 1, 0, 0, 0, 230, 231, 5, 8, 0, 0, 231, 232, 3, 44, 22, 0, 232, 23,
    1, 0, 0, 0, 233, 234, 5, 9, 0, 0, 234, 235, 3, 44, 22, 0, 235, 25, 1, 0, 0, 0, 236, 237,
    5, 10, 0, 0, 237, 238, 3, 64, 32, 0, 238, 239, 5, 54, 0, 0, 239, 244, 3, 64, 32, 0, 240,
    241, 5, 62, 0, 0, 241, 243, 3, 64, 32, 0, 242, 240, 1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244,
    242, 1, 0, 0, 0, 244, 245, 1, 0, 0, 0, 245, 247, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 247,
    248, 5, 55, 0, 0, 248, 249, 3, 44, 22, 0, 249, 27, 1, 0, 0, 0, 250, 251, 5, 19, 0, 0, 251,
    252, 3, 44, 22, 0, 252, 29, 1, 0, 0, 0, 253, 254, 5, 20, 0, 0, 254, 255, 3, 44, 22, 0,
    255, 31, 1, 0, 0, 0, 256, 257, 5, 21, 0, 0, 257, 258, 3, 44, 22, 0, 258, 33, 1, 0, 0, 0,
    259, 260, 7, 1, 0, 0, 260, 265, 3, 64, 32, 0, 261, 262, 5, 62, 0, 0, 262, 264, 3, 64,
    32, 0, 263, 261, 1, 0, 0, 0, 264, 267, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 265, 266, 1, 0,
    0, 0, 266, 268, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 268, 269, 3, 44, 22, 0, 269, 277, 1,
    0, 0, 0, 270, 271, 5, 11, 0, 0, 271, 272, 3, 64, 32, 0, 272, 273, 3, 44, 22, 0, 273, 277,
    1, 0, 0, 0, 274, 275, 5, 12, 0, 0, 275, 277, 3, 44, 22, 0, 276, 259, 1, 0, 0, 0, 276, 270,
    1, 0, 0, 0, 276, 274, 1, 0, 0, 0, 277, 35, 1, 0, 0, 0, 278, 279, 6, 18, -1, 0, 279, 280,
    5, 52, 0, 0, 280, 281, 3, 36, 18, 0, 281, 282, 5, 53, 0, 0, 282, 354, 1, 0, 0, 0, 283,
    354, 3, 60, 30, 0, 284, 354, 3, 62, 31, 0, 285, 354, 5, 102, 0, 0, 286, 354, 3, 66, 33,
    0, 287, 354, 3, 54, 27, 0, 288, 354, 3, 4, 2, 0, 289, 354, 3, 40, 20, 0, 290, 354, 3,
    64, 32, 0, 291, 293, 5, 24, 0, 0, 292, 291, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 294,
    1, 0, 0, 0, 294, 305, 3, 38, 19, 0, 295, 296, 5, 54, 0, 0, 296, 301, 5, 89, 0, 0, 297,
    298, 5, 62, 0, 0, 298, 300, 5, 89, 0, 0, 299, 297, 1, 0, 0, 0, 300, 303, 1, 0, 0, 0, 301,
    299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302, 304, 1, 0, 0, 0, 303, 301, 1, 0, 0, 0, 304,
    306, 5, 55, 0, 0, 305, 295, 1, 0, 0, 0, 305, 306, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307,
    309, 5, 52, 0, 0, 308, 310, 3, 42, 21, 0, 309, 308, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310,
    320, 1, 0, 0, 0, 311, 312, 5, 51, 0, 0, 312, 317, 3, 52, 26, 0, 313, 314, 5, 62, 0, 0,
    314, 316, 3, 52, 26, 0, 315, 313, 1, 0, 0, 0, 316, 319, 1, 0, 0, 0, 317, 315, 1, 0, 0,
    0, 317, 318, 1, 0, 0, 0, 318, 321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 320, 311, 1, 0, 0,
    0, 320, 321, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 5, 53, 0, 0, 323, 354, 1, 0, 0,
    0, 324, 325, 5, 52, 0, 0, 325, 326, 5, 45, 0, 0, 326, 327, 3, 36, 18, 0, 327, 328, 5,
    53, 0, 0, 328, 330, 5, 52, 0, 0, 329, 331, 3, 42, 21, 0, 330, 329, 1, 0, 0, 0, 330, 331,
    1, 0, 0, 0, 331, 341, 1, 0, 0, 0, 332, 333, 5, 51, 0, 0, 333, 338, 3, 52, 26, 0, 334, 335,
    5, 62, 0, 0, 335, 337, 3, 52, 26, 0, 336, 334, 1, 0, 0, 0, 337, 340, 1, 0, 0, 0, 338, 336,
    1, 0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 342, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 341, 332,
    1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 5, 53, 0, 0, 344, 354,
    1, 0, 0, 0, 345, 346, 7, 2, 0, 0, 346, 354, 3, 36, 18, 17, 347, 348, 7, 3, 0, 0, 348, 354,
    3, 36, 18, 16, 349, 350, 5, 42, 0, 0, 350, 354, 3, 36, 18, 15, 351, 352, 5, 50, 0, 0,
    352, 354, 3, 36, 18, 3, 353, 278, 1, 0, 0, 0, 353, 283, 1, 0, 0, 0, 353, 284, 1, 0, 0,
    0, 353, 285, 1, 0, 0, 0, 353, 286, 1, 0, 0, 0, 353, 287, 1, 0, 0, 0, 353, 288, 1, 0, 0,
    0, 353, 289, 1, 0, 0, 0, 353, 290, 1, 0, 0, 0, 353, 292, 1, 0, 0, 0, 353, 324, 1, 0, 0,
    0, 353, 345, 1, 0, 0, 0, 353, 347, 1, 0, 0, 0, 353, 349, 1, 0, 0, 0, 353, 351, 1, 0, 0,
    0, 354, 419, 1, 0, 0, 0, 355, 356, 10, 14, 0, 0, 356, 357, 5, 48, 0, 0, 357, 418, 3, 36,
    18, 14, 358, 359, 10, 13, 0, 0, 359, 360, 7, 4, 0, 0, 360, 418, 3, 36, 18, 14, 361, 362,
    10, 12, 0, 0, 362, 363, 7, 3, 0, 0, 363, 418, 3, 36, 18, 13, 364, 365, 10, 11, 0, 0, 365,
    366, 7, 5, 0, 0, 366, 418, 3, 36, 18, 12, 367, 368, 10, 10, 0, 0, 368, 369, 5, 40, 0,
    0, 369, 418, 3, 36, 18, 11, 370, 371, 10, 9, 0, 0, 371, 372, 5, 41, 0, 0, 372, 418, 3,
    36, 18, 10, 373, 374, 10, 8, 0, 0, 374, 375, 7, 6, 0, 0, 375, 418, 3, 36, 18, 9, 376,
    377, 10, 7, 0, 0, 377, 378, 7, 7, 0, 0, 378, 418, 3, 36, 18, 8, 379, 380, 10, 6, 0, 0,
    380, 381, 7, 8, 0, 0, 381, 418, 3, 36, 18, 7, 382, 383, 10, 5, 0, 0, 383, 384, 5, 77,
    0, 0, 384, 418, 3, 36, 18, 6, 385, 386, 10, 4, 0, 0, 386, 387, 7, 9, 0, 0, 387, 418, 3,
    36, 18, 5, 388, 389, 10, 1, 0, 0, 389, 390, 7, 10, 0, 0, 390, 418, 3, 36, 18, 1, 391,
    394, 10, 21, 0, 0, 392, 393, 5, 33, 0, 0, 393, 395, 3, 64, 32, 0, 394, 392, 1, 0, 0, 0,
    395, 396, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 418, 1, 0, 0, 0,
    398, 403, 10, 20, 0, 0, 399, 400, 5, 56, 0, 0, 400, 401, 3, 36, 18, 0, 401, 402, 5, 57,
    0, 0, 402, 404, 1, 0, 0, 0, 403, 399, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 403, 1, 0,
    0, 0, 405, 406, 1, 0, 0, 0, 406, 418, 1, 0, 0, 0, 407, 408, 10, 19, 0, 0, 408, 418, 7,
    2, 0, 0, 409, 410, 10, 18, 0, 0, 410, 418, 5, 42, 0, 0, 411, 412, 10, 2, 0, 0, 412, 413,
    5, 58, 0, 0, 413, 414, 3, 36, 18, 0, 414, 415, 5, 59, 0, 0, 415, 416, 3, 36, 18, 0, 416,
    418, 1, 0, 0, 0, 417, 355, 1, 0, 0, 0, 417, 358, 1, 0, 0, 0, 417, 361, 1, 0, 0, 0, 417,
    364, 1, 0, 0, 0, 417, 367, 1, 0, 0, 0, 417, 370, 1, 0, 0, 0, 417, 373, 1, 0, 0, 0, 417,
    376, 1, 0, 0, 0, 417, 379, 1, 0, 0, 0, 417, 382, 1, 0, 0, 0, 417, 385, 1, 0, 0, 0, 417,
    388, 1, 0, 0, 0, 417, 391, 1, 0, 0, 0, 417, 398, 1, 0, 0, 0, 417, 407, 1, 0, 0, 0, 417,
    409, 1, 0, 0, 0, 417, 411, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419,
    420, 1, 0, 0, 0, 420, 37, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 422, 423, 5, 87, 0, 0, 423,
    425, 5, 90, 0, 0, 424, 422, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
    427, 3, 64, 32, 0, 427, 39, 1, 0, 0, 0, 428, 431, 3, 64, 32, 0, 429, 430, 5, 90, 0, 0,
    430, 432, 3, 64, 32, 0, 431, 429, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 431, 1, 0, 0,
    0, 433, 434, 1, 0, 0, 0, 434, 41, 1, 0, 0, 0, 435, 440, 3, 36, 18, 0, 436, 437, 5, 62,
    0, 0, 437, 439, 3, 36, 18, 0, 438, 436, 1, 0, 0, 0, 439, 442, 1, 0, 0, 0, 440, 438, 1,
    0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 43, 1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 443, 444, 7, 11,
    0, 0, 444, 45, 1, 0, 0, 0, 445, 446, 5, 104, 0, 0, 446, 47, 1, 0, 0, 0, 447, 448, 5, 96,
    0, 0, 448, 452, 3, 36, 18, 0, 449, 451, 3, 2, 1, 0, 450, 449, 1, 0, 0, 0, 451, 454, 1,
    0, 0, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 49, 1, 0, 0, 0, 454, 452, 1, 0,
    0, 0, 455, 459, 5, 95, 0, 0, 456, 458, 3, 2, 1, 0, 457, 456, 1, 0, 0, 0, 458, 461, 1, 0,
    0, 0, 459, 457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 51, 1, 0, 0, 0, 461, 459, 1, 0, 0,
    0, 462, 463, 3, 64, 32, 0, 463, 464, 5, 49, 0, 0, 464, 465, 3, 36, 18, 0, 465, 53, 1,
    0, 0, 0, 466, 467, 5, 22, 0, 0, 467, 472, 5, 89, 0, 0, 468, 469, 5, 62, 0, 0, 469, 471,
    5, 89, 0, 0, 470, 468, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473,
    1, 0, 0, 0, 473, 477, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 475, 476, 5, 59, 0, 0, 476, 478,
    5, 89, 0, 0, 477, 475, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 480,
    5, 23, 0, 0, 480, 55, 1, 0, 0, 0, 481, 483, 5, 44, 0, 0, 482, 481, 1, 0, 0, 0, 482, 483,
    1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 485, 5, 89, 0, 0, 485, 487, 5, 46, 0, 0, 486, 488,
    5, 44, 0, 0, 487, 486, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 490,
    5, 89, 0, 0, 490, 57, 1, 0, 0, 0, 491, 492, 7, 12, 0, 0, 492, 59, 1, 0, 0, 0, 493, 501,
    5, 63, 0, 0, 494, 501, 5, 64, 0, 0, 495, 501, 3, 56, 28, 0, 496, 501, 3, 58, 29, 0, 497,
    501, 5, 65, 0, 0, 498, 501, 5, 66, 0, 0, 499, 501, 5, 67, 0, 0, 500, 493, 1, 0, 0, 0, 500,
    494, 1, 0, 0, 0, 500, 495, 1, 0, 0, 0, 500, 496, 1, 0, 0, 0, 500, 497, 1, 0, 0, 0, 500,
    498, 1, 0, 0, 0, 500, 499, 1, 0, 0, 0, 501, 61, 1, 0, 0, 0, 502, 506, 5, 68, 0, 0, 503,
    506, 5, 69, 0, 0, 504, 506, 5, 86, 0, 0, 505, 502, 1, 0, 0, 0, 505, 503, 1, 0, 0, 0, 505,
    504, 1, 0, 0, 0, 506, 63, 1, 0, 0, 0, 507, 511, 5, 87, 0, 0, 508, 511, 5, 85, 0, 0, 509,
    511, 5, 103, 0, 0, 510, 507, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 510, 509, 1, 0, 0, 0, 511,
    65, 1, 0, 0, 0, 512, 514, 5, 56, 0, 0, 513, 515, 3, 42, 21, 0, 514, 513, 1, 0, 0, 0, 514,
    515, 1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 517, 5, 57, 0, 0, 517, 67, 1, 0, 0, 0, 518,
    522, 5, 54, 0, 0, 519, 521, 3, 2, 1, 0, 520, 519, 1, 0, 0, 0, 521, 524, 1, 0, 0, 0, 522,
    520, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 525, 1, 0, 0, 0, 524, 522, 1, 0, 0, 0, 525,
    528, 5, 55, 0, 0, 526, 528, 3, 2, 1, 0, 527, 518, 1, 0, 0, 0, 527, 526, 1, 0, 0, 0, 528,
    69, 1, 0, 0, 0, 54, 73, 97, 104, 114, 117, 120, 128, 134, 138, 145, 147, 157, 160,
    173, 176, 188, 193, 197, 201, 209, 219, 226, 244, 265, 276, 292, 301, 305, 309,
    317, 320, 330, 338, 341, 353, 396, 405, 417, 419, 424, 433, 440, 452, 459, 472,
    477, 482, 487, 500, 505, 510, 514, 522, 527
];
asirParser.vocabulary = new antlr.Vocabulary(asirParser.literalNames, asirParser.symbolicNames, []);
asirParser.decisionsToDFA = asirParser._ATN.decisionToState.map((ds, index) => new antlr.DFA(ds, index));
class ProgContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    EOF() {
        return this.getToken(asirParser.EOF, 0);
    }
    statement(i) {
        if (i === undefined) {
            return this.getRuleContexts(StatementContext);
        }
        return this.getRuleContext(i, StatementContext);
    }
    get ruleIndex() {
        return asirParser.RULE_prog;
    }
    enterRule(listener) {
        if (listener.enterProg) {
            listener.enterProg(this);
        }
    }
    exitRule(listener) {
        if (listener.exitProg) {
            listener.exitProg(this);
        }
    }
    accept(visitor) {
        if (visitor.visitProg) {
            return visitor.visitProg(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ProgContext = ProgContext;
class StatementContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_statement;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.StatementContext = StatementContext;
class QuitStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionQuit() {
        return this.getRuleContext(0, FunctionQuitContext);
    }
    enterRule(listener) {
        if (listener.enterQuitStatement) {
            listener.enterQuitStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQuitStatement) {
            listener.exitQuitStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQuitStatement) {
            return visitor.visitQuitStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QuitStatementContext = QuitStatementContext;
class DoStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionDo() {
        return this.getRuleContext(0, FunctionDoContext);
    }
    enterRule(listener) {
        if (listener.enterDoStatement) {
            listener.enterDoStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDoStatement) {
            listener.exitDoStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDoStatement) {
            return visitor.visitDoStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DoStatementContext = DoStatementContext;
class ForwardDeclStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    formDeclaration() {
        return this.getRuleContext(0, FormDeclarationContext);
    }
    enterRule(listener) {
        if (listener.enterForwardDeclStatement) {
            listener.enterForwardDeclStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitForwardDeclStatement) {
            listener.exitForwardDeclStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitForwardDeclStatement) {
            return visitor.visitForwardDeclStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ForwardDeclStatementContext = ForwardDeclStatementContext;
class ModuleStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionModule() {
        return this.getRuleContext(0, FunctionModuleContext);
    }
    enterRule(listener) {
        if (listener.enterModuleStatement) {
            listener.enterModuleStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitModuleStatement) {
            listener.exitModuleStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitModuleStatement) {
            return visitor.visitModuleStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ModuleStatementContext = ModuleStatementContext;
class WhileStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionWhile() {
        return this.getRuleContext(0, FunctionWhileContext);
    }
    enterRule(listener) {
        if (listener.enterWhileStatement) {
            listener.enterWhileStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitWhileStatement) {
            listener.exitWhileStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitWhileStatement) {
            return visitor.visitWhileStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.WhileStatementContext = WhileStatementContext;
class EndStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionEnd() {
        return this.getRuleContext(0, FunctionEndContext);
    }
    enterRule(listener) {
        if (listener.enterEndStatement) {
            listener.enterEndStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitEndStatement) {
            listener.exitEndStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitEndStatement) {
            return visitor.visitEndStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.EndStatementContext = EndStatementContext;
class DebugStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionDebug() {
        return this.getRuleContext(0, FunctionDebugContext);
    }
    enterRule(listener) {
        if (listener.enterDebugStatement) {
            listener.enterDebugStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDebugStatement) {
            listener.exitDebugStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDebugStatement) {
            return visitor.visitDebugStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DebugStatementContext = DebugStatementContext;
class EmptyLineStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterEmptyLineStatement) {
            listener.enterEmptyLineStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitEmptyLineStatement) {
            listener.exitEmptyLineStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitEmptyLineStatement) {
            return visitor.visitEmptyLineStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.EmptyLineStatementContext = EmptyLineStatementContext;
class BreakStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionBreak() {
        return this.getRuleContext(0, FunctionBreakContext);
    }
    enterRule(listener) {
        if (listener.enterBreakStatement) {
            listener.enterBreakStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitBreakStatement) {
            listener.exitBreakStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitBreakStatement) {
            return visitor.visitBreakStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.BreakStatementContext = BreakStatementContext;
class IfStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionIf() {
        return this.getRuleContext(0, FunctionIfContext);
    }
    enterRule(listener) {
        if (listener.enterIfStatement) {
            listener.enterIfStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitIfStatement) {
            listener.exitIfStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitIfStatement) {
            return visitor.visitIfStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.IfStatementContext = IfStatementContext;
class PreproStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    preprocessor() {
        return this.getRuleContext(0, PreprocessorContext);
    }
    enterRule(listener) {
        if (listener.enterPreproStatement) {
            listener.enterPreproStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPreproStatement) {
            listener.exitPreproStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPreproStatement) {
            return visitor.visitPreproStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PreproStatementContext = PreproStatementContext;
class DefinitionStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionDefinition() {
        return this.getRuleContext(0, FunctionDefinitionContext);
    }
    enterRule(listener) {
        if (listener.enterDefinitionStatement) {
            listener.enterDefinitionStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDefinitionStatement) {
            listener.exitDefinitionStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDefinitionStatement) {
            return visitor.visitDefinitionStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DefinitionStatementContext = DefinitionStatementContext;
class StructStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionStruct() {
        return this.getRuleContext(0, FunctionStructContext);
    }
    enterRule(listener) {
        if (listener.enterStructStatement) {
            listener.enterStructStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitStructStatement) {
            listener.exitStructStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitStructStatement) {
            return visitor.visitStructStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.StructStatementContext = StructStatementContext;
class ExprStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterExprStatement) {
            listener.enterExprStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitExprStatement) {
            listener.exitExprStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitExprStatement) {
            return visitor.visitExprStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ExprStatementContext = ExprStatementContext;
class ReturnStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionReturn() {
        return this.getRuleContext(0, FunctionReturnContext);
    }
    enterRule(listener) {
        if (listener.enterReturnStatement) {
            listener.enterReturnStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitReturnStatement) {
            listener.exitReturnStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitReturnStatement) {
            return visitor.visitReturnStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ReturnStatementContext = ReturnStatementContext;
class ForStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionFor() {
        return this.getRuleContext(0, FunctionForContext);
    }
    enterRule(listener) {
        if (listener.enterForStatement) {
            listener.enterForStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitForStatement) {
            listener.exitForStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitForStatement) {
            return visitor.visitForStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ForStatementContext = ForStatementContext;
class ContinueStatementContext extends StatementContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    functionContinue() {
        return this.getRuleContext(0, FunctionContinueContext);
    }
    enterRule(listener) {
        if (listener.enterContinueStatement) {
            listener.enterContinueStatement(this);
        }
    }
    exitRule(listener) {
        if (listener.exitContinueStatement) {
            listener.exitContinueStatement(this);
        }
    }
    accept(visitor) {
        if (visitor.visitContinueStatement) {
            return visitor.visitContinueStatement(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ContinueStatementContext = ContinueStatementContext;
class PrecharContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_prechar;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.PrecharContext = PrecharContext;
class PreChrContext extends PrecharContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    CHAR() {
        return this.getToken(asirParser.CHAR, 0);
    }
    ID() {
        return this.getToken(asirParser.ID, 0);
    }
    enterRule(listener) {
        if (listener.enterPreChr) {
            listener.enterPreChr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPreChr) {
            listener.exitPreChr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPreChr) {
            return visitor.visitPreChr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PreChrContext = PreChrContext;
class PreChrPlusContext extends PrecharContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    ID(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.ID);
        }
        else {
            return this.getToken(asirParser.ID, i);
        }
    }
    CHARPLUS() {
        return this.getToken(asirParser.CHARPLUS, 0);
    }
    enterRule(listener) {
        if (listener.enterPreChrPlus) {
            listener.enterPreChrPlus(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPreChrPlus) {
            listener.exitPreChrPlus(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPreChrPlus) {
            return visitor.visitPreChrPlus(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PreChrPlusContext = PreChrPlusContext;
class PreprocessorContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_preprocessor;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.PreprocessorContext = PreprocessorContext;
class PDefContext extends PreprocessorContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._params = [];
        super.copyFrom(ctx);
    }
    PDEFINE() {
        return this.getToken(asirParser.PDEFINE, 0);
    }
    ID(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.ID);
        }
        else {
            return this.getToken(asirParser.ID, i);
        }
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterPDef) {
            listener.enterPDef(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPDef) {
            listener.exitPDef(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPDef) {
            return visitor.visitPDef(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PDefContext = PDefContext;
class PIncContext extends PreprocessorContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    PINCLUDE() {
        return this.getToken(asirParser.PINCLUDE, 0);
    }
    systemPath() {
        return this.getRuleContext(0, SystemPathContext);
    }
    STRING() {
        return this.getToken(asirParser.STRING, 0);
    }
    enterRule(listener) {
        if (listener.enterPInc) {
            listener.enterPInc(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPInc) {
            listener.exitPInc(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPInc) {
            return visitor.visitPInc(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PIncContext = PIncContext;
class PIfContext extends PreprocessorContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._thenSymts = [];
        this._elifs = [];
        super.copyFrom(ctx);
    }
    PENDIF() {
        return this.getToken(asirParser.PENDIF, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    PIF() {
        return this.getToken(asirParser.PIF, 0);
    }
    PIFDEF() {
        return this.getToken(asirParser.PIFDEF, 0);
    }
    PIFNDEF() {
        return this.getToken(asirParser.PIFNDEF, 0);
    }
    statement(i) {
        if (i === undefined) {
            return this.getRuleContexts(StatementContext);
        }
        return this.getRuleContext(i, StatementContext);
    }
    elifClause(i) {
        if (i === undefined) {
            return this.getRuleContexts(ElifClauseContext);
        }
        return this.getRuleContext(i, ElifClauseContext);
    }
    elseClause() {
        return this.getRuleContext(0, ElseClauseContext);
    }
    enterRule(listener) {
        if (listener.enterPIf) {
            listener.enterPIf(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPIf) {
            listener.exitPIf(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPIf) {
            return visitor.visitPIf(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PIfContext = PIfContext;
class FunctionDefinitionContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionDefinition;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionDefinitionContext = FunctionDefinitionContext;
class DefContext extends FunctionDefinitionContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._params = [];
        super.copyFrom(ctx);
    }
    DEF() {
        return this.getToken(asirParser.DEF, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    indeterminate() {
        return this.getRuleContext(0, IndeterminateContext);
    }
    block() {
        return this.getRuleContext(0, BlockContext);
    }
    ID(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.ID);
        }
        else {
            return this.getToken(asirParser.ID, i);
        }
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterDef) {
            listener.enterDef(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDef) {
            listener.exitDef(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDef) {
            return visitor.visitDef(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DefContext = DefContext;
class FormDeclarationContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_formDeclaration;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FormDeclarationContext = FormDeclarationContext;
class FormDeclContext extends FormDeclarationContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._params = [];
        super.copyFrom(ctx);
    }
    FUNCTION() {
        return this.getToken(asirParser.FUNCTION, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    indeterminate(i) {
        if (i === undefined) {
            return this.getRuleContexts(IndeterminateContext);
        }
        return this.getRuleContext(i, IndeterminateContext);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterFormDecl) {
            listener.enterFormDecl(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFormDecl) {
            listener.exitFormDecl(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFormDecl) {
            return visitor.visitFormDecl(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FormDeclContext = FormDeclContext;
class FunctionIfContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionIf;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionIfContext = FunctionIfContext;
class IfContext extends FunctionIfContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    IF() {
        return this.getToken(asirParser.IF, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    block(i) {
        if (i === undefined) {
            return this.getRuleContexts(BlockContext);
        }
        return this.getRuleContext(i, BlockContext);
    }
    ELSE() {
        return this.getToken(asirParser.ELSE, 0);
    }
    enterRule(listener) {
        if (listener.enterIf) {
            listener.enterIf(this);
        }
    }
    exitRule(listener) {
        if (listener.exitIf) {
            listener.exitIf(this);
        }
    }
    accept(visitor) {
        if (visitor.visitIf) {
            return visitor.visitIf(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.IfContext = IfContext;
class FunctionForContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionFor;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionForContext = FunctionForContext;
class ForContext extends FunctionForContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    FOR() {
        return this.getToken(asirParser.FOR, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    SEMI(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.SEMI);
        }
        else {
            return this.getToken(asirParser.SEMI, i);
        }
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    block() {
        return this.getRuleContext(0, BlockContext);
    }
    exprlist(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprlistContext);
        }
        return this.getRuleContext(i, ExprlistContext);
    }
    enterRule(listener) {
        if (listener.enterFor) {
            listener.enterFor(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFor) {
            listener.exitFor(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFor) {
            return visitor.visitFor(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ForContext = ForContext;
class FunctionWhileContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionWhile;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionWhileContext = FunctionWhileContext;
class WhileContext extends FunctionWhileContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    WHILE() {
        return this.getToken(asirParser.WHILE, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    block() {
        return this.getRuleContext(0, BlockContext);
    }
    exprlist() {
        return this.getRuleContext(0, ExprlistContext);
    }
    enterRule(listener) {
        if (listener.enterWhile) {
            listener.enterWhile(this);
        }
    }
    exitRule(listener) {
        if (listener.exitWhile) {
            listener.exitWhile(this);
        }
    }
    accept(visitor) {
        if (visitor.visitWhile) {
            return visitor.visitWhile(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.WhileContext = WhileContext;
class FunctionDoContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionDo;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionDoContext = FunctionDoContext;
class DoContext extends FunctionDoContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    DO() {
        return this.getToken(asirParser.DO, 0);
    }
    block() {
        return this.getRuleContext(0, BlockContext);
    }
    WHILE() {
        return this.getToken(asirParser.WHILE, 0);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    SEMI() {
        return this.getToken(asirParser.SEMI, 0);
    }
    exprlist() {
        return this.getRuleContext(0, ExprlistContext);
    }
    enterRule(listener) {
        if (listener.enterDo) {
            listener.enterDo(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDo) {
            listener.exitDo(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDo) {
            return visitor.visitDo(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DoContext = DoContext;
class FunctionReturnContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionReturn;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionReturnContext = FunctionReturnContext;
class ReturnContext extends FunctionReturnContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    RETURN() {
        return this.getToken(asirParser.RETURN, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
        if (listener.enterReturn) {
            listener.enterReturn(this);
        }
    }
    exitRule(listener) {
        if (listener.exitReturn) {
            listener.exitReturn(this);
        }
    }
    accept(visitor) {
        if (visitor.visitReturn) {
            return visitor.visitReturn(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ReturnContext = ReturnContext;
class FunctionContinueContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionContinue;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionContinueContext = FunctionContinueContext;
class ContinueContext extends FunctionContinueContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    CONTINUE() {
        return this.getToken(asirParser.CONTINUE, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterContinue) {
            listener.enterContinue(this);
        }
    }
    exitRule(listener) {
        if (listener.exitContinue) {
            listener.exitContinue(this);
        }
    }
    accept(visitor) {
        if (visitor.visitContinue) {
            return visitor.visitContinue(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ContinueContext = ContinueContext;
class FunctionBreakContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionBreak;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionBreakContext = FunctionBreakContext;
class BreakContext extends FunctionBreakContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    BREAK() {
        return this.getToken(asirParser.BREAK, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterBreak) {
            listener.enterBreak(this);
        }
    }
    exitRule(listener) {
        if (listener.exitBreak) {
            listener.exitBreak(this);
        }
    }
    accept(visitor) {
        if (visitor.visitBreak) {
            return visitor.visitBreak(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.BreakContext = BreakContext;
class FunctionStructContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionStruct;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionStructContext = FunctionStructContext;
class StructContext extends FunctionStructContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._members = [];
        super.copyFrom(ctx);
    }
    STRUCT() {
        return this.getToken(asirParser.STRUCT, 0);
    }
    LBRANCE() {
        return this.getToken(asirParser.LBRANCE, 0);
    }
    RBRANCE() {
        return this.getToken(asirParser.RBRANCE, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    indeterminate(i) {
        if (i === undefined) {
            return this.getRuleContexts(IndeterminateContext);
        }
        return this.getRuleContext(i, IndeterminateContext);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterStruct) {
            listener.enterStruct(this);
        }
    }
    exitRule(listener) {
        if (listener.exitStruct) {
            listener.exitStruct(this);
        }
    }
    accept(visitor) {
        if (visitor.visitStruct) {
            return visitor.visitStruct(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.StructContext = StructContext;
class FunctionEndContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionEnd;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionEndContext = FunctionEndContext;
class EndContext extends FunctionEndContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    END() {
        return this.getToken(asirParser.END, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterEnd) {
            listener.enterEnd(this);
        }
    }
    exitRule(listener) {
        if (listener.exitEnd) {
            listener.exitEnd(this);
        }
    }
    accept(visitor) {
        if (visitor.visitEnd) {
            return visitor.visitEnd(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.EndContext = EndContext;
class FunctionQuitContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionQuit;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionQuitContext = FunctionQuitContext;
class QuitContext extends FunctionQuitContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    QUIT() {
        return this.getToken(asirParser.QUIT, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterQuit) {
            listener.enterQuit(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQuit) {
            listener.exitQuit(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQuit) {
            return visitor.visitQuit(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QuitContext = QuitContext;
class FunctionDebugContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionDebug;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionDebugContext = FunctionDebugContext;
class DebugContext extends FunctionDebugContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    DEBUG() {
        return this.getToken(asirParser.DEBUG, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterDebug) {
            listener.enterDebug(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDebug) {
            listener.exitDebug(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDebug) {
            return visitor.visitDebug(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DebugContext = DebugContext;
class FunctionModuleContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_functionModule;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.FunctionModuleContext = FunctionModuleContext;
class ModuleEndContext extends FunctionModuleContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    ENDMODULE() {
        return this.getToken(asirParser.ENDMODULE, 0);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterModuleEnd) {
            listener.enterModuleEnd(this);
        }
    }
    exitRule(listener) {
        if (listener.exitModuleEnd) {
            listener.exitModuleEnd(this);
        }
    }
    accept(visitor) {
        if (visitor.visitModuleEnd) {
            return visitor.visitModuleEnd(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ModuleEndContext = ModuleEndContext;
class ModuleAssignContext extends FunctionModuleContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    indeterminate(i) {
        if (i === undefined) {
            return this.getRuleContexts(IndeterminateContext);
        }
        return this.getRuleContext(i, IndeterminateContext);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    EXTERN() {
        return this.getToken(asirParser.EXTERN, 0);
    }
    STATIC() {
        return this.getToken(asirParser.STATIC, 0);
    }
    GLOBAL() {
        return this.getToken(asirParser.GLOBAL, 0);
    }
    LOCAL() {
        return this.getToken(asirParser.LOCAL, 0);
    }
    LOCALF() {
        return this.getToken(asirParser.LOCALF, 0);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterModuleAssign) {
            listener.enterModuleAssign(this);
        }
    }
    exitRule(listener) {
        if (listener.exitModuleAssign) {
            listener.exitModuleAssign(this);
        }
    }
    accept(visitor) {
        if (visitor.visitModuleAssign) {
            return visitor.visitModuleAssign(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ModuleAssignContext = ModuleAssignContext;
class ModuleStartContext extends FunctionModuleContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    MODULE() {
        return this.getToken(asirParser.MODULE, 0);
    }
    indeterminate() {
        return this.getRuleContext(0, IndeterminateContext);
    }
    terminator() {
        return this.getRuleContext(0, TerminatorContext);
    }
    enterRule(listener) {
        if (listener.enterModuleStart) {
            listener.enterModuleStart(this);
        }
    }
    exitRule(listener) {
        if (listener.exitModuleStart) {
            listener.exitModuleStart(this);
        }
    }
    accept(visitor) {
        if (visitor.visitModuleStart) {
            return visitor.visitModuleStart(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ModuleStartContext = ModuleStartContext;
class ExprContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_expr;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.ExprContext = ExprContext;
class AndExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    AND() {
        return this.getToken(asirParser.AND, 0);
    }
    enterRule(listener) {
        if (listener.enterAndExpr) {
            listener.enterAndExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitAndExpr) {
            listener.exitAndExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitAndExpr) {
            return visitor.visitAndExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.AndExprContext = AndExprContext;
class IndexAccessExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._indices = [];
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    LBRACKET(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.LBRACKET);
        }
        else {
            return this.getToken(asirParser.LBRACKET, i);
        }
    }
    RBRACKET(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.RBRACKET);
        }
        else {
            return this.getToken(asirParser.RBRACKET, i);
        }
    }
    enterRule(listener) {
        if (listener.enterIndexAccessExpr) {
            listener.enterIndexAccessExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitIndexAccessExpr) {
            listener.exitIndexAccessExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitIndexAccessExpr) {
            return visitor.visitIndexAccessExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.IndexAccessExprContext = IndexAccessExprContext;
class DottedIdExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    dottedIdentifier() {
        return this.getRuleContext(0, DottedIdentifierContext);
    }
    enterRule(listener) {
        if (listener.enterDottedIdExpr) {
            listener.enterDottedIdExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDottedIdExpr) {
            listener.exitDottedIdExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDottedIdExpr) {
            return visitor.visitDottedIdExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DottedIdExprContext = DottedIdExprContext;
class PreFixExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    INC() {
        return this.getToken(asirParser.INC, 0);
    }
    DEC() {
        return this.getToken(asirParser.DEC, 0);
    }
    enterRule(listener) {
        if (listener.enterPreFixExpr) {
            listener.enterPreFixExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPreFixExpr) {
            listener.exitPreFixExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPreFixExpr) {
            return visitor.visitPreFixExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PreFixExprContext = PreFixExprContext;
class StringLiteralExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    STRING() {
        return this.getToken(asirParser.STRING, 0);
    }
    enterRule(listener) {
        if (listener.enterStringLiteralExpr) {
            listener.enterStringLiteralExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitStringLiteralExpr) {
            listener.exitStringLiteralExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitStringLiteralExpr) {
            return visitor.visitStringLiteralExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.StringLiteralExprContext = StringLiteralExprContext;
class UnaryNotExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    NOT() {
        return this.getToken(asirParser.NOT, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
        if (listener.enterUnaryNotExpr) {
            listener.enterUnaryNotExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitUnaryNotExpr) {
            listener.exitUnaryNotExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitUnaryNotExpr) {
            return visitor.visitUnaryNotExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.UnaryNotExprContext = UnaryNotExprContext;
class RelationalExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    EQ() {
        return this.getToken(asirParser.EQ, 0);
    }
    NEQ() {
        return this.getToken(asirParser.NEQ, 0);
    }
    LT() {
        return this.getToken(asirParser.LT, 0);
    }
    GT() {
        return this.getToken(asirParser.GT, 0);
    }
    LE() {
        return this.getToken(asirParser.LE, 0);
    }
    GE() {
        return this.getToken(asirParser.GE, 0);
    }
    enterRule(listener) {
        if (listener.enterRelationalExpr) {
            listener.enterRelationalExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitRelationalExpr) {
            listener.exitRelationalExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitRelationalExpr) {
            return visitor.visitRelationalExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.RelationalExprContext = RelationalExprContext;
class AssignExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    ASSIGN() {
        return this.getToken(asirParser.ASSIGN, 0);
    }
    PLUSEQ() {
        return this.getToken(asirParser.PLUSEQ, 0);
    }
    MINUSEQ() {
        return this.getToken(asirParser.MINUSEQ, 0);
    }
    MULTEQ() {
        return this.getToken(asirParser.MULTEQ, 0);
    }
    DIVEQ() {
        return this.getToken(asirParser.DIVEQ, 0);
    }
    SUREQ() {
        return this.getToken(asirParser.SUREQ, 0);
    }
    POWEREQ() {
        return this.getToken(asirParser.POWEREQ, 0);
    }
    enterRule(listener) {
        if (listener.enterAssignExpr) {
            listener.enterAssignExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitAssignExpr) {
            listener.exitAssignExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitAssignExpr) {
            return visitor.visitAssignExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.AssignExprContext = AssignExprContext;
class FactorialExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    NOT() {
        return this.getToken(asirParser.NOT, 0);
    }
    enterRule(listener) {
        if (listener.enterFactorialExpr) {
            listener.enterFactorialExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFactorialExpr) {
            listener.exitFactorialExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFactorialExpr) {
            return visitor.visitFactorialExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FactorialExprContext = FactorialExprContext;
class ListLiteralExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    list() {
        return this.getRuleContext(0, ListContext);
    }
    enterRule(listener) {
        if (listener.enterListLiteralExpr) {
            listener.enterListLiteralExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitListLiteralExpr) {
            listener.exitListLiteralExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitListLiteralExpr) {
            return visitor.visitListLiteralExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ListLiteralExprContext = ListLiteralExprContext;
class PrecharExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    prechar() {
        return this.getRuleContext(0, PrecharContext);
    }
    enterRule(listener) {
        if (listener.enterPrecharExpr) {
            listener.enterPrecharExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPrecharExpr) {
            listener.exitPrecharExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPrecharExpr) {
            return visitor.visitPrecharExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PrecharExprContext = PrecharExprContext;
class QENotExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QE_8() {
        return this.getToken(asirParser.QE_8, 0);
    }
    enterRule(listener) {
        if (listener.enterQENotExpr) {
            listener.enterQENotExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQENotExpr) {
            listener.exitQENotExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQENotExpr) {
            return visitor.visitQENotExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QENotExprContext = QENotExprContext;
class VarExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    indeterminate() {
        return this.getRuleContext(0, IndeterminateContext);
    }
    enterRule(listener) {
        if (listener.enterVarExpr) {
            listener.enterVarExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitVarExpr) {
            listener.exitVarExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitVarExpr) {
            return visitor.visitVarExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.VarExprContext = VarExprContext;
class FCallExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._diffOrders = [];
        this._options = [];
        super.copyFrom(ctx);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    qualifiedName() {
        return this.getRuleContext(0, QualifiedNameContext);
    }
    LBRANCE() {
        return this.getToken(asirParser.LBRANCE, 0);
    }
    RBRANCE() {
        return this.getToken(asirParser.RBRANCE, 0);
    }
    MID() {
        return this.getToken(asirParser.MID, 0);
    }
    COLON2() {
        return this.getToken(asirParser.COLON2, 0);
    }
    INT(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.INT);
        }
        else {
            return this.getToken(asirParser.INT, i);
        }
    }
    exprlist() {
        return this.getRuleContext(0, ExprlistContext);
    }
    optionPair(i) {
        if (i === undefined) {
            return this.getRuleContexts(OptionPairContext);
        }
        return this.getRuleContext(i, OptionPairContext);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterFCallExpr) {
            listener.enterFCallExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFCallExpr) {
            listener.exitFCallExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFCallExpr) {
            return visitor.visitFCallExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FCallExprContext = FCallExprContext;
class QEAndExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QE_9() {
        return this.getToken(asirParser.QE_9, 0);
    }
    QE_10() {
        return this.getToken(asirParser.QE_10, 0);
    }
    enterRule(listener) {
        if (listener.enterQEAndExpr) {
            listener.enterQEAndExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQEAndExpr) {
            listener.exitQEAndExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQEAndExpr) {
            return visitor.visitQEAndExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QEAndExprContext = QEAndExprContext;
class FunctorCallExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        this._options = [];
        super.copyFrom(ctx);
    }
    LPAREN(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.LPAREN);
        }
        else {
            return this.getToken(asirParser.LPAREN, i);
        }
    }
    MULT() {
        return this.getToken(asirParser.MULT, 0);
    }
    RPAREN(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.RPAREN);
        }
        else {
            return this.getToken(asirParser.RPAREN, i);
        }
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    MID() {
        return this.getToken(asirParser.MID, 0);
    }
    exprlist() {
        return this.getRuleContext(0, ExprlistContext);
    }
    optionPair(i) {
        if (i === undefined) {
            return this.getRuleContexts(OptionPairContext);
        }
        return this.getRuleContext(i, OptionPairContext);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    enterRule(listener) {
        if (listener.enterFunctorCallExpr) {
            listener.enterFunctorCallExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFunctorCallExpr) {
            listener.exitFunctorCallExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFunctorCallExpr) {
            return visitor.visitFunctorCallExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FunctorCallExprContext = FunctorCallExprContext;
class TernaryExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QUESTION() {
        return this.getToken(asirParser.QUESTION, 0);
    }
    COLON() {
        return this.getToken(asirParser.COLON, 0);
    }
    enterRule(listener) {
        if (listener.enterTernaryExpr) {
            listener.enterTernaryExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitTernaryExpr) {
            listener.exitTernaryExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitTernaryExpr) {
            return visitor.visitTernaryExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.TernaryExprContext = TernaryExprContext;
class QECompareExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QE_1() {
        return this.getToken(asirParser.QE_1, 0);
    }
    QE_2() {
        return this.getToken(asirParser.QE_2, 0);
    }
    QE_3() {
        return this.getToken(asirParser.QE_3, 0);
    }
    QE_4() {
        return this.getToken(asirParser.QE_4, 0);
    }
    QE_5() {
        return this.getToken(asirParser.QE_5, 0);
    }
    QE_6() {
        return this.getToken(asirParser.QE_6, 0);
    }
    QE_7() {
        return this.getToken(asirParser.QE_7, 0);
    }
    enterRule(listener) {
        if (listener.enterQECompareExpr) {
            listener.enterQECompareExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQECompareExpr) {
            listener.exitQECompareExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQECompareExpr) {
            return visitor.visitQECompareExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QECompareExprContext = QECompareExprContext;
class IdLiteralContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    id() {
        return this.getRuleContext(0, IdContext);
    }
    enterRule(listener) {
        if (listener.enterIdLiteral) {
            listener.enterIdLiteral(this);
        }
    }
    exitRule(listener) {
        if (listener.exitIdLiteral) {
            listener.exitIdLiteral(this);
        }
    }
    accept(visitor) {
        if (visitor.visitIdLiteral) {
            return visitor.visitIdLiteral(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.IdLiteralContext = IdLiteralContext;
class UnarySignExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    PLUS() {
        return this.getToken(asirParser.PLUS, 0);
    }
    MINUS() {
        return this.getToken(asirParser.MINUS, 0);
    }
    enterRule(listener) {
        if (listener.enterUnarySignExpr) {
            listener.enterUnarySignExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitUnarySignExpr) {
            listener.exitUnarySignExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitUnarySignExpr) {
            return visitor.visitUnarySignExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.UnarySignExprContext = UnarySignExprContext;
class OrExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    OR() {
        return this.getToken(asirParser.OR, 0);
    }
    enterRule(listener) {
        if (listener.enterOrExpr) {
            listener.enterOrExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitOrExpr) {
            listener.exitOrExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitOrExpr) {
            return visitor.visitOrExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.OrExprContext = OrExprContext;
class QEOrExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QE_11() {
        return this.getToken(asirParser.QE_11, 0);
    }
    QE_12() {
        return this.getToken(asirParser.QE_12, 0);
    }
    enterRule(listener) {
        if (listener.enterQEOrExpr) {
            listener.enterQEOrExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQEOrExpr) {
            listener.exitQEOrExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQEOrExpr) {
            return visitor.visitQEOrExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QEOrExprContext = QEOrExprContext;
class PowerExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    POWER() {
        return this.getToken(asirParser.POWER, 0);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    enterRule(listener) {
        if (listener.enterPowerExpr) {
            listener.enterPowerExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPowerExpr) {
            listener.exitPowerExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPowerExpr) {
            return visitor.visitPowerExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PowerExprContext = PowerExprContext;
class QEImplExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    QE_IMPL() {
        return this.getToken(asirParser.QE_IMPL, 0);
    }
    QE_REPL() {
        return this.getToken(asirParser.QE_REPL, 0);
    }
    QE_EQUIV() {
        return this.getToken(asirParser.QE_EQUIV, 0);
    }
    enterRule(listener) {
        if (listener.enterQEImplExpr) {
            listener.enterQEImplExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQEImplExpr) {
            listener.exitQEImplExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQEImplExpr) {
            return visitor.visitQEImplExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QEImplExprContext = QEImplExprContext;
class DpolyLiteralExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    dpoly() {
        return this.getRuleContext(0, DpolyContext);
    }
    enterRule(listener) {
        if (listener.enterDpolyLiteralExpr) {
            listener.enterDpolyLiteralExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDpolyLiteralExpr) {
            listener.exitDpolyLiteralExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDpolyLiteralExpr) {
            return visitor.visitDpolyLiteralExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DpolyLiteralExprContext = DpolyLiteralExprContext;
class QuoteExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    BACK() {
        return this.getToken(asirParser.BACK, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    enterRule(listener) {
        if (listener.enterQuoteExpr) {
            listener.enterQuoteExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQuoteExpr) {
            listener.exitQuoteExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQuoteExpr) {
            return visitor.visitQuoteExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QuoteExprContext = QuoteExprContext;
class PostFixExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    INC() {
        return this.getToken(asirParser.INC, 0);
    }
    DEC() {
        return this.getToken(asirParser.DEC, 0);
    }
    enterRule(listener) {
        if (listener.enterPostFixExpr) {
            listener.enterPostFixExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitPostFixExpr) {
            listener.exitPostFixExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitPostFixExpr) {
            return visitor.visitPostFixExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.PostFixExprContext = PostFixExprContext;
class ParenExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    LPAREN() {
        return this.getToken(asirParser.LPAREN, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    RPAREN() {
        return this.getToken(asirParser.RPAREN, 0);
    }
    enterRule(listener) {
        if (listener.enterParenExpr) {
            listener.enterParenExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitParenExpr) {
            listener.exitParenExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitParenExpr) {
            return visitor.visitParenExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ParenExprContext = ParenExprContext;
class MemberAccessExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    ARROW(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.ARROW);
        }
        else {
            return this.getToken(asirParser.ARROW, i);
        }
    }
    indeterminate(i) {
        if (i === undefined) {
            return this.getRuleContexts(IndeterminateContext);
        }
        return this.getRuleContext(i, IndeterminateContext);
    }
    enterRule(listener) {
        if (listener.enterMemberAccessExpr) {
            listener.enterMemberAccessExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitMemberAccessExpr) {
            listener.exitMemberAccessExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitMemberAccessExpr) {
            return visitor.visitMemberAccessExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.MemberAccessExprContext = MemberAccessExprContext;
class AddSubExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    PLUS() {
        return this.getToken(asirParser.PLUS, 0);
    }
    MINUS() {
        return this.getToken(asirParser.MINUS, 0);
    }
    enterRule(listener) {
        if (listener.enterAddSubExpr) {
            listener.enterAddSubExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitAddSubExpr) {
            listener.exitAddSubExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitAddSubExpr) {
            return visitor.visitAddSubExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.AddSubExprContext = AddSubExprContext;
class NumberLiteralContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    num() {
        return this.getRuleContext(0, NumContext);
    }
    enterRule(listener) {
        if (listener.enterNumberLiteral) {
            listener.enterNumberLiteral(this);
        }
    }
    exitRule(listener) {
        if (listener.exitNumberLiteral) {
            listener.exitNumberLiteral(this);
        }
    }
    accept(visitor) {
        if (visitor.visitNumberLiteral) {
            return visitor.visitNumberLiteral(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.NumberLiteralContext = NumberLiteralContext;
class MulDivSurExprContext extends ExprContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    MULT() {
        return this.getToken(asirParser.MULT, 0);
    }
    DIV() {
        return this.getToken(asirParser.DIV, 0);
    }
    SUR() {
        return this.getToken(asirParser.SUR, 0);
    }
    enterRule(listener) {
        if (listener.enterMulDivSurExpr) {
            listener.enterMulDivSurExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitMulDivSurExpr) {
            listener.exitMulDivSurExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitMulDivSurExpr) {
            return visitor.visitMulDivSurExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.MulDivSurExprContext = MulDivSurExprContext;
class QualifiedNameContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    indeterminate() {
        return this.getRuleContext(0, IndeterminateContext);
    }
    DOT() {
        return this.getToken(asirParser.DOT, 0);
    }
    ID() {
        return this.getToken(asirParser.ID, 0);
    }
    get ruleIndex() {
        return asirParser.RULE_qualifiedName;
    }
    enterRule(listener) {
        if (listener.enterQualifiedName) {
            listener.enterQualifiedName(this);
        }
    }
    exitRule(listener) {
        if (listener.exitQualifiedName) {
            listener.exitQualifiedName(this);
        }
    }
    accept(visitor) {
        if (visitor.visitQualifiedName) {
            return visitor.visitQualifiedName(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.QualifiedNameContext = QualifiedNameContext;
class DottedIdentifierContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    indeterminate(i) {
        if (i === undefined) {
            return this.getRuleContexts(IndeterminateContext);
        }
        return this.getRuleContext(i, IndeterminateContext);
    }
    DOT(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.DOT);
        }
        else {
            return this.getToken(asirParser.DOT, i);
        }
    }
    get ruleIndex() {
        return asirParser.RULE_dottedIdentifier;
    }
    enterRule(listener) {
        if (listener.enterDottedIdentifier) {
            listener.enterDottedIdentifier(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDottedIdentifier) {
            listener.exitDottedIdentifier(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDottedIdentifier) {
            return visitor.visitDottedIdentifier(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DottedIdentifierContext = DottedIdentifierContext;
class ExprlistContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    expr(i) {
        if (i === undefined) {
            return this.getRuleContexts(ExprContext);
        }
        return this.getRuleContext(i, ExprContext);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    get ruleIndex() {
        return asirParser.RULE_exprlist;
    }
    enterRule(listener) {
        if (listener.enterExprlist) {
            listener.enterExprlist(this);
        }
    }
    exitRule(listener) {
        if (listener.exitExprlist) {
            listener.exitExprlist(this);
        }
    }
    accept(visitor) {
        if (visitor.visitExprlist) {
            return visitor.visitExprlist(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ExprlistContext = ExprlistContext;
class TerminatorContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    SEMI() {
        return this.getToken(asirParser.SEMI, 0);
    }
    DOLLAR() {
        return this.getToken(asirParser.DOLLAR, 0);
    }
    get ruleIndex() {
        return asirParser.RULE_terminator;
    }
    enterRule(listener) {
        if (listener.enterTerminator) {
            listener.enterTerminator(this);
        }
    }
    exitRule(listener) {
        if (listener.exitTerminator) {
            listener.exitTerminator(this);
        }
    }
    accept(visitor) {
        if (visitor.visitTerminator) {
            return visitor.visitTerminator(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.TerminatorContext = TerminatorContext;
class SystemPathContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    SYSTEM_PATH_LITERAL() {
        return this.getToken(asirParser.SYSTEM_PATH_LITERAL, 0);
    }
    get ruleIndex() {
        return asirParser.RULE_systemPath;
    }
    enterRule(listener) {
        if (listener.enterSystemPath) {
            listener.enterSystemPath(this);
        }
    }
    exitRule(listener) {
        if (listener.exitSystemPath) {
            listener.exitSystemPath(this);
        }
    }
    accept(visitor) {
        if (visitor.visitSystemPath) {
            return visitor.visitSystemPath(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.SystemPathContext = SystemPathContext;
class ElifClauseContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
        this._statements = [];
    }
    PELIF() {
        return this.getToken(asirParser.PELIF, 0);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    statement(i) {
        if (i === undefined) {
            return this.getRuleContexts(StatementContext);
        }
        return this.getRuleContext(i, StatementContext);
    }
    get ruleIndex() {
        return asirParser.RULE_elifClause;
    }
    enterRule(listener) {
        if (listener.enterElifClause) {
            listener.enterElifClause(this);
        }
    }
    exitRule(listener) {
        if (listener.exitElifClause) {
            listener.exitElifClause(this);
        }
    }
    accept(visitor) {
        if (visitor.visitElifClause) {
            return visitor.visitElifClause(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ElifClauseContext = ElifClauseContext;
class ElseClauseContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
        this._statements = [];
    }
    PELSE() {
        return this.getToken(asirParser.PELSE, 0);
    }
    statement(i) {
        if (i === undefined) {
            return this.getRuleContexts(StatementContext);
        }
        return this.getRuleContext(i, StatementContext);
    }
    get ruleIndex() {
        return asirParser.RULE_elseClause;
    }
    enterRule(listener) {
        if (listener.enterElseClause) {
            listener.enterElseClause(this);
        }
    }
    exitRule(listener) {
        if (listener.exitElseClause) {
            listener.exitElseClause(this);
        }
    }
    accept(visitor) {
        if (visitor.visitElseClause) {
            return visitor.visitElseClause(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ElseClauseContext = ElseClauseContext;
class OptionPairContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    ASSIGN() {
        return this.getToken(asirParser.ASSIGN, 0);
    }
    indeterminate() {
        return this.getRuleContext(0, IndeterminateContext);
    }
    expr() {
        return this.getRuleContext(0, ExprContext);
    }
    get ruleIndex() {
        return asirParser.RULE_optionPair;
    }
    enterRule(listener) {
        if (listener.enterOptionPair) {
            listener.enterOptionPair(this);
        }
    }
    exitRule(listener) {
        if (listener.exitOptionPair) {
            listener.exitOptionPair(this);
        }
    }
    accept(visitor) {
        if (visitor.visitOptionPair) {
            return visitor.visitOptionPair(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.OptionPairContext = OptionPairContext;
class DpolyContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_dpoly;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.DpolyContext = DpolyContext;
class DpContext extends DpolyContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    LTLT() {
        return this.getToken(asirParser.LTLT, 0);
    }
    INT(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.INT);
        }
        else {
            return this.getToken(asirParser.INT, i);
        }
    }
    GTGT() {
        return this.getToken(asirParser.GTGT, 0);
    }
    COMMA(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.COMMA);
        }
        else {
            return this.getToken(asirParser.COMMA, i);
        }
    }
    COLON() {
        return this.getToken(asirParser.COLON, 0);
    }
    enterRule(listener) {
        if (listener.enterDp) {
            listener.enterDp(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDp) {
            listener.exitDp(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDp) {
            return visitor.visitDp(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DpContext = DpContext;
class RationalContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_rational;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.RationalContext = RationalContext;
class RatContext extends RationalContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    INT(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.INT);
        }
        else {
            return this.getToken(asirParser.INT, i);
        }
    }
    DIV() {
        return this.getToken(asirParser.DIV, 0);
    }
    MINUS(i) {
        if (i === undefined) {
            return this.getTokens(asirParser.MINUS);
        }
        else {
            return this.getToken(asirParser.MINUS, i);
        }
    }
    enterRule(listener) {
        if (listener.enterRat) {
            listener.enterRat(this);
        }
    }
    exitRule(listener) {
        if (listener.exitRat) {
            listener.exitRat(this);
        }
    }
    accept(visitor) {
        if (visitor.visitRat) {
            return visitor.visitRat(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.RatContext = RatContext;
class DecimalContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_decimal;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.DecimalContext = DecimalContext;
class FloatContext extends DecimalContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    FLOAT() {
        return this.getToken(asirParser.FLOAT, 0);
    }
    INT() {
        return this.getToken(asirParser.INT, 0);
    }
    enterRule(listener) {
        if (listener.enterFloat) {
            listener.enterFloat(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFloat) {
            listener.exitFloat(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFloat) {
            return visitor.visitFloat(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FloatContext = FloatContext;
class NumContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_num;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.NumContext = NumContext;
class DecNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    decimal() {
        return this.getRuleContext(0, DecimalContext);
    }
    enterRule(listener) {
        if (listener.enterDecNum) {
            listener.enterDecNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitDecNum) {
            listener.exitDecNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitDecNum) {
            return visitor.visitDecNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.DecNumContext = DecNumContext;
class BitNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    BIT() {
        return this.getToken(asirParser.BIT, 0);
    }
    enterRule(listener) {
        if (listener.enterBitNum) {
            listener.enterBitNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitBitNum) {
            listener.exitBitNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitBitNum) {
            return visitor.visitBitNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.BitNumContext = BitNumContext;
class ApGenNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    APGEN() {
        return this.getToken(asirParser.APGEN, 0);
    }
    enterRule(listener) {
        if (listener.enterApGenNum) {
            listener.enterApGenNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitApGenNum) {
            listener.exitApGenNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitApGenNum) {
            return visitor.visitApGenNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ApGenNumContext = ApGenNumContext;
class ImaNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    IMAGINARY() {
        return this.getToken(asirParser.IMAGINARY, 0);
    }
    enterRule(listener) {
        if (listener.enterImaNum) {
            listener.enterImaNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitImaNum) {
            listener.exitImaNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitImaNum) {
            return visitor.visitImaNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ImaNumContext = ImaNumContext;
class HexNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    HEX() {
        return this.getToken(asirParser.HEX, 0);
    }
    enterRule(listener) {
        if (listener.enterHexNum) {
            listener.enterHexNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitHexNum) {
            listener.exitHexNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitHexNum) {
            return visitor.visitHexNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.HexNumContext = HexNumContext;
class RatNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    rational() {
        return this.getRuleContext(0, RationalContext);
    }
    enterRule(listener) {
        if (listener.enterRatNum) {
            listener.enterRatNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitRatNum) {
            listener.exitRatNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitRatNum) {
            return visitor.visitRatNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.RatNumContext = RatNumContext;
class AsGenNumContext extends NumContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    ASGEN() {
        return this.getToken(asirParser.ASGEN, 0);
    }
    enterRule(listener) {
        if (listener.enterAsGenNum) {
            listener.enterAsGenNum(this);
        }
    }
    exitRule(listener) {
        if (listener.exitAsGenNum) {
            listener.exitAsGenNum(this);
        }
    }
    accept(visitor) {
        if (visitor.visitAsGenNum) {
            return visitor.visitAsGenNum(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.AsGenNumContext = AsGenNumContext;
class IdContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_id;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.IdContext = IdContext;
class V2IdContext extends IdContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    VAR_2() {
        return this.getToken(asirParser.VAR_2, 0);
    }
    enterRule(listener) {
        if (listener.enterV2Id) {
            listener.enterV2Id(this);
        }
    }
    exitRule(listener) {
        if (listener.exitV2Id) {
            listener.exitV2Id(this);
        }
    }
    accept(visitor) {
        if (visitor.visitV2Id) {
            return visitor.visitV2Id(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.V2IdContext = V2IdContext;
class BefContext extends IdContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    BEFORE() {
        return this.getToken(asirParser.BEFORE, 0);
    }
    enterRule(listener) {
        if (listener.enterBef) {
            listener.enterBef(this);
        }
    }
    exitRule(listener) {
        if (listener.exitBef) {
            listener.exitBef(this);
        }
    }
    accept(visitor) {
        if (visitor.visitBef) {
            return visitor.visitBef(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.BefContext = BefContext;
class BefNContext extends IdContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    BEFORE_N() {
        return this.getToken(asirParser.BEFORE_N, 0);
    }
    enterRule(listener) {
        if (listener.enterBefN) {
            listener.enterBefN(this);
        }
    }
    exitRule(listener) {
        if (listener.exitBefN) {
            listener.exitBefN(this);
        }
    }
    accept(visitor) {
        if (visitor.visitBefN) {
            return visitor.visitBefN(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.BefNContext = BefNContext;
class IndeterminateContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_indeterminate;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.IndeterminateContext = IndeterminateContext;
class FuncContext extends IndeterminateContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    ID() {
        return this.getToken(asirParser.ID, 0);
    }
    enterRule(listener) {
        if (listener.enterFunc) {
            listener.enterFunc(this);
        }
    }
    exitRule(listener) {
        if (listener.exitFunc) {
            listener.exitFunc(this);
        }
    }
    accept(visitor) {
        if (visitor.visitFunc) {
            return visitor.visitFunc(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.FuncContext = FuncContext;
class ChFuncContext extends IndeterminateContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    NOSTRING() {
        return this.getToken(asirParser.NOSTRING, 0);
    }
    enterRule(listener) {
        if (listener.enterChFunc) {
            listener.enterChFunc(this);
        }
    }
    exitRule(listener) {
        if (listener.exitChFunc) {
            listener.exitChFunc(this);
        }
    }
    accept(visitor) {
        if (visitor.visitChFunc) {
            return visitor.visitChFunc(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ChFuncContext = ChFuncContext;
class AtFuncContext extends IndeterminateContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    ATFUNC() {
        return this.getToken(asirParser.ATFUNC, 0);
    }
    enterRule(listener) {
        if (listener.enterAtFunc) {
            listener.enterAtFunc(this);
        }
    }
    exitRule(listener) {
        if (listener.exitAtFunc) {
            listener.exitAtFunc(this);
        }
    }
    accept(visitor) {
        if (visitor.visitAtFunc) {
            return visitor.visitAtFunc(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.AtFuncContext = AtFuncContext;
class ListContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_list;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.ListContext = ListContext;
class ListExprContext extends ListContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    LBRACKET() {
        return this.getToken(asirParser.LBRACKET, 0);
    }
    RBRACKET() {
        return this.getToken(asirParser.RBRACKET, 0);
    }
    exprlist() {
        return this.getRuleContext(0, ExprlistContext);
    }
    enterRule(listener) {
        if (listener.enterListExpr) {
            listener.enterListExpr(this);
        }
    }
    exitRule(listener) {
        if (listener.exitListExpr) {
            listener.exitListExpr(this);
        }
    }
    accept(visitor) {
        if (visitor.visitListExpr) {
            return visitor.visitListExpr(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.ListExprContext = ListExprContext;
class BlockContext extends antlr.ParserRuleContext {
    constructor(parent, invokingState) {
        super(parent, invokingState);
    }
    get ruleIndex() {
        return asirParser.RULE_block;
    }
    copyFrom(ctx) {
        super.copyFrom(ctx);
    }
}
exports.BlockContext = BlockContext;
class Sentence1Context extends BlockContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    statement() {
        return this.getRuleContext(0, StatementContext);
    }
    enterRule(listener) {
        if (listener.enterSentence1) {
            listener.enterSentence1(this);
        }
    }
    exitRule(listener) {
        if (listener.exitSentence1) {
            listener.exitSentence1(this);
        }
    }
    accept(visitor) {
        if (visitor.visitSentence1) {
            return visitor.visitSentence1(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.Sentence1Context = Sentence1Context;
class SentenceContext extends BlockContext {
    constructor(ctx) {
        super(ctx.parent, ctx.invokingState);
        super.copyFrom(ctx);
    }
    LBRANCE() {
        return this.getToken(asirParser.LBRANCE, 0);
    }
    RBRANCE() {
        return this.getToken(asirParser.RBRANCE, 0);
    }
    statement(i) {
        if (i === undefined) {
            return this.getRuleContexts(StatementContext);
        }
        return this.getRuleContext(i, StatementContext);
    }
    enterRule(listener) {
        if (listener.enterSentence) {
            listener.enterSentence(this);
        }
    }
    exitRule(listener) {
        if (listener.exitSentence) {
            listener.exitSentence(this);
        }
    }
    accept(visitor) {
        if (visitor.visitSentence) {
            return visitor.visitSentence(this);
        }
        else {
            return visitor.visitChildren(this);
        }
    }
}
exports.SentenceContext = SentenceContext;
//# sourceMappingURL=asirParser.js.map

/***/ }),

/***/ "../pasirser/dist/analysis/astCache.js":
/*!*********************************************!*\
  !*** ../pasirser/dist/analysis/astCache.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ASTCache = void 0;
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const parserUtils_1 = __webpack_require__(/*! ../core/parser/parserUtils */ "../pasirser/dist/core/parser/parserUtils.js");
class ASTCache {
    constructor() {
        this.cache = new Map();
    }
    static getInstance() {
        if (!ASTCache.instance) {
            ASTCache.instance = new ASTCache();
        }
        return ASTCache.instance;
    }
    // ファイルをパースするかキャッシュを返す
    getAST(filePath) {
        try {
            const stats = fs.statSync(filePath);
            const currentMtime = stats.mtimeMs;
            if (this.cache.has(filePath)) {
                const entry = this.cache.get(filePath);
                if (entry.mtimeMs === currentMtime) {
                    return { ast: entry.ast, diagnostics: entry.diagnostics };
                }
            }
            const code = fs.readFileSync(filePath, 'utf-8');
            const result = (0, parserUtils_1.parseAndBuildAST)(code, filePath);
            this.cache.set(filePath, {
                mtimeMs: currentMtime,
                ast: result.ast,
                diagnostics: result.diagnostics
            });
            return result;
        }
        catch (e) {
            return { ast: null, diagnostics: [] };
        }
    }
    clear() {
        this.cache.clear();
    }
}
exports.ASTCache = ASTCache;
//# sourceMappingURL=astCache.js.map

/***/ }),

/***/ "../pasirser/dist/core/ast/asirASTBuilder.js":
/*!***************************************************!*\
  !*** ../pasirser/dist/core/ast/asirASTBuilder.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsirASTBuilder = void 0;
const antlr4ng_1 = __webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs");
// --- loc用のヘルパー関数 ---
function getLoc(ctx) {
    if (!ctx)
        return undefined;
    let startToken;
    let stopToken;
    if (ctx instanceof antlr4ng_1.ParserRuleContext) {
        if (!ctx.start || !ctx.stop)
            return undefined;
        startToken = ctx.start;
        stopToken = ctx.stop;
    }
    else if (ctx instanceof antlr4ng_1.TerminalNode) {
        startToken = ctx.symbol;
        stopToken = ctx.symbol;
    }
    else {
        startToken = ctx;
        stopToken = ctx;
    }
    return {
        start: {
            line: startToken.line,
            column: startToken.column,
            offset: startToken.start,
        },
        end: {
            line: stopToken.line,
            column: stopToken.column + (stopToken.text?.length || 0),
            offset: stopToken.start + 1,
        }
    };
}
// --- Visitor Class ---
class AsirASTBuilder extends antlr4ng_1.AbstractParseTreeVisitor {
    // デフォルト
    defaultResult() {
        return { kind: 'Error', message: 'Not implemented or unknown node' };
    }
    // --- ヘルパーメソッド ---
    // 構文エラーなどによってctxが存在しない場合にクラッシュを防ぐ
    visitMandatory(ctx, expectedName) {
        if (!ctx) {
            return {
                kind: 'Error',
                message: `Missing expected node: ${expectedName}`
            };
        }
        const result = this.visit(ctx);
        if (!result) {
            return {
                kind: 'Error',
                message: `Visiting ${expectedName} returned nothing`,
                loc: getLoc(ctx)
            };
        }
        return result;
    }
    // ノードをvisitする
    visitOptional(ctx) {
        if (!ctx)
            return undefined;
        return this.visit(ctx);
    }
    // 識別子生成
    createIndeterminateNode(tokenOrNode) {
        const token = (tokenOrNode instanceof antlr4ng_1.TerminalNode) ? tokenOrNode.symbol : tokenOrNode;
        return {
            kind: 'Indeterminate',
            name: token.text || '',
            loc: getLoc(tokenOrNode)
        };
    }
    // --- Program Entry --- 
    visitProg(ctx) {
        const statements = [];
        for (const stmtCtx of ctx.statement()) {
            const stmtNode = this.visit(stmtCtx);
            if (stmtNode) {
                statements.push(stmtNode);
            }
        }
        return {
            kind: 'Program',
            statements: statements,
            loc: getLoc(ctx)
        };
    }
    // --- Statements ---
    visitExprStatement(ctx) {
        return {
            kind: 'ExpressionStatement',
            expression: this.visitMandatory(ctx.expr(), 'expression'),
            loc: getLoc(ctx)
        };
    }
    visitEmptyStatement(ctx) {
        return { kind: 'EmptyStatement', loc: getLoc(ctx) };
    }
    visitDefinitionStatement(ctx) {
        return this.visitMandatory(ctx.functionDefinition(), 'function definition');
    }
    // ... 他のstatementへの委譲メソッド ...
    visitForwardDeclStatement(ctx) {
        return this.visitMandatory(ctx.formDeclaration(), 'form declaration');
    }
    visitIfStatement(ctx) {
        return this.visitMandatory(ctx.functionIf(), 'if statement');
    }
    visitForStatement(ctx) {
        return this.visitMandatory(ctx.functionFor(), 'for statement');
    }
    visitWhileStatement(ctx) {
        return this.visitMandatory(ctx.functionWhile(), 'while statement');
    }
    visitDoStatement(ctx) {
        return this.visitMandatory(ctx.functionDo(), 'do statement');
    }
    visitReturnStatement(ctx) {
        return this.visitMandatory(ctx.functionReturn(), 'return statement');
    }
    visitBreakStatement(ctx) {
        return this.visitMandatory(ctx.functionBreak(), 'break statement');
    }
    visitContinueStatement(ctx) {
        return this.visitMandatory(ctx.functionContinue(), 'continue statement');
    }
    visitQuitStatement(ctx) {
        return this.visitMandatory(ctx.functionQuit(), 'quit statement');
    }
    visitDebugStatement(ctx) {
        return this.visitMandatory(ctx.functionDebug(), 'debug statement');
    }
    visitEndStatement(ctx) {
        return this.visitMandatory(ctx.functionEnd(), 'end statement');
    }
    visitStructStatement(ctx) {
        return this.visitMandatory(ctx.functionStruct(), 'struct statement');
    }
    visitModuleStatement(ctx) {
        return this.visitMandatory(ctx.functionModule(), 'module statement');
    }
    visitPreproStatement(ctx) {
        return this.visitMandatory(ctx.preprocessor(), 'preprocessor');
    }
    // --- expressions ---
    // 二項演算用のヘルパー関数
    createBinaryOp(leftCtx, rightCtx, operator, ctx) {
        return {
            kind: 'BinaryOperation',
            operator: operator,
            left: this.visitMandatory(leftCtx, 'left operand'),
            right: this.visitMandatory(rightCtx, 'right operand'),
            loc: getLoc(ctx)
        };
    }
    // --- 1. Atoms & Primary
    visitParenExpr(ctx) {
        return { kind: 'ParenExpression', expression: this.visitMandatory(ctx.expr(), 'expression'), loc: getLoc(ctx) };
    }
    visitNumberLiteral(ctx) {
        return this.visitMandatory(ctx.num(), 'number');
    }
    visitIdLiteral(ctx) {
        return this.visitMandatory(ctx.id(), 'id');
    }
    visitStringLiteralExpr(ctx) {
        const text = ctx.STRING().getText();
        const value = text.substring(1, text.length - 1);
        return { kind: 'StringLiteral', value: value, rawText: text, loc: getLoc(ctx) };
    }
    visitListLiteralExpr(ctx) {
        return this.visitMandatory(ctx.list(), 'list literal');
    }
    visitDpolyLiteralExpr(ctx) {
        return this.visitMandatory(ctx.dpoly(), 'distributed polynomial literal');
    }
    visitPreChrExpr(ctx) {
        return this.visitMandatory(ctx.prechar(), 'prechar');
    }
    visitVarExpr(ctx) {
        return this.visitMandatory(ctx.indeterminate(), 'variable');
    }
    visitDottedIdExpr(ctx) {
        return this.visitMandatory(ctx.dottedIdentifier(), 'dotted identifier');
    }
    // ---Function calls ---
    visitFCallExpr(ctx) {
        const callee = this.visitMandatory(ctx._path, 'function name');
        const isGlobal = !!ctx._is_global;
        let diffOrders = undefined;
        if (ctx._diffOrders && ctx._diffOrders.length > 0) {
            diffOrders = ctx._diffOrders.map(t => parseInt(t.text || '0', 10));
        }
        let args = [];
        if (ctx._args) {
            args = this.visitMandatory(ctx._args, 'arguments').expressions;
        }
        let options = [];
        if (ctx._options && ctx._options.length > 0) {
            options = ctx._options.map(o => this.visitMandatory(o, 'option'));
        }
        return {
            kind: 'FunctionCall',
            callee: callee,
            isGlobal: isGlobal,
            diffOrders: diffOrders,
            args: args,
            options: options,
            loc: getLoc(ctx)
        };
    }
    visitFunctorCallExpr(ctx) {
        const callee = this.visitMandatory(ctx._callee, 'callee expression');
        let args = [];
        if (ctx._args) {
            args = this.visitMandatory(ctx._args, 'arguments').expressions;
        }
        let options = [];
        if (ctx._options && ctx._options.length > 0) {
            options = ctx._options.map(o => this.visitMandatory(o, 'option'));
        }
        return {
            kind: 'FunctorCall',
            callee: callee,
            args: args,
            options: options,
            loc: getLoc(ctx)
        };
    }
    // --- 2. Suffix Operations ---
    visitMemberAccessExpr(ctx) {
        const base = this.visitMandatory(ctx.expr(), 'base expression');
        const members = ctx.indeterminate().map(id => this.visitMandatory(id, 'member'));
        return {
            kind: 'MemberAccess',
            base: base,
            members: members,
            loc: getLoc(ctx)
        };
    }
    visitIndexAccessExpr(ctx) {
        if (!ctx.expr() || ctx.expr().length === 0) {
            return this.defaultResult();
        }
        const baseCtx = ctx.expr(0) ?? undefined;
        const base = this.visitMandatory(baseCtx, 'base expression');
        const indices = [];
        if (ctx._indices) {
            for (const idxCtx of ctx._indices) {
                indices.push(this.visitMandatory(idxCtx, 'index expression'));
            }
        }
        return {
            kind: 'IndexAccess',
            base: base,
            indices: indices,
            loc: getLoc(ctx)
        };
    }
    visitPostFixExpr(ctx) {
        const op = (ctx.INC() || ctx.DEC()).getText();
        return {
            kind: 'UnaryOperation',
            operator: op,
            operand: this.visitMandatory(ctx.expr(), 'operand'),
            isPostfix: true,
            loc: getLoc(ctx)
        };
    }
    visitFactorialExpr(ctx) {
        return {
            kind: 'UnaryOperation',
            operator: '!',
            operand: this.visitMandatory(ctx.expr(), 'operand'),
            isPostfix: true,
            loc: getLoc(ctx)
        };
    }
    // --- 3. Prefix Operations ---
    visitPreFixExpr(ctx) {
        const op = (ctx.INC() || ctx.DEC()).getText();
        return {
            kind: 'UnaryOperation',
            operator: op,
            operand: this.visitMandatory(ctx.expr(), 'operand'),
            isPostfix: false,
            loc: getLoc(ctx)
        };
    }
    visitUnarySignExpr(ctx) {
        const op = (ctx.PLUS() || ctx.MINUS()).getText();
        return {
            kind: 'UnaryOperation',
            operator: op,
            operand: this.visitMandatory(ctx.expr(), 'operand'),
            loc: getLoc(ctx)
        };
    }
    visitUnaryNotExpr(ctx) {
        return {
            kind: 'UnaryOperation',
            operator: '!',
            operand: this.visitMandatory(ctx.expr(), 'operand'),
            loc: getLoc(ctx)
        };
    }
    // --- 4. Power ---
    visitPowerExpr(ctx) {
        return {
            kind: 'PowerOperation',
            base: this.visitMandatory(ctx._base, 'base'),
            exponent: this.visitMandatory(ctx._exponent, 'exponent'),
            loc: getLoc(ctx)
        };
    }
    // -- 5. Binary Operations ---
    visitMulDivSurExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '*', ctx);
    }
    visitAddSubExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '+', ctx);
    }
    visitRelationalExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '==', ctx);
    }
    visitAndExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), '&&', ctx);
    }
    // QE系
    visitQECompareExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '@==', ctx);
    }
    visitQEAndExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '@&&', ctx);
    }
    visitQEOrExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '@||', ctx);
    }
    visitQENotExpr(ctx) {
        // よく考えたらbinaryじゃなくね？（そこまで使わないものなので保留）
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), '@!', ctx);
    }
    visitQEImplExpr(ctx) {
        return this.createBinaryOp(ctx.expr(0), ctx.expr(1), ctx._op?.text || '@impl', ctx);
    }
    // --- 15. Quote ---
    visitQuoteExpr(ctx) {
        return {
            kind: 'UnaryOperation',
            operator: '`',
            operand: this.visitMandatory(ctx.expr(), 'quoted expression'),
            loc: getLoc(ctx)
        };
    }
    // --- 16. Ternary ---
    visitTernaryExpr(ctx) {
        return {
            kind: 'TernaryOperation',
            condition: this.visitMandatory(ctx._condition, 'condition'),
            consequence: this.visitMandatory(ctx._consequence, 'consequence'),
            alternative: this.visitMandatory(ctx._alternative, 'alternative'),
            loc: getLoc(ctx)
        };
    }
    // --- 17. Assignment ---
    visitAssignExpr(ctx) {
        let leftNode = this.visitMandatory(ctx._left, 'left hand side');
        const lValue = leftNode;
        return {
            kind: 'AssignmentExpression',
            left: lValue,
            operator: ctx._op?.text || '=',
            right: this.visitMandatory(ctx._right, 'right hand side'),
            loc: getLoc(ctx)
        };
    }
    // --- 18. Control Flow ---
    // ヘルパー関数
    getExpressionList(ctx) {
        if (!ctx.expr())
            return [];
        return ctx.expr().map(e => this.visitMandatory(e, 'expression in list'));
    }
    visitIf(ctx) {
        const condition = this.visitMandatory(ctx._condition, 'if condition');
        const consequent = this.visitMandatory(ctx._thenBlock, 'then block');
        let alternate;
        if (ctx._elseBlock) {
            alternate = this.visitMandatory(ctx._elseBlock, 'else block');
        }
        return {
            kind: 'IfStatement',
            condition: condition,
            thenStatement: consequent,
            elseStatement: alternate,
            loc: getLoc(ctx)
        };
    }
    visitFor(ctx) {
        const initializers = ctx._init ? this.visit(ctx._init).expressions : [];
        const conditions = ctx._cond ? this.visit(ctx._cond).expressions : [];
        const updaters = ctx._update ? this.visit(ctx._update).expressions : [];
        const body = this.visitMandatory(ctx.block(), 'for loop body');
        return {
            kind: 'ForStatement',
            initializers: initializers,
            conditions: conditions,
            updaters: updaters,
            body: body,
            loc: getLoc(ctx)
        };
    }
    visitWhile(ctx) {
        const conditions = ctx.exprlist() ? this.visit(ctx.exprlist()).expressions : [];
        const body = this.visitMandatory(ctx.block(), 'while loop body');
        return {
            kind: 'WhileStatement',
            conditions: conditions,
            body: body,
            loc: getLoc(ctx)
        };
    }
    visitDo(ctx) {
        const conditions = ctx.exprlist() ? this.visit(ctx.exprlist()).expressions : [];
        const body = this.visitMandatory(ctx.block(), 'do loop body');
        return {
            kind: 'DoWhileStatement',
            body: body,
            conditions: conditions,
            loc: getLoc(ctx)
        };
    }
    visitReturn(ctx) {
        const value = ctx.expr() ? this.visitMandatory(ctx.expr(), 'return value') : undefined;
        return {
            kind: 'ReturnStatement',
            value: value,
            loc: getLoc(ctx)
        };
    }
    visitBreak(ctx) {
        return { kind: 'BreakStatement', loc: getLoc(ctx) };
    }
    visitContinue(ctx) {
        return { kind: 'ContinueStatement', loc: getLoc(ctx) };
    }
    visitEnd(ctx) {
        return { kind: 'EndStatement', loc: getLoc(ctx) };
    }
    visitQuit(ctx) {
        return { kind: 'QuitStatement', loc: getLoc(ctx) };
    }
    visitDebug(ctx) {
        return { kind: 'DebugStatement', loc: getLoc(ctx) };
    }
    // --- 19. Block and Definitions ---
    visitSentence(ctx) {
        const statements = [];
        for (const s of ctx.statement()) {
            const res = this.visit(s);
            if (res)
                statements.push(res);
        }
        return { kind: 'Block', statements: statements, loc: getLoc(ctx) };
    }
    visitSentence1(ctx) {
        return this.visitMandatory(ctx.statement(), 'statement');
    }
    visitDef(ctx) {
        const nameNode = this.visitMandatory(ctx._name, 'function name');
        const parameters = [];
        if (ctx.ID && ctx.ID().length > 0) {
            for (const token of ctx.ID()) {
                parameters.push({
                    kind: 'Indeterminate',
                    name: token.getText(),
                    loc: getLoc(token.symbol)
                });
            }
        }
        const body = this.visitMandatory(ctx._body, 'function body');
        return {
            kind: 'FunctionDefinition',
            name: nameNode,
            parameters: parameters,
            body: body,
            loc: getLoc(ctx)
        };
    }
    visitFormDecl(ctx) {
        const nameNode = this.visitMandatory(ctx._name, 'function name');
        const parameters = [];
        if (ctx._params) {
            for (const p of ctx._params) {
                parameters.push(this.visitMandatory(p, 'parameter'));
            }
        }
        return {
            kind: 'FormDeclaration',
            name: nameNode,
            parameters: parameters,
            loc: getLoc(ctx)
        };
    }
    // --- 20. Module Statements ---
    visitModuleAssign(ctx) {
        const scopeText = (ctx.EXTERN() || ctx.STATIC() || ctx.GLOBAL() || ctx.LOCAL() || ctx.LOCALF()).getText().toLowerCase();
        const scope = scopeText;
        const variables = ctx.indeterminate().map(i => this.visitMandatory(i, 'variable'));
        return {
            kind: 'ModuleVariableDeclaration',
            scope: scope,
            variables: variables,
            loc: getLoc(ctx)
        };
    }
    visitModuleStart(ctx) {
        const name = this.visitMandatory(ctx.indeterminate(), 'module name');
        return { kind: 'ModuleDeclaration', name: name, loc: getLoc(ctx) };
    }
    visitModuleEnd(ctx) {
        return { kind: 'EndModule', loc: getLoc(ctx) };
    }
    // --- 21. Struct Statements ---
    visitStruct(ctx) {
        const name = this.visitMandatory(ctx._name, 'struct name');
        const members = ctx._members.map(m => this.visitMandatory(m, 'struct member'));
        return {
            kind: 'StructStatement',
            name: name,
            members: members,
            loc: getLoc(ctx)
        };
    }
    // --- 22. Numerics ---
    visitHexNum(ctx) {
        return { kind: 'NumberLiteral', value: parseInt(ctx.getText(), 16), rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitBitNum(ctx) {
        const text = ctx.getText();
        return { kind: 'NumberLiteral', value: parseInt(text.replace(/^0[bB]/, ''), 2), rawText: text, loc: getLoc(ctx) };
    }
    visitDecNum(ctx) {
        // decimalルールへ委譲
        return this.visitMandatory(ctx.decimal(), 'decimal');
    }
    visitFloat(ctx) {
        const text = ctx.getText();
        const val = ctx.FLOAT() ? parseFloat(text) : parseInt(text, 10);
        return { kind: 'NumberLiteral', value: val, rawText: text, loc: getLoc(ctx) };
    }
    visitRatNum(ctx) {
        return this.visitMandatory(ctx.rational(), 'rational');
    }
    visitRat(ctx) {
        // RationalLiteralNode を検討するのもあり
        return { kind: 'NumberLiteral', value: ctx.getText(), rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitImaNum(ctx) {
        return { kind: 'NumberLiteral', value: ctx.getText(), rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitApGenNum(ctx) {
        return { kind: 'NumberLiteral', value: ctx.getText(), rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitAsGenNum(ctx) {
        return { kind: 'NumberLiteral', value: ctx.getText(), rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    // --- 23. Indeterminate and Primitives ---
    visitFunc(ctx) {
        return {
            kind: 'Indeterminate',
            name: ctx.getText(),
            loc: getLoc(ctx)
        };
    }
    visitAtFunc(ctx) {
        return {
            kind: 'Indeterminate',
            name: ctx.getText(),
            loc: getLoc(ctx)
        };
    }
    visitChFunc(ctx) {
        return {
            kind: 'Indeterminate',
            name: ctx.getText(),
            loc: getLoc(ctx)
        };
    }
    visitBef(ctx) {
        return { kind: 'IdLiteral', rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitBefN(ctx) {
        return { kind: 'IdLiteral', rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    visitV2Id(ctx) {
        return { kind: 'IdLiteral', rawText: ctx.getText(), loc: getLoc(ctx) };
    }
    // --- 24. Preprocessor ---
    visitPDef(ctx) {
        const nameToken = ctx._name;
        const nameNode = {
            kind: 'Indeterminate',
            name: nameToken?.text || '',
            loc: getLoc(nameToken)
        };
        const parameters = [];
        if (ctx._params && ctx._params.length > 0) {
            for (const token of ctx._params) {
                parameters.push({
                    kind: 'Indeterminate',
                    name: token.text || '',
                    loc: getLoc(token)
                });
            }
        }
        return {
            kind: 'PreprocessorDefine',
            name: nameNode,
            parameters: parameters,
            body: this.visitMandatory(ctx.expr(), 'define body'),
            loc: getLoc(ctx)
        };
    }
    visitPInc(ctx) {
        let pathType = 'local';
        let path = '';
        if (ctx._path_sys) {
            pathType = 'system';
            const rawPath = ctx._path_sys.getText();
            path = rawPath.substring(1, rawPath.length - 1);
        }
        else if (ctx._path_loc) {
            pathType = 'local';
            const rawPath = ctx._path_loc.text || '';
            if (rawPath.length >= 2 && rawPath.startsWith('"') && rawPath.endsWith('"')) {
                path = rawPath.substring(1, rawPath.length - 1);
            }
            else {
                path = rawPath;
            }
        }
        return {
            kind: 'PreprocessorInclude',
            pathtype: pathType,
            path: path,
            loc: getLoc(ctx)
        };
    }
    visitPIf(ctx) {
        const directiveText = ctx._directive.text || '#if';
        const directive = directiveText.substring(1);
        const condition = this.visitMandatory(ctx._condition, 'preprocessor condition');
        const thenStatements = [];
        if (ctx._thenSymts) {
            for (const s of ctx._thenSymts) {
                const res = this.visit(s);
                if (res)
                    thenStatements.push(res);
            }
        }
        const elifClauses = [];
        if (ctx._elifs) {
            for (const e of ctx._elifs) {
                const res = this.visit(e);
                if (res)
                    elifClauses.push(res);
            }
        }
        let elseStatements;
        if (ctx._elseBlk) {
            elseStatements = this.visit(ctx._elseBlk);
        }
        return {
            kind: 'PreprocessorIf',
            directive: directive,
            condition: condition,
            thenStatements: thenStatements,
            elifClauses: elifClauses,
            elseStatements: elseStatements,
            loc: getLoc(ctx)
        };
    }
    visitElifClause(ctx) {
        const condition = this.visitMandatory(ctx._condition, 'elif condition');
        const statements = [];
        if (ctx._statements) {
            for (const e of ctx._statements) {
                const res = this.visit(e);
                if (res)
                    statements.push(res);
            }
        }
        return {
            kind: 'PreprocessorElif',
            condition: condition,
            statements: statements,
            loc: getLoc(ctx)
        };
    }
    visitElseClause(ctx) {
        const statements = [];
        if (ctx._statements) {
            for (const e of ctx._statements) {
                const res = this.visit(e);
                if (res)
                    statements.push(res);
            }
        }
        return {
            kind: 'PreprocessorElse',
            statements: statements,
            loc: getLoc(ctx)
        };
    }
    visitPreChr(ctx) {
        return {
            kind: 'StringLiteral',
            value: ctx.getText(),
            rawText: ctx.getText(),
            loc: getLoc(ctx)
        };
    }
    visitPreChrPlus(ctx) {
        return {
            kind: 'StringLiteral',
            value: ctx.getText(),
            rawText: ctx.getText(),
            loc: getLoc(ctx)
        };
    }
    // --- 25. other Literals ---
    visitListExpr(ctx) {
        const elements = ctx.exprlist() ? this.visit(ctx.exprlist()).expressions : [];
        return { kind: 'ListLiteral', elements: elements, loc: getLoc(ctx) };
    }
    visitDp(ctx) {
        const terms = [];
        if (ctx.INT()) {
            for (const t of ctx.INT()) {
                terms.push(parseInt(t.getText(), 10));
            }
        }
        let modulus;
        if (ctx.COLON()) {
            modulus = terms.pop();
        }
        return { kind: 'DistributedPolynomialLiteral', terms, modulus, loc: getLoc(ctx) };
    }
    visitQualifiedName(ctx) {
        let moduleNameNode = undefined;
        if (ctx._moduleName) {
            moduleNameNode = {
                kind: 'Indeterminate',
                name: ctx._moduleName.text || '',
                loc: getLoc(ctx._moduleName)
            };
        }
        const functionName = this.visitMandatory(ctx._funcName, 'function name');
        return {
            kind: 'QualifiedName',
            moduleName: moduleNameNode,
            functionName: functionName,
            loc: getLoc(ctx)
        };
    }
    // --- 26. others ---
    visitExprlist(ctx) {
        const expressions = [];
        if (ctx.expr()) {
            for (const e of ctx.expr()) {
                expressions.push(this.visitMandatory(e, 'expression in list'));
            }
        }
        return {
            kind: 'ExpressionList',
            expressions: expressions,
            loc: getLoc(ctx)
        };
    }
    visitOptionPair(ctx) {
        const key = this.visitMandatory(ctx._key, 'option key');
        const value = this.visitMandatory(ctx._value, 'option value');
        return {
            kind: 'OptionPair',
            key: key,
            value: value,
            loc: getLoc(ctx)
        };
    }
}
exports.AsirASTBuilder = AsirASTBuilder;
//# sourceMappingURL=asirASTBuilder.js.map

/***/ }),

/***/ "../pasirser/dist/core/ast/asirAst.js":
/*!********************************************!*\
  !*** ../pasirser/dist/core/ast/asirAst.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=asirAst.js.map

/***/ }),

/***/ "../pasirser/dist/core/parser/customErrorListener.js":
/*!***********************************************************!*\
  !*** ../pasirser/dist/core/parser/customErrorListener.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomErrorListener = void 0;
const antlr4ng_1 = __webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs");
// ANTLRErrorListenerを実装したカスタムクラス
class CustomErrorListener {
    constructor() {
        this._errors = [];
        this._ambiguities = [];
        this._diagnostics = [];
    }
    // public API
    getErrors() { return this._errors; }
    hasErrors() { return this._errors.length > 0; }
    clear() {
        this._errors = [];
        this._ambiguities = [];
        this._diagnostics = [];
    }
    // このメソッドが構文エラー発生時にパーサーから呼び出される
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
        let ruleStack = [];
        if (recognizer instanceof antlr4ng_1.Parser) {
            ruleStack = recognizer.getRuleInvocationStack().reverse();
        }
        const ecdColumn = charPositionInLine + (offendingSymbol?.text?.length ?? 1);
        // エラー情報を配列に保存
        this._errors.push({
            line: line,
            column: charPositionInLine,
            endLine: line,
            endColumn: ecdColumn,
            message: this.translateErrorMessage(msg, recognizer.vocabulary),
            offendingSymbol: offendingSymbol?.text ?? null,
            ruleStack: ruleStack,
        });
    }
    /**
     * 文法が曖昧な箇所を報告するために呼び出される
     */
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        const token = recognizer.tokenStream.get(startIndex);
        this._ambiguities.push({
            line: token.line,
            column: token.column,
            message: `Ambiguity detected at: '${token.text}'`
        });
    }
    /**
     * より強力だが低速な解析モードに切り替わろうとしていることを報告する
     */
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
        const token = recognizer.tokenStream.get(startIndex);
        this._diagnostics.push({
            type: 'FullContext',
            line: token.line,
            column: token.column,
            message: `Attempting full context parsing at: '${token.text}'`
        });
    }
    /**
     * コンテキストに依存する構文を検出したことを報告する
     */
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
        const token = recognizer.tokenStream.get(startIndex);
        this._diagnostics.push({
            type: 'ContextSensitivity',
            line: token.line,
            column: token.column,
            message: `Context sensitivity issue at: '${token.text}'`
        });
    }
    /**
     * 典型的なエラーメッセージを日本語で表示
     */
    translateErrorMessage(msg, vocabulary) {
        let match = msg.match(/mismatched input '(.+)' expecting (.+)/);
        if (match) {
            const actual = match[1];
            const expected = this.formatExpectedTokens(match[2], vocabulary);
            return `'${actual}' は不正な入力です。 ${expected} が期待されていました。`;
        }
        match = msg.match(/extraneous input '(.+)' expecting (.+)/);
        if (match) {
            const actual = match[1];
            const expected = this.formatExpectedTokens(match[2], vocabulary);
            return `余分な入力 '${actual}' があります。${expected} が期待されていました。`;
        }
        match = msg.match(/missing (.+) at '(.+)'/);
        if (match) {
            const expected = this.formatExpectedTokens(match[1], vocabulary);
            const actual = match[2];
            return `'${actual}' の前に ${expected} がありません。`;
        }
        match = msg.match(/no viable alternative at input '(.+)'/);
        if (match) {
            return `'${match[1]}' から始まる有効な構文が見つかりません。`;
        }
        return msg;
    }
    formatExpectedTokens(expectedStr, vocabulary) {
        const tokenDisplayNameMap = new Map([
            ['ID', '識別子'],
            ['STRING', '文字列'],
            ['INT', '整数'],
            ['FLOAT', '浮動小数'],
            ['SEMI', 'セミコロン(;)'],
            ['DOLLAR', 'ドル記号($)'],
            ["'<EOF>'", 'ファイルの終端'],
        ]);
        if (expectedStr.startsWith('{')) {
            const tokenNames = expectedStr.substring(1, expectedStr.length - 1).split(', ');
            const translatedNames = tokenNames.map(name => tokenDisplayNameMap.get(name) ?? name.replace(/'/g, ''));
            return `次のいずれか： ${translatedNames.join(', ')}`;
        }
        return tokenDisplayNameMap.get(expectedStr) ?? expectedStr.replace(/'/g, '');
    }
    // --- ヘルパーメソッド ---
    getAmbiguities() {
        return this._ambiguities;
    }
    getDiagnostics() {
        return this._diagnostics;
    }
}
exports.CustomErrorListener = CustomErrorListener;
//# sourceMappingURL=customErrorListener.js.map

/***/ }),

/***/ "../pasirser/dist/core/parser/parserUtils.js":
/*!***************************************************!*\
  !*** ../pasirser/dist/core/parser/parserUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAndBuildAST = parseAndBuildAST;
const antlr4ng_1 = __webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs");
const asirLexer_1 = __webpack_require__(/*! ../../.antlr/asirLexer */ "../pasirser/dist/.antlr/asirLexer.js");
const asirParser_1 = __webpack_require__(/*! ../../.antlr/asirParser */ "../pasirser/dist/.antlr/asirParser.js");
const asirASTBuilder_1 = __webpack_require__(/*! ../ast/asirASTBuilder */ "../pasirser/dist/core/ast/asirASTBuilder.js");
const customErrorListener_1 = __webpack_require__(/*! ./customErrorListener */ "../pasirser/dist/core/parser/customErrorListener.js");
const errors_1 = __webpack_require__(/*! ../../utils/errors */ "../pasirser/dist/utils/errors.js");
const diagnostics_1 = __webpack_require__(/*! ../../utils/diagnostics */ "../pasirser/dist/utils/diagnostics.js");
/**
 * Asirのソースコード文字列を解析し、AST（抽象構文木）と構文エラーを生成します。
 * @param code 解析するソースコード
 * @param filePathForErrors エラーメッセージに表示するファイルパス
 * @returns ASTと診断情報のオブジェクト
 */
function parseAndBuildAST(code, filePathForErrors) {
    const chars = antlr4ng_1.CharStream.fromString(code);
    const lexer = new asirLexer_1.asirLexer(chars);
    const tokens = new antlr4ng_1.CommonTokenStream(lexer);
    const parser = new asirParser_1.asirParser(tokens);
    parser.removeErrorListeners();
    const errorListener = new customErrorListener_1.CustomErrorListener();
    parser.addErrorListener(errorListener);
    const tree = parser.prog();
    const syntaxErrors = errorListener.getErrors();
    const ambiguities = errorListener.getAmbiguities();
    const otherDiagnostics = errorListener.getDiagnostics();
    const diagnostics = syntaxErrors.map(e => ({
        severity: diagnostics_1.DiagnosticSeverity.Error,
        range: {
            start: { line: e.line, character: e.column },
            end: { line: e.endLine, character: e.endColumn },
        },
        message: e.message,
        source: 'Syntax',
        filePath: filePathForErrors,
    }));
    ambiguities.forEach(a => {
        diagnostics.push({
            severity: diagnostics_1.DiagnosticSeverity.Hint,
            range: { start: { line: a.line, character: a.column }, end: { line: a.line, character: a.column + 1 } },
            message: a.message,
            source: 'Ambiguity',
            filePath: filePathForErrors,
        });
    });
    otherDiagnostics.forEach(d => {
        diagnostics.push({
            severity: diagnostics_1.DiagnosticSeverity.Hint,
            range: { start: { line: d.line, character: d.column }, end: { line: d.line, character: d.column + 1 } },
            message: d.message,
            source: d.type === 'FullContext' ? 'FullContext' : 'ContextSensitivity',
            filePath: filePathForErrors,
        });
    });
    // if (syntaxErrors.length > 0) {
    //     return { ast: null, diagnostics };
    // }
    const astBuilder = new asirASTBuilder_1.AsirASTBuilder();
    try {
        const result = astBuilder.visit(tree);
        if (result?.kind === 'Program') {
            return { ast: result, diagnostics };
        }
        else {
            diagnostics.push({
                severity: diagnostics_1.DiagnosticSeverity.Error,
                range: { start: { line: 1, character: 0 }, end: { line: 1, character: 1 } },
                message: result.message || 'Failed to build AST: Unknown root node',
                source: 'AST Builder',
                filePath: filePathForErrors
            });
            return { ast: null, diagnostics };
        }
    }
    catch (e) {
        if (e instanceof errors_1.ASTBuilderError) {
            const errorInfo = {
                line: e.loc?.start.line ?? 1,
                column: e.loc?.start.column ?? 0,
                endLine: e.loc?.end.line ?? e.loc?.start.line ?? 1,
                endColumn: e.loc?.end.column ?? e.loc?.start.column ?? 0,
                message: e.message,
                offendingSymbol: null,
                ruleStack: [],
            };
            diagnostics.push({
                severity: diagnostics_1.DiagnosticSeverity.Error,
                range: {
                    start: { line: errorInfo.line, character: errorInfo.column },
                    end: { line: errorInfo.endLine, character: errorInfo.endColumn },
                },
                message: errorInfo.message,
                source: 'AST Builder',
                filePath: filePathForErrors,
            });
            return { ast: null, diagnostics };
        }
        else {
            const fatalError = {
                severity: diagnostics_1.DiagnosticSeverity.Error,
                range: { start: { line: 0, character: 0 }, end: { line: 0, character: 1 } },
                message: `致命的なエラー: ${e}`,
                source: 'Fatal',
                filePath: filePathForErrors,
            };
            return { ast: null, diagnostics: [fatalError] };
        }
    }
}
//# sourceMappingURL=parserUtils.js.map

/***/ }),

/***/ "../pasirser/dist/data/builtinCategories.js":
/*!**************************************************!*\
  !*** ../pasirser/dist/data/builtinCategories.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BUILTIN_CATEGORIES = exports.BuiltinFunctionCategory = void 0;
var BuiltinFunctionCategory;
(function (BuiltinFunctionCategory) {
    BuiltinFunctionCategory[BuiltinFunctionCategory["Keyword"] = 0] = "Keyword";
    BuiltinFunctionCategory[BuiltinFunctionCategory["Form"] = 1] = "Form";
    BuiltinFunctionCategory[BuiltinFunctionCategory["Default"] = 2] = "Default";
})(BuiltinFunctionCategory || (exports.BuiltinFunctionCategory = BuiltinFunctionCategory = {}));
exports.BUILTIN_CATEGORIES = new Map();
// --- キーワード的関数 ---
exports.BUILTIN_CATEGORIES.set('map', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('car', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('cdr', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('getopt', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('newstruct', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('pari', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('quote', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('recmap', BuiltinFunctionCategory.Keyword);
exports.BUILTIN_CATEGORIES.set('timer', BuiltinFunctionCategory.Keyword);
// --- 関数形式 ---
exports.BUILTIN_CATEGORIES.set('sin', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('cos', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('log', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('exp', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('sinh', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('cosh', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('tan', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('tanh', BuiltinFunctionCategory.Form);
exports.BUILTIN_CATEGORIES.set('factorial', BuiltinFunctionCategory.Form);
// 上記で指定されていない BUILTIN_SIGNATURES の関数は 'Default' として扱います。
//# sourceMappingURL=builtinCategories.js.map

/***/ }),

/***/ "../pasirser/dist/data/builtinConstants.js":
/*!*************************************************!*\
  !*** ../pasirser/dist/data/builtinConstants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BUILTIN_CONSTANTS = void 0;
const types_1 = __webpack_require__(/*! ../semantics/types */ "../pasirser/dist/semantics/types.js");
exports.BUILTIN_CONSTANTS = new Map([
    ['@e', (0, types_1.p_type)('form')],
    ['@pi', (0, types_1.p_type)('form')],
    ['@i', (0, types_1.p_type)('complex')],
    ['@', (0, types_1.p_type)('fchar2')],
    ['@p', (0, types_1.p_type)('fcharp')],
    ['@s', (0, types_1.p_type)('fchardefp')],
    ['@lex', (0, types_1.p_type)('symbol')],
    ['@glex', (0, types_1.p_type)('symbol')],
    ['@grlex', (0, types_1.p_type)('symbol')],
    ['@true', (0, types_1.p_type)('qeformula')],
    ['@false', (0, types_1.p_type)('qeformula')],
    ['@void', (0, types_1.p_type)('void')],
]);
//# sourceMappingURL=builtinConstants.js.map

/***/ }),

/***/ "../pasirser/dist/data/builtinSignatures.js":
/*!**************************************************!*\
  !*** ../pasirser/dist/data/builtinSignatures.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BUILTIN_SIGNATURES = void 0;
const types_1 = __webpack_require__(/*! ../semantics/types */ "../pasirser/dist/semantics/types.js");
// 更新後は以下を実行
// python3 temp_for_review/find_missing_signatures.py src/data/builtins.ts src/data/builtinSignatures.ts > temp_for_review/undefined_builtin_functions.txt
// p_type('any')ってプリミティブ型じゃね？
// 組み込み関数用のシグネチャ
exports.BUILTIN_SIGNATURES = new Map([
    [
        'access',
        {
            kind: 'function',
            parameters: [{ name: 'file', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'alg',
        {
            kind: 'function',
            parameters: [{ name: 'i', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('alg'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'algtodalg',
        {
            kind: 'function',
            parameters: [{ name: 'alg', type: (0, types_1.p_type)('alg') }],
            returnType: (0, types_1.p_type)('dalg'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'algv',
        {
            kind: 'function',
            parameters: [{ name: 'i', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('indeterminate'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'append',
        {
            kind: 'function',
            parameters: [
                { name: 'list1', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'list2', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'arfreg',
        {
            kind: 'function',
            parameters: [
                { name: 'name', type: (0, types_1.p_type)('string') },
                { name: 'add', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'sub', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'mul', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'div', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'pwr', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'chsgn', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) },
                { name: 'comp', type: (0, types_1.u_type)([(0, types_1.p_type)('any'), types_1.type_0]) }
            ],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'args',
        {
            kind: 'function',
            parameters: [{ name: 'func', type: (0, types_1.p_type)('form') }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'asciitostr',
        {
            kind: 'function',
            parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('integer')) }],
            returnType: (0, types_1.p_type)('string'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'bload',
        {
            kind: 'function',
            parameters: [{ name: 'file', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'bload27',
        {
            kind: 'function',
            parameters: [{ name: 'file', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'bsave',
        {
            kind: 'function',
            parameters: [
                { name: 'obj', type: (0, types_1.p_type)('any') },
                { name: 'file', type: (0, types_1.p_type)('string') }
            ],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'call',
        {
            kind: 'function',
            parameters: [
                { name: 'name', type: (0, types_1.p_type)('any') },
                { name: 'args', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'car',
        {
            kind: 'function',
            parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_only'
        }
    ],
    [
        'cdr',
        {
            kind: 'function',
            parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_only'
        }
    ],
    [
        'ceil',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'characteristic_ff',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'clear_canvas',
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'index', type: (0, types_1.p_type)('integer') }
            ],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'close_file',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'coef',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'deg', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'deg', type: (0, types_1.p_type)('integer') },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'cola', // TODO: こういう形を変える関数（Juliaでいう「!」がつく関数）はどうすればよいのか
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'j', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('number') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'colm',
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('number') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'colx',
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'j', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'conj',
        {
            kind: 'function',
            parameters: [{ name: 'complex', type: (0, types_1.p_type)('complex') }],
            returnType: (0, types_1.p_type)('complex'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'conplot', // 今は二通りしか認めない // 2変数用
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'geometry', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'x', type: (0, types_1.p_type)('integer') },
                                    { name: 'y', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'xrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'yrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'zrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') },
                                    { name: 'step', type: (0, types_1.p_type)('number') } // step本来は指定しなくても良い
                                ]
                            } },
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'name', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'cons',
        {
            kind: 'function',
            parameters: [
                { name: 'obj', type: (0, types_1.p_type)('any') },
                { name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'cont',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                        { name: 'v', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'cputime',
        {
            kind: 'function',
            parameters: [{ name: 'switch', type: types_1.type_0_1 }],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ctrl',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    allowesOptions: new Map([['disc', (0, types_1.p_type)('integer')]]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'switch', type: (0, types_1.p_type)('string') }],
                    returnType: (0, types_1.p_type)('any'),
                    allowesOptions: new Map([['disc', (0, types_1.p_type)('integer')]]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'switch', type: (0, types_1.p_type)('string') },
                        { name: 'obj', type: (0, types_1.p_type)('any') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    allowesOptions: new Map([['disc', (0, types_1.p_type)('integer')]]),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'currenttime',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dabs',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat'), (0, types_1.p_type)('complex')]) }],
            returnType: (0, types_1.p_type)('number'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dacos',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dalgtoalg',
        {
            kind: 'function',
            parameters: [{ name: 'dalg', type: (0, types_1.p_type)('dalg') }],
            returnType: (0, types_1.p_type)('alg'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dalgtodp',
        {
            kind: 'function',
            parameters: [{ name: 'dalg', type: (0, types_1.p_type)('dalg') }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dasin',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'datan',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dceil',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dcos',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'defpoly',
        {
            kind: 'function',
            parameters: [{ name: 'alg', type: (0, types_1.p_type)('alg') }],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'deg',
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'var', type: (0, types_1.p_type)('pp') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'delete_history',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'index', type: (0, types_1.p_type)('integer') }],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'det',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'deval',
        {
            kind: 'function',
            parameters: [{ name: 'obj', type: (0, types_1.p_type)('any') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dexp',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dfloor',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'diff',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }],
                    restParameter: { name: 'vars', type: (0, types_1.p_type)('pp') },
                    returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) },
                        { name: 'varlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
                    ],
                    returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dlog',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dn',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.rat_type)((0, types_1.p_type)('any'))]) }],
            returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_dptodpm',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'pos', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_dtol',
        {
            kind: 'function',
            parameters: [
                { name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                { name: 'varlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_hc',
        {
            kind: 'function',
            parameters: [{ name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.u_type)([(0, types_1.dpoly_type)((0, types_1.p_type)('any')), (0, types_1.p_type)('number')]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_hm',
        {
            kind: 'function',
            parameters: [{ name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_hp',
        {
            kind: 'function',
            parameters: [{ name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_ht',
        {
            kind: 'function',
            parameters: [{ name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_ltod',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_nf',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpolyarray', type: (0, types_1.v_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) },
                        { name: 'fullreduse', type: types_1.type_0 }
                    ],
                    returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpolyarray', type: (0, types_1.v_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) },
                        { name: 'fullreduse', type: types_1.type_0 }
                    ],
                    returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_nf_and_quotient',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpolyarray', type: (0, types_1.v_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) }
                    ],
                    returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                        { name: 'dmpolyarray', type: (0, types_1.v_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) }
                    ],
                    returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_redble',
        {
            kind: 'function',
            parameters: [
                { name: 'dmpoly1', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) },
                { name: 'dmpoly2', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }
            ],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_rest',
        {
            kind: 'function',
            parameters: [{ name: 'dmpoly', type: (0, types_1.dpm_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpm_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_schreyer_base',
        {
            kind: 'function',
            parameters: [{ name: 'G', type: (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) }],
            returnType: (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_schreyer_frme',
        {
            kind: 'function',
            parameters: [{ name: 'G', type: (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) }],
            returnType: (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_set_schreyer_level',
        {
            kind: 'function',
            parameters: [{ name: 'L', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_sp',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.u_type)([(0, types_1.dpm_type)((0, types_1.p_type)('any')), (0, types_1.dpoly_type)((0, types_1.p_type)('any'))]) },
                { name: 'dpoly2', type: (0, types_1.u_type)([(0, types_1.dpm_type)((0, types_1.p_type)('any')), (0, types_1.dpoly_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.dpm_type)((0, types_1.p_type)('any')), (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['coef', (0, types_1.p_type)('integer')]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dpm_sp_nf',
        {
            kind: 'function',
            parameters: [
                { name: 'C', type: (0, types_1.v_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))) },
                { name: 'Z', type: (0, types_1.v_type)((0, types_1.p_type)('integer')) },
                { name: 'P', type: (0, types_1.p_type)('integer') },
                { name: 'Q', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.l_type)((0, types_1.dpm_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dptodalg',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.p_type)('dalg'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_dehomo',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_dtop',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_dtoe',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.v_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_f4_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_f4_mod_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) },
                { name: 'p', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_gr_flags', // TODO: flag補完
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_gr_f_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_gr_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'modular', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_gr_mod_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'modular', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_gr_print',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'i', type: types_1.type_0_1_2 }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_hc',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.u_type)([(0, types_1.dpoly_type)((0, types_1.p_type)('any')), (0, types_1.p_type)('number')]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_hm',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_homo',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_ht',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_lcm',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_mag',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_mbase', // usage: 多項式の集合のグレブナー基底を計算し、dpolyに変換してから使う
        {
            kind: 'function',
            parameters: [{ name: 'dplist', type: (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) }],
            returnType: (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('rational')) },
                { name: 'mod', type: (0, types_1.p_type)('integer') },
                { name: 'subst', type: (0, types_1.l_type)((0, types_1.p_type)('any')) } // [[var, value], ...] の形（varにvalueを代入）
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('fsmall')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_nf',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_nf_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_ord',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_prim',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('integer'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_ptod',
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_ptozp',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('integer'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_rat',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('fsmall')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('rational')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_red',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly3', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_redble',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_red_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly3', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_rest',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_set_top_weight',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.u_type)([(0, types_1.v_type)((0, types_1.p_type)('integer')), types_1.type_0]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'weight', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.p_type)('integer')), (0, types_1.v_type)((0, types_1.p_type)('integer'))]) }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_set_weight',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.u_type)([(0, types_1.v_type)((0, types_1.p_type)('integer')), types_1.type_0]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'weight', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.p_type)('integer')), (0, types_1.v_type)((0, types_1.p_type)('integer'))]) }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_sp',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_sp_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('fsmall')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('fsmall')) },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_subd',
        {
            kind: 'function',
            parameters: [
                { name: 'dpoly1', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly2', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_sugar',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_td',
        {
            kind: 'function',
            parameters: [{ name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_true_nf',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 }
            ],
            returnType: {
                kind: 'tuple',
                elements: [
                    { name: 'nm', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                    { name: 'dn', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
                ]
            },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_true_nf_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: {
                kind: 'tuple',
                elements: [
                    { name: 'nm', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                    { name: 'dn', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) }
                ]
            },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_vtoe',
        {
            kind: 'function',
            parameters: [{ name: 'vect', type: (0, types_1.v_type)((0, types_1.p_type)('integer')) }],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_f4_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_f4_mod_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) },
                { name: 'p', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_gr_f_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0 },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_gr_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0 },
                { name: 'modular', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_gr_mod_main',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0 },
                { name: 'modular', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_nf',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_nf_weyl_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'indexlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
                { name: 'dpoly', type: (0, types_1.dpoly_type)((0, types_1.p_type)('any')) },
                { name: 'dpolyarray', type: (0, types_1.v_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))) },
                { name: 'fullreduce', type: types_1.type_0_1 },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.dpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dp_weyl_set_weight',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.u_type)([(0, types_1.v_type)((0, types_1.p_type)('integer')), types_1.type_0]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'weight', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.p_type)('integer')), (0, types_1.v_type)((0, types_1.p_type)('integer'))]) }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'draw_obj',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'index', type: (0, types_1.p_type)('integer') },
                        { name: 'pointorsegment', type: (0, types_1.u_type)([
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') }
                                    ] },
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') },
                                        { name: 'u', type: (0, types_1.p_type)('integer') },
                                        { name: 'v', type: (0, types_1.p_type)('integer') }
                                    ] }
                            ]) }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'index', type: (0, types_1.p_type)('integer') },
                        { name: 'pointorsegment', type: (0, types_1.u_type)([
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') }
                                    ] },
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') },
                                        { name: 'u', type: (0, types_1.p_type)('integer') },
                                        { name: 'v', type: (0, types_1.p_type)('integer') }
                                    ] }
                            ]) },
                        { name: 'color', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'draw_string',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'index', type: (0, types_1.p_type)('integer') },
                        { name: 'pointorsegment', type: (0, types_1.u_type)([
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') }
                                    ] },
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') },
                                        { name: 'u', type: (0, types_1.p_type)('integer') },
                                        { name: 'v', type: (0, types_1.p_type)('integer') }
                                    ] }
                            ]) },
                        { name: 'string', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'index', type: (0, types_1.p_type)('integer') },
                        { name: 'pointorsegment', type: (0, types_1.u_type)([
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') }
                                    ] },
                                { kind: 'tuple', elements: [
                                        { name: 'x', type: (0, types_1.p_type)('integer') },
                                        { name: 'y', type: (0, types_1.p_type)('integer') },
                                        { name: 'u', type: (0, types_1.p_type)('integer') },
                                        { name: 'v', type: (0, types_1.p_type)('integer') }
                                    ] }
                            ]) },
                        { name: 'string', type: (0, types_1.p_type)('string') },
                        { name: 'color', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'drint',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dsin',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dsqrt',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat'), (0, types_1.p_type)('complex')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'dtan',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ecm_add_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.u_type)([{
                            kind: 'tuple',
                            elements: [
                                { name: 'x', type: (0, types_1.p_type)('rational') },
                                { name: 'y', type: (0, types_1.p_type)('rational') },
                                { name: 'z', type: (0, types_1.p_type)('rational') }
                            ]
                        }, types_1.type_0]) },
                { name: 'p2', type: (0, types_1.u_type)([{
                            kind: 'tuple',
                            elements: [
                                { name: 'x', type: (0, types_1.p_type)('rational') },
                                { name: 'y', type: (0, types_1.p_type)('rational') },
                                { name: 'z', type: (0, types_1.p_type)('rational') }
                            ]
                        }, types_1.type_0]) },
                { name: 'ec', type: {
                        kind: 'tuple',
                        elements: [
                            { name: 'a', type: (0, types_1.p_type)('flarge') },
                            { name: 'b', type: (0, types_1.p_type)('flarge') }
                        ]
                    } }
            ],
            returnType: {
                kind: 'tuple',
                elements: [
                    { name: 'x', type: (0, types_1.p_type)('flarge') },
                    { name: 'y', type: (0, types_1.p_type)('flarge') },
                    { name: 'z', type: (0, types_1.p_type)('flarge') }
                ]
            },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ecm_sub_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.u_type)([{
                            kind: 'tuple',
                            elements: [
                                { name: 'x', type: (0, types_1.p_type)('rational') },
                                { name: 'y', type: (0, types_1.p_type)('rational') },
                                { name: 'z', type: (0, types_1.p_type)('rational') }
                            ]
                        }, types_1.type_0]) },
                { name: 'p2', type: (0, types_1.u_type)([{
                            kind: 'tuple',
                            elements: [
                                { name: 'x', type: (0, types_1.p_type)('rational') },
                                { name: 'y', type: (0, types_1.p_type)('rational') },
                                { name: 'z', type: (0, types_1.p_type)('rational') }
                            ]
                        }, types_1.type_0]) },
                { name: 'ec', type: {
                        kind: 'tuple',
                        elements: [
                            { name: 'a', type: (0, types_1.p_type)('flarge') },
                            { name: 'b', type: (0, types_1.p_type)('flarge') }
                        ]
                    } }
            ],
            returnType: {
                kind: 'tuple',
                elements: [
                    { name: 'x', type: (0, types_1.p_type)('flarge') },
                    { name: 'y', type: (0, types_1.p_type)('flarge') },
                    { name: 'z', type: (0, types_1.p_type)('flarge') }
                ]
            },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ecm_chsgn_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.u_type)([{
                            kind: 'tuple',
                            elements: [
                                { name: 'x', type: (0, types_1.p_type)('rational') },
                                { name: 'y', type: (0, types_1.p_type)('rational') },
                                { name: 'z', type: (0, types_1.p_type)('rational') }
                            ]
                        }, types_1.type_0]) }
            ],
            returnType: {
                kind: 'tuple',
                elements: [
                    { name: 'x', type: (0, types_1.p_type)('flarge') },
                    { name: 'y', type: (0, types_1.p_type)('flarge') },
                    { name: 'z', type: (0, types_1.p_type)('flarge') }
                ]
            },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ediff',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }],
                    restParameter: { name: 'vars', type: (0, types_1.p_type)('pp') },
                    returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) },
                        { name: 'varlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
                    ],
                    returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'error',
        {
            kind: 'function',
            parameters: [{ name: 'message', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('undefined'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'eval',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'obj', type: (0, types_1.p_type)('any') }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'obj', type: (0, types_1.p_type)('any') },
                        { name: 'prec', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'eval_str',
        {
            kind: 'function',
            parameters: [{ name: 'str', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'extdeg_ff',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'fac',
        {
            kind: 'function',
            parameters: [{ name: 'i', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'fctr',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('any'))), // [[因子, 重複度],...] の形
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'field_order_ff',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'field_type_ff',
        {
            kind: 'function',
            parameters: [],
            returnType: types_1.type_0_1_2,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'flist',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'mname', type: (0, types_1.p_type)("string") }],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'floor',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'funargs',
        {
            kind: 'function',
            parameters: [{ name: 'func', type: (0, types_1.p_type)('form') }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')), // [any, arg1, arg2,...] の形
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'functor',
        {
            kind: 'function',
            parameters: [{ name: 'func', type: (0, types_1.p_type)('form') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'gcd',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'gcdz',
        {
            kind: 'function',
            parameters: [
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) },
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'generate_port',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'use_unix', type: types_1.type_0_1 }],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'getenv',
        {
            kind: 'function',
            parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('string'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'getopt',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('string'))),
                    behavior: 'callable_only'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'key', type: (0, types_1.p_type)('any') }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_only'
                }
            ],
            behavior: 'callable_only'
        }
    ],
    [
        'get_byte',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'get_line',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('string'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }],
                    returnType: (0, types_1.p_type)('string'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'get_rootdir',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('string'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'gf2nton',
        {
            kind: 'function',
            parameters: [{ name: 'm', type: (0, types_1.p_type)('fchar2') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'gf2ntop',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'm', type: (0, types_1.p_type)('fchar2') }],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'm', type: (0, types_1.p_type)('fchar2') },
                        { name: 'v', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'heap',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'help',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'iand',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'idiv',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ifplot', // 今は二通りしか認めない　// 2変数用
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'geometry', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'x', type: (0, types_1.p_type)('integer') },
                                    { name: 'y', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'xrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'yrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'name', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'igcd',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'igcdctrl',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'i', type: {
                                kind: 'literal_union',
                                values: [0, 1, 2, 3]
                            } }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ilcm',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'int32ton',
        {
            kind: 'function',
            parameters: [{ name: 'int32', type: (0, types_1.p_type)('usint') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'inttorat',
        {
            kind: 'function',
            parameters: [
                { name: 'a', type: (0, types_1.p_type)('integer') },
                { name: 'm', type: (0, types_1.p_type)('integer') },
                { name: 'b', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.u_type)([{
                    kind: 'tuple',
                    elements: [
                        { name: 'x', type: (0, types_1.p_type)('integer') },
                        { name: 'y', type: (0, types_1.p_type)('integer') } // xa=y (mod m)  s.t. x,|y| <b, gcd(x,y) = 1
                    ]
                }, types_1.type_0]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'inv',
        {
            kind: 'function',
            parameters: [
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'm', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'invmat',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) }],
                    returnType: {
                        kind: 'tuple',
                        elements: [
                            { name: 'nm', type: (0, types_1.m_type)((0, types_1.p_type)('any')) },
                            { name: 'dn', type: (0, types_1.p_type)('any') }
                        ]
                    },
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: {
                        kind: 'tuple',
                        elements: [
                            { name: 'nm', type: (0, types_1.m_type)((0, types_1.p_type)('any')) },
                            { name: 'dn', type: (0, types_1.p_type)('any') }
                        ]
                    },
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ior',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'irem',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ishift',
        {
            kind: 'function',
            parameters: [
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'count', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'isqrt',
        {
            kind: 'function',
            parameters: [
                { name: 'i', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ixor',
        {
            kind: 'function',
            parameters: [
                { name: 'i1', type: (0, types_1.p_type)('integer') },
                { name: 'i2', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'kmul', // gf2n係数の多項式のも使えるらしい。
        {
            kind: 'function',
            parameters: [
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ksquare', // gf2n係数の多項式のも使えるらしい。
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ktmul', // gf2n係数の多項式のも使えるらしい。
        {
            kind: 'function',
            parameters: [
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'length',
        {
            kind: 'function',
            parameters: [{ name: 'list|vect', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.v_type)((0, types_1.p_type)('any'))]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'lmptop',
        {
            kind: 'function',
            parameters: [{ name: 'm', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('flarge')) }], // fchar2もいけそう
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'load',
        {
            kind: 'function',
            parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'lprime',
        {
            kind: 'function',
            parameters: [{ name: 'index', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'lrandom',
        {
            kind: 'function',
            parameters: [{ name: 'bit', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ltov',
        {
            kind: 'function',
            parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'map',
        {
            kind: 'function',
            parameters: [
                { name: 'function', type: (0, types_1.p_type)('any') },
                { name: 'arg0', type: (0, types_1.p_type)('any') } // 実際にはlist,vector,matrixが望ましく、それ以外の場合はcallと同じ
            ],
            restParameter: { name: 'args', type: (0, types_1.p_type)('any') },
            returnType: (0, types_1.p_type)('any'), // arg0と同じ型
            behavior: 'callable_only'
        }
    ],
    [
        'mat',
        {
            kind: 'function',
            parameters: [{ name: 'rowvector', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
            restParameter: { name: 'vectors', type: (0, types_1.v_type)((0, types_1.p_type)('any')) },
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'matc',
        {
            kind: 'function',
            parameters: [{ name: 'columnvector', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
            restParameter: { name: 'vectors', type: (0, types_1.v_type)((0, types_1.p_type)('any')) },
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'matr',
        {
            kind: 'function',
            parameters: [{ name: 'rowvector', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
            restParameter: { name: 'vectors', type: (0, types_1.v_type)((0, types_1.p_type)('any')) },
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'matrix',
        {
            kind: 'function',
            parameters: [
                { name: 'row', type: (0, types_1.p_type)('integer') },
                { name: 'col', type: (0, types_1.p_type)('integer') }
            ],
            restParameter: { name: 'vectors', type: (0, types_1.v_type)((0, types_1.p_type)('any')) },
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'mindeg',
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'var', type: (0, types_1.p_type)('pp') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'modfctr',
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) },
                { name: 'mod', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('any'))), // [[因子, 重複度],...] の形
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'module_definedp',
        {
            kind: 'function',
            parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'module_list',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('string')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'mt_load',
        {
            kind: 'function',
            parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'mt_save',
        {
            kind: 'function',
            parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_det', // 有限体上のものらしい（引数も？）
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_f4', // plistは多項式のリストのリストが入力できるらしい。
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'modular', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['homo', types_1.type_1], ['dp', types_1.type_1], ['nora', types_1.type_1]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_f4_trace',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['dp', types_1.type_1], ['nora', types_1.type_1]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_gr',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['homo', types_1.type_1], ['dp', types_1.type_1], ['nora', types_1.type_1]]), // これ違うかも
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_gr_postproc',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) },
                { name: 'check', type: types_1.type_0_1 }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))), types_1.type_0]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_gr_trace',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['dp', types_1.type_1], ['nora', types_1.type_1]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_weyl_gr',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['dp', types_1.type_1], ['nora', types_1.type_1]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_weyl_gr_trace',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'homo', type: types_1.type_0_1 },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]),
            allowesOptions: new Map([['dp', types_1.type_1], ['nora', types_1.type_1]]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nd_weyl_gr_postproc',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any')))]) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'p', type: (0, types_1.p_type)('integer') },
                { name: 'order', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) },
                { name: 'check', type: types_1.type_0_1 }
            ],
            returnType: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('any'))), (0, types_1.l_type)((0, types_1.dpoly_type)((0, types_1.p_type)('any'))), types_1.type_0]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'newalg',
        {
            kind: 'function',
            parameters: [{ name: 'defpoly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.p_type)('alg'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'newbytearray',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'len', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.p_type)('bytearray'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'len', type: (0, types_1.p_type)('integer') },
                        { name: 'list_or_string', type: (0, types_1.u_type)([(0, types_1.l_type)((0, types_1.p_type)('integer')), (0, types_1.p_type)('string')]) }
                    ],
                    returnType: (0, types_1.p_type)('bytearray'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'newmat',
        {
            kind: 'function',
            parameters: [
                { name: 'row', type: (0, types_1.p_type)('integer') },
                { name: 'col', type: (0, types_1.p_type)('integer') }
            ],
            restParameter: { name: 'vectors', type: (0, types_1.l_type)((0, types_1.p_type)('any')) },
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'newstruct',
        {
            kind: 'function',
            parameters: [{ name: 'name', type: (0, types_1.p_type)('any') }],
            returnType: (0, types_1.p_type)('struct'),
            behavior: 'callable_only'
        }
    ],
    [
        'newvect',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'len', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'len', type: (0, types_1.p_type)('integer') },
                        { name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nm',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.rat_type)((0, types_1.p_type)('any'))]) }],
            returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'nmono',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ntogf2n',
        {
            kind: 'function',
            parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('fchar2'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ntoint32',
        {
            kind: 'function',
            parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('usint'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ntype',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.p_type)('number') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'open_canvas',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'geometry', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'x', type: (0, types_1.p_type)('integer') },
                                    { name: 'y', type: (0, types_1.p_type)('integer') }
                                ]
                            } }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'open_file',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'filename', type: (0, types_1.p_type)('string') },
                        { name: 'mode', type: (0, types_1.p_type)('string') } // "w", "a"など（fopenのモード）
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ord',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'varlist', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'output',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: types_1.type_1,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
                    returnType: types_1.type_1,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_cmo_rpc', // 関数によって変わる
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'func', type: (0, types_1.p_type)('string') }
            ],
            restParameter: { name: 'args', type: (0, types_1.p_type)('any') },
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_execute_string', // 何個も送れるの...？
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'command', type: (0, types_1.p_type)('string') }
            ],
            restParameter: { name: 'commands', type: (0, types_1.p_type)('any') },
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_flush',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_get', // 返り値はスタックされているものによる
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_get_serverinfo',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')), // mathcap がリストになったもの
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_intr',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_launch',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'host', type: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]) },
                        { name: 'command', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function', // ox_launch(0, "/usr/local/bin", "ox_asir") みたいな
                    parameters: [
                        { name: 'host', type: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]) },
                        { name: 'dir', type: (0, types_1.p_type)('string') },
                        { name: 'command', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_launch_generic',
        {
            kind: 'function',
            parameters: [
                { name: 'host', type: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]) },
                { name: 'launch', type: (0, types_1.p_type)('string') },
                { name: 'server', type: (0, types_1.p_type)('string') },
                { name: 'use_unix', type: types_1.type_0_1 },
                { name: 'use_ssh', type: types_1.type_0_1 },
                { name: 'use_x', type: types_1.type_0_1 },
                { name: 'conn_to_serv', type: types_1.type_0_1 },
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_launch_nox',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'host', type: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]) },
                        { name: 'command', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function', // ox_launch_nox(0, "/usr/local/bin", "ox_asir") みたいな
                    parameters: [
                        { name: 'host', type: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]) },
                        { name: 'dir', type: (0, types_1.p_type)('string') },
                        { name: 'command', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_pops',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'nitem', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_pop_cmo', // 返り値はスタックされているものによる
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_pop_local', // 返り値はスタックされているものによる
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_push_cmd',
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'command', type: (0, types_1.p_type)('integer') } // SMC
            ],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_push_cmo',
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'obj', type: (0, types_1.p_type)('any') }
            ],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_push_local',
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'obj', type: (0, types_1.p_type)('any') }
            ],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_reset',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_rpc', // 関数によって変わる
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'func', type: (0, types_1.p_type)('string') }
            ],
            restParameter: { name: 'args', type: (0, types_1.p_type)('any') },
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_select',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'nlist', type: (0, types_1.l_type)((0, types_1.p_type)('integer')) }],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'nlist', type: (0, types_1.l_type)((0, types_1.p_type)('integer')) },
                        { name: 'timeout', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('integer')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_shutdown',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ox_sync',
        {
            kind: 'function',
            parameters: [{ name: 'id', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'pari', // TODO: ox_pariを見れば分かるらしい
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.p_type)('any') },
                        { name: 'arg', type: (0, types_1.p_type)('any') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_only'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.p_type)('any') },
                        { name: 'arg', type: (0, types_1.p_type)('any') },
                        { name: 'prec', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.p_type)('any'),
                    behavior: 'callable_only'
                },
            ],
            behavior: 'callable_only'
        }
    ],
    [
        'plot', // 今は二通りしか認めない　// 1変数用
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'geometry', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'x', type: (0, types_1.p_type)('integer') },
                                    { name: 'y', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'xrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'name', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'plotover',
        {
            kind: 'function',
            parameters: [
                { name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, // 2変数多項式
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'number', type: (0, types_1.p_type)('integer') } // これ何？
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'polarplot', // 今は二通りしか認めない　// 極形式　f=r(θ)用
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'func', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'geometry', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'x', type: (0, types_1.p_type)('integer') },
                                    { name: 'y', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'θrange', type: {
                                kind: 'tuple',
                                elements: [
                                    { name: 'v', type: (0, types_1.p_type)('indeterminate') },
                                    { name: 'vmin', type: (0, types_1.p_type)('integer') },
                                    { name: 'vmax', type: (0, types_1.p_type)('integer') }
                                ]
                            } },
                        { name: 'id', type: (0, types_1.p_type)('integer') },
                        { name: 'name', type: (0, types_1.p_type)('string') }
                    ],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'prim',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                        { name: 'v', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'primadec',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('rational'))) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('rational'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'prime',
        {
            kind: 'function',
            parameters: [{ name: 'index', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'primedec',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('rational'))) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) }
            ],
            returnType: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('rational'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'primedec_mod',
        {
            kind: 'function',
            parameters: [
                { name: 'plist', type: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('rational'))) },
                { name: 'vlist', type: (0, types_1.l_type)((0, types_1.p_type)('pp')) },
                { name: 'ord', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.l_type)((0, types_1.p_type)('any')), (0, types_1.m_type)((0, types_1.p_type)('any'))]) },
                { name: 'mod', type: (0, types_1.p_type)('integer') },
                { name: 'strategy', type: types_1.type_0_1 }
            ],
            returnType: (0, types_1.l_type)((0, types_1.stdpoly_type)((0, types_1.p_type)('integer'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'print',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'obj', type: (0, types_1.p_type)('any') }],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'obj', type: (0, types_1.p_type)('any') },
                        { name: 'nl', type: types_1.type_0_1_2 }
                    ],
                    returnType: types_1.type_0,
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'psubst',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }], // リストや分散表現多項式もいけるらしい
            restParameter: { name: 'vars_and_rats', type: (0, types_1.u_type)([(0, types_1.p_type)('pp'), (0, types_1.rat_type)((0, types_1.p_type)('any'))]) }, // 本当は v1,r1,v2,r2,...の形
            returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ptogf2n',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('fchar2'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ptosfp',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) }], // 整数もとれる
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('fcharpsmall')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ptozp',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'put_byte',
        {
            kind: 'function',
            parameters: [
                { name: 'id', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('any') } // 何か分からない
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'qsort',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'array', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'array', type: (0, types_1.v_type)((0, types_1.p_type)('any')) },
                        { name: 'func', type: types_1.type_m1_0_1 } // どうする？
                    ],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'random',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'seed', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'random_ff',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('fcharpsmall'), // これ違うかも
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'red',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.rat_type)((0, types_1.p_type)('rational')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'register_handler',
        {
            kind: 'function',
            parameters: [{ name: 'func', type: (0, types_1.p_type)('any') }], // 0も可
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'register_server',
        {
            kind: 'function',
            parameters: [
                { name: 'control_socket', type: (0, types_1.p_type)('integer') },
                { name: 'control_port', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]) },
                { name: 'server_socket', type: (0, types_1.p_type)('integer') },
                { name: 'server_port', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]) }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'remove_file',
        {
            kind: 'function',
            parameters: [{ name: 'file', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'remove_module',
        {
            kind: 'function',
            parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'res',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'var', type: (0, types_1.p_type)('pp') },
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'var', type: (0, types_1.p_type)('pp') },
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'reverse',
        {
            kind: 'function',
            parameters: [{ name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'rint',
        {
            kind: 'function',
            parameters: [{ name: 'num', type: (0, types_1.u_type)([(0, types_1.p_type)('rational'), (0, types_1.p_type)('float'), (0, types_1.p_type)('bigfloat')]) }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'rowa', // TODO: こういう形を変える関数（Juliaでいう「!」がつく関数）はどうすればよいのか
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'j', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('number') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'rowm',
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('number') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'rowx',
        {
            kind: 'function',
            parameters: [
                { name: 'matrix', type: (0, types_1.m_type)((0, types_1.p_type)('number')) },
                { name: 'i', type: (0, types_1.p_type)('integer') },
                { name: 'j', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('number')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'rtostr',
        {
            kind: 'function',
            parameters: [{ name: 'obj', type: (0, types_1.p_type)('any') }],
            returnType: (0, types_1.p_type)('string'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sdiv',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sdivm',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'setbprec',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'setmod',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'p', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'setmod_ff',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'p', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'defpoly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) }],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'defpoly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) },
                        { name: 'p', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'p', type: (0, types_1.p_type)('integer') },
                        { name: 'n', type: (0, types_1.p_type)('integer') }
                    ],
                    returnType: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]),
                    behavior: 'callable_and_symbol'
                },
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'setprec',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'setround',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [],
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }], // 0,1,2,3
                    returnType: (0, types_1.p_type)('integer'),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'set_field',
        {
            kind: 'function',
            parameters: [{ name: 'rootlist', type: (0, types_1.l_type)((0, types_1.p_type)('alg')) }],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'set_upfft',
        {
            kind: 'function',
            parameters: [{ name: 'threshold', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'set_upkara',
        {
            kind: 'function',
            parameters: [{ name: 'threshold', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'set_uptkara',
        {
            kind: 'function',
            parameters: [{ name: 'threshold', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sffctr',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.l_type)({ kind: 'tuple', elements: [{ name: 'monic', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('fcharpsmall')) }, { name: 'multiplicity', type: (0, types_1.p_type)('integer') }] }),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sfptop',
        {
            kind: 'function',
            parameters: [{ name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('fcharpsmall')) }],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'shell',
        {
            kind: 'function',
            parameters: [{ name: 'command', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'simp_ff',
        {
            kind: 'function',
            parameters: [{ name: 'obj', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('integer')) }],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('flarge')), // setmod_ff によって違う
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'size',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) }],
                    returnType: { kind: 'tuple', elements: [{ name: 'row', type: (0, types_1.p_type)('integer') }, { name: 'col', type: (0, types_1.p_type)('integer') }] },
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [{ name: 'vect', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
                    returnType: { kind: 'tuple', elements: [{ name: 'length', type: (0, types_1.p_type)('integer') }] },
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sleep',
        {
            kind: 'function',
            parameters: [{ name: 'interval', type: (0, types_1.p_type)('integer') }],
            returnType: types_1.type_1,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sqfr',
        {
            kind: 'function',
            parameters: [{ name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) }],
            returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('any'))), // [[因子, 重複度],...] の形
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sqr',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: { kind: 'tuple', elements: [{ name: 'quotient', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, { name: 'remainder', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }] },
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: { kind: 'tuple', elements: [{ name: 'quotient', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, { name: 'remainder', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }] },
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sqrm',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                    ],
                    returnType: { kind: 'tuple', elements: [{ name: 'quotient', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, { name: 'remainder', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }] },
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: { kind: 'tuple', elements: [{ name: 'quotient', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, { name: 'remainder', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }] },
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'srem',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sremm',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                        { name: 'mod', type: (0, types_1.p_type)('integer') },
                        { name: 'var', type: (0, types_1.p_type)('pp') }
                    ],
                    returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'strtoascii',
        {
            kind: 'function',
            parameters: [{ name: 'str', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'strtov',
        {
            kind: 'function',
            parameters: [{ name: 'str', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('indeterminate'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'struct_type',
        {
            kind: 'function',
            parameters: [{ name: 'name', type: (0, types_1.p_type)('string') }], // 実はstruct型もできるが一旦保留
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'str_chr',
        {
            kind: 'function',
            parameters: [
                { name: 'str', type: (0, types_1.p_type)('string') },
                { name: 'start', type: (0, types_1.p_type)('integer') },
                { name: 'c', type: (0, types_1.p_type)('string') }
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'str_len',
        {
            kind: 'function',
            parameters: [{ name: 'str', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'subst',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }], // リストや分散表現多項式もいけるらしい
            restParameter: { name: 'vars_and_rats', type: (0, types_1.u_type)([(0, types_1.p_type)('pp'), (0, types_1.rat_type)((0, types_1.p_type)('any'))]) }, // 本当は v1,r1,v2,r2,...の形
            returnType: (0, types_1.rat_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'sub_str',
        {
            kind: 'function',
            parameters: [
                { name: 'str', type: (0, types_1.p_type)('string') },
                { name: 'start', type: (0, types_1.p_type)('integer') },
                { name: 'end', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('string'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'tdiv',
        {
            kind: 'function',
            parameters: [
                { name: 'poly1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'poly2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'time',
        {
            kind: 'function',
            parameters: [],
            returnType: { kind: 'tuple', elements: [
                    { name: 'CPU_time', type: (0, types_1.p_type)('float') },
                    { name: 'GC_time', type: (0, types_1.p_type)('float') },
                    { name: 'Memory', type: (0, types_1.p_type)('float') },
                    { name: 'Elapsed_time', type: (0, types_1.p_type)('float') }
                ] },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'timer', // ほぼcall、時間が足りなければvalが返る
        {
            kind: 'function',
            parameters: [
                { name: 'interval', type: (0, types_1.p_type)('integer') },
                { name: 'expr', type: (0, types_1.p_type)('any') },
                { name: 'val', type: (0, types_1.p_type)('any') }
            ],
            returnType: (0, types_1.p_type)('any'),
            behavior: 'callable_only'
        }
    ],
    [
        'try_accept',
        {
            kind: 'function',
            parameters: [
                { name: 'socket', type: (0, types_1.p_type)('integer') },
                { name: 'port', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]) },
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'try_bind_listen',
        {
            kind: 'function',
            parameters: [
                { name: 'port', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]) },
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'try_connect',
        {
            kind: 'function',
            parameters: [
                { name: 'host', type: (0, types_1.p_type)('string') },
                { name: 'port', type: (0, types_1.u_type)([(0, types_1.p_type)('integer'), (0, types_1.p_type)('string')]) },
            ],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'tstart',
        {
            kind: 'function',
            parameters: [],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'tstop',
        {
            kind: 'function',
            parameters: [],
            returnType: types_1.type_0,
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'type',
        {
            kind: 'function',
            parameters: [{ name: 'obj', type: (0, types_1.p_type)('any') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'uc',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('uc'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'udecomp',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: { kind: 'tuple', elements: [{ name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }, { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }] },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'udiv',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ufctrhint',
        {
            kind: 'function',
            parameters: [
                { name: 'poly', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('rational')) },
                { name: 'hint', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('any'))), // [[因子, 重複度],...] の形
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ugcd',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'uinv_as_power_series',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'umul',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'umul_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'urem',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'urembymul',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'urembymul_precomp',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'inv', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ureverse',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'ureverse_inv_as_power_series',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'usquare',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'usquare_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'utmul',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'utmul_ff',
        {
            kind: 'function',
            parameters: [
                { name: 'p1', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'p2', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'utrunc',
        {
            kind: 'function',
            parameters: [
                { name: 'p', type: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')) },
                { name: 'd', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.stdpoly_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'var',
        {
            kind: 'function',
            parameters: [{ name: 'rat', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.p_type)('pp'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'vars',
        {
            kind: 'function',
            parameters: [{ name: 'obj', type: (0, types_1.rat_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('pp')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'vect',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
            restParameter: { name: 'elements', type: (0, types_1.p_type)('any') },
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'vector',
        {
            kind: 'overloaded_function',
            signatures: [
                {
                    kind: 'function',
                    parameters: [{ name: 'len', type: (0, types_1.p_type)('integer') }],
                    returnType: (0, types_1.v_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                },
                {
                    kind: 'function',
                    parameters: [
                        { name: 'len', type: (0, types_1.p_type)('integer') },
                        { name: 'list', type: (0, types_1.l_type)((0, types_1.p_type)('any')) }
                    ],
                    returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
                    behavior: 'callable_and_symbol'
                }
            ],
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'version',
        {
            kind: 'function',
            parameters: [],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'vtol',
        {
            kind: 'function',
            parameters: [{ name: 'vect', type: (0, types_1.v_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.l_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'vtype',
        {
            kind: 'function',
            parameters: [{ name: 'var', type: (0, types_1.p_type)('pp') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        'which',
        {
            kind: 'function',
            parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
            returnType: (0, types_1.u_type)([(0, types_1.p_type)('string'), types_1.type_0]),
            behavior: 'callable_and_symbol'
        }
    ],
    // 実験的な関数
    [
        'chdir',
        {
            kind: 'function',
            parameters: [{ name: 'directory', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_m1_0_1,
            behavior: 'callable_and_symbol'
        }
    ],
    // その他
    [
        'import',
        {
            kind: 'function',
            parameters: [{ name: 'filename', type: (0, types_1.p_type)('string') }],
            returnType: types_1.type_0_1,
            behavior: 'callable_and_symbol'
        }
    ]
]);
//# sourceMappingURL=builtinSignatures.js.map

/***/ }),

/***/ "../pasirser/dist/data/builtins.js":
/*!*****************************************!*\
  !*** ../pasirser/dist/data/builtins.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ALL_ASIR_BUILTIN = exports.ASIR_KEYWORDS = exports.functionNames = void 0;
const builtinSignatures_1 = __webpack_require__(/*! ./builtinSignatures */ "../pasirser/dist/data/builtinSignatures.js");
exports.functionNames = Array.from(builtinSignatures_1.BUILTIN_SIGNATURES.keys());
exports.ASIR_KEYWORDS = [
    'if', 'while', 'for', 'return', 'break', 'continue', 'static', 'struct', 'do', 'else', 'extern',
    'def', 'endmodule', 'function', 'global', 'local', 'localf', 'module',
    'end', 'quit', 'debug'
];
exports.ALL_ASIR_BUILTIN = [
    // --- なぜかflistにない関数 ---
    'quote', 'pari', 'recmap', 'timer', 'newstruct', 'getopt',
    'sin', 'cos', 'tan', 'sinh', 'cosh', 'tanh', 'log', 'exp', 'factorial',
    // --- flistにある関数 ---
    'comp_f', 'div_minf', 'div_pinf', 'mul_minf', 'mul_pinf', 'sub_minf', 'sub_pinf', 'add_minf', 'add_pinf', 'hugo',
    'nnf', 'subf', 'atnum', 'qe', 'qevar', 'atl', 'compf', 'fopargs', 'fargs', 'fop', 'all', 'ex', 'simpl', 'sha1',
    'ecm_set_addcounter', 'ecm_find_match', 'separate_vect', 'sort_ktarray', 'nextvect1', 'ecm_count_order',
    'ecm_compute_all_key_homo_ff', 'ecm_sub_ff', 'ecm_chsgn_ff', 'ecm_add_ff', 'draw_string', 'draw_obj', 'clear_canvas',
    'open_canvas', 'drawcircle', 'memory_plot', 'memory_conplot', 'memory_ifplot', 'plotoverB', 'plotoverQ', 'plotoverD',
    'plotover', 'conplotQ', 'conplotB', 'conplotD', 'conplot', 'ineqnBxor', 'ineqnQxor', 'ineqnDxor', 'ineqnxor', 'ineqnBor',
    'ineqnQor', 'ineqnDor', 'ineqnor', 'ineqnBand', 'ineqnQand', 'ineqnDand', 'ineqnand', 'ineqnB', 'ineqnQ', 'ineqnD',
    'ineqn', 'ifplotB', 'ifplotQ', 'ifplotD', 'ifplot', 'polarplotD', 'polarplot', 'obj_cp', 'plot', 'ox_execute_function',
    'ox_execute_string', 'ox_evalname', 'ox_setname', 'ox_push_cmd', 'ox_push_cmo', 'ox_push_local', 'ox_push_vl',
    'ox_pops', 'ox_get', 'ox_pop0_cmo', 'ox_pop_cmo', 'ox_pop0_local', 'ox_pop_local', 'ox_pop0_string', 'ox_pop_string',
    'ox_select', 'ox_intr', 'ox_reset', 'ox_sync', 'ox_cmo_rpc', 'ox_rpc', 'ox_shutdown', 'ox_launch_generic',
    'ox_launch_nox', 'ox_launch', 'ox_flush', 'register_server', 'try_accept', 'try_connect', 'try_bind_listen',
    'ox_reduce_102', 'ox_bcast_102', 'ox_recv_102', 'ox_send_102', 'ox_get_rank_102', 'ox_reset_102', 'ox_tcp_connect_102',
    'ox_tcp_accept_102', 'ox_set_rank_102', 'generate_port', 'ox_get_serverinfo', 'ox_recv_raw_cmo', 'ox_send_raw_cmo',
    'cola', 'colx', 'colm', 'rowa', 'rowx', 'rowm', 'mfund', 'disnan', 'drint', 'rint', 'dceil', 'ceil', 'dfloor', 'floor',
    'datan', 'dacos', 'dasin', 'dexp', 'dlog', 'dtan', 'dcos', 'dsin', 'dabs', 'dsqrt', 'im2m', 'm2im', 'newimat', 'sfuhensel',
    'uhensel_incremental', 'uhensel', 'pwr_mod', 'resfmain', 'ftest', 'nullspace_ff', 'nullspace',
    'solve_linear_equation_gf2n', 'range', 'get_struct_name', 'get_element_names', 'put_element_at', 'get_element_at',
    'struct_type', 'arfreg', 'simple_is_eq', 'delete_uc', 'uc', 'vars_recursive', 'vars', 'var', 'readarray', 'ntype', 'type',
    'tstop', 'tstart', 'dcurrenttime', 'currenttime', 'cputime', 'time', 'substf', 'psubst', 'subst_quote', 'substr2np',
    'subst', 'get_function_name', 'funargs_to_quote', 'quote_to_funargs', 'flatten_quote', 'quotetotex_env', 'quotetotex',
    'quotetotex_tb', 'qt_to_bin', 'qt_to_nary', 'nbm_trest', 'nbm_rest', 'nbm_tv', 'nbm_hv', 'nbm_hp_rest', 'nbm_xky_rest',
    'nbm_hxky', 'nbm_index', 'nbm_deg', 'nbp_trest', 'nbp_tc', 'nbp_tt', 'nbp_tm', 'nbp_rest', 'nbp_hc', 'nbp_ht', 'nbp_hm',
    'harmonic_mul', 'shuffle_mul', 'qt_to_nbp', 'nqt_match', 'nqt_comp', 'nqt_weight', 'nqt_match_rewrite', 'qt_match',
    'qt_normalize', 'qt_set_weight', 'qt_set_ord', 'qt_set_coef', 'qt_is_dependent', 'qt_is_function', 'qt_is_integer',
    'qt_is_rational', 'qt_is_number', 'qt_is_coef', 'qt_is_var', 'get_quote_id', 'string_to_tb', 'tb_to_string', 'clear_tb',
    'write_to_tb', 'sub_str', 'str_chr', 'str_len', 'asciitostr', 'strtoascii', 'eval_str', 'strtov', 'rtostr', 'sprintf',
    'srcr', 'nd_res', 'res', 'prim', 'redc', 'red', 'laurent_to_rat', 'rdiff', 'ediff', 'diff', 'dn', 'nm', 'eval_quote',
    'deval', 'vtype', 'call', 'clear_handler', 'list_handler', 'add_handler', 'register_handler', 'funargs_ext', 'funargs',
    'args', 'functor', 'map', 'mapat', 'set_print_function', 'eval_variables_in_quote', 'quotetolist', 'objtoquote', 'print',
    'printf', 'get_next_fft_prime', 'rinvtest_gf2n', 'invtest_gf2n', 'bininv_gf2n', 'squaretest_gf2n', 'multest_gf2n',
    'hfmul_lm', 'fmultest', 'ksquareum', 'kmulum', 'kpwrtab_lm', 'kgeneric_pwrmod_lm', 'kpwrmod_lm', 'is_irred_ddd_gf2',
    'is_irred_gf2', 'b_find_root_gf2n', 'tracemod_gf2n', 'pwrtab_ff', 'generic_pwrmod_ff', 'pwrmod_ff', 'lazy_ff',
    'lazy_lm', 'urembymul_precomp', 'urembymul', 'ureverse', 'udecomp', 'utrunc', 'decomp', 'trunc', 'utmul_ff', 'usquare_ff',
    'umul_ff', 'utmul', 'utmul_specialmod', 'usquare_specialmod', 'umul_specialmod', 'uinv_as_power_series',
    'ureverse_inv_as_power_series', 'usquare', 'umul', 'ktmul', 'ksquare', 'kmul', 'gfpntop', 'ptogfpn', 'gf2ntovect',
    'gf2ntop', 'ptogf2n', 'sfptopsfp', 'sfptop', 'ptosfp', 'sf_log', 'sf_embed', 'sf_minipoly', 'sf_find_root',
    'sf_galois_action', 'lmptop', 'ptolmp', 'mptop', 'ptomp', 're_mv', 'ch_mv', 'mergelist', 'deglist', 'random_ff',
    'field_order_ff', 'field_type_ff', 'characteristic_ff', 'extdeg_ff', 'simp_ff', 'setmod_ff', 'sparsemod_gf2n', 'setmod',
    'mindeg', 'deg', 'coef_gf2n', 'coef', 'coef0', 'delete_vars', 'remove_vars', 'ord', 'maxblen', 'p_mag', 'ranp', 'uadj_coef',
    'reorder', 'homogeneous_part', 'homogeneous_deg', 'mul_trunc', 'quo_trunc', 'headsgn', 'urem', 'ugcd', 'srem_mod',
    'inva_mod', 'sqrm', 'sremm', 'sdivm', 'udiv', 'tdiv', 'sqr', 'gcd_gf2n', 'srem_gf2n', 'sdiv_gf2n', 'prem', 'srem', 'sdiv',
    'poke', 'peek', 'hex_dump', 'get_addr', 'send_progress', 'batch', 'gc', 'pause', 'delete_history', 'flist', 'nez', 'error3',
    'error', 'toplevel', 'nmono', 'copyright', 'version', 'heap', 'shell', 'debug', 'quit', 'end', 'getenv', 'null_command',
    'sleep', 'module_definedp', 'remove_module', 'module_list', 'set_secure_flag', 'set_secure_mode', 'chdir', 'pwd', 'cadr',
    'cddr', 'assoc', 'list', 'replca', 'replcd', 'nconc', 'length', 'reverse', 'append', 'cons', 'cdr', 'car', 'int32ton',
    'ntoint32', 'mt_load', 'mt_save', 'igcdcntl', 'igcdacc', 'igcdeuc', 'igcdbmod', 'igcdbin', 'small_jacobi', 'ishift',
    'ixor', 'ior', 'iand', 'lrandom', 'random', 'lprime', 'prime', 'fac', 'inttorat', 'inv', 'set_upfft', 'set_up2kara',
    'set_uptkara', 'set_upkara', 'ntogf2n', 'gf2nton', 'type_t_NB', 'up2_show_eg', 'up2_init_eg', 'up2_inv', 'ibin', 'ilcm',
    'igcd', 'iqr', 'irem', 'idiv', 'isqrt', 'dp_set_mpi', 'help', 'getpid', 'bload_cmo', 'bsave_cmo', 'get_rootdir', 'bload',
    'bsave', 'output', 'loadfiles', 'which', 'import', 'load', 'access', 'remove_file', 'get_line', 'put_word', 'get_word',
    'put_byte', 'get_byte', 'close_file', 'open_file', 'purge_stdin', 'fprintf', 'nfctr_mod', 'irred_check', 'ddd_tab',
    'sfgcd', 'sfmintdeg', 'sfbfctr', 'sfufctr', 'sffctr', 'sfsqfr', 'modfctr', 'modsqfr', 'agcd', 'afctr', 'sfcont', 'cont',
    'ptozp', 'ufctrhint', 'sqfr', 'lcm', 'gcdz', 'gcd', 'fctr', 'bivariate_hensel_special', 'sumi_symbolic',
    'sumi_updatepairs', 'dp_rref2', 'dpm_simplify_syz', 'dpm_insert_to_zlist', 'dpm_sp_nf', 'dpm_list_to_array',
    'dpm_schreyer_base', 'dp_mono_reduce', 'dp_mono_raddec', 'dp_compute_essential_df', 'dp_compute_last_t',
    'dp_compute_last_w_02', 'dp_compute_last_w', 'dp_minp', 'dp_tdiv', 'dp_idiv', 'dp_sep', 'dpm_redble', 'dp_redble',
    'dp_mbase', 'dpm_td', 'dp_set_sugar', 'dp_sugar', 'dp_mag', 'dp_td', 'dp_symb_add', 'dp_order', 'dp_initial_term',
    'dp_rest', 'dpm_sort', 'dpm_extract', 'dpm_split', 'dpm_shift', 'dpm_rest', 'dpm_hp', 'dpm_hc', 'dpm_ht', 'dpm_hm',
    'dpv_hc', 'dpv_ht', 'dpv_hm', 'dp_hc', 'dp_ht', 'dp_hm', 'dp_lcm', 'dp_subd', 'dp_criB', 'dp_cri2', 'dp_cri1', 'dpm_mod',
    'dpm_dehomo', 'dpm_homo', 'dpm_dtol', 'dpm_dptodpm', 'dpm_ltod', 'dp_ltod', 'dp_rat', 'dp_mod', 'dp_mdtod', 'dp_dtov',
    'dp_vtoe', 'dp_etov', 'dp_dehomo', 'dp_homo', 'dp_dtop', 'dp_ptod', 'homogenize', 'dp_gr_print', 'dp_gr_flags', 'dp_nelim',
    'dp_set_kara', 'dpv_ord', 'dpm_schreyer_frame', 'dpm_set_schreyer_level', 'dpm_set_schreyer', 'dp_ord', 'dp_sort',
    'dp_get_denomlist', 'dp_weyl_set_weight', 'dp_set_top_weight', 'dp_set_module_weight', 'dp_set_weight',
    'dp_inv_or_split', 'dp_monomial_hilbert_poincare_incremental', 'dp_monomial_hilbert_poincare', 'dp_symb_preproc',
    'dp_weyl_f4_mod_main', 'dp_weyl_f4_main', 'dp_weyl_gr_f_main', 'dp_weyl_gr_mod_main', 'dp_weyl_gr_main',
    'dp_weyl_true_nf_and_quotient_marked_mod', 'dp_weyl_true_nf_and_quotient_marked', 'dp_weyl_true_nf_and_quotient_mod',
    'dp_weyl_true_nf_and_quotient', 'dp_weyl_nf_f', 'dp_weyl_nf_mod', 'dpm_weyl_nf', 'dp_weyl_nf', 'dp_weyl_red',
    'dp_weyl_sp', 'dp_weyl_act', 'dp_weyl_mul_mod', 'dp_weyl_mul', 'dp_f4_mod_main', 'dp_f4_main', 'nd_weyl_nf',
    'nd_nf', 'nd_weyl_gr_trace', 'nd_weyl_gr', 'nd_weyl_gr_postproc', 'nd_btog', 'nd_gr_recompute_trace', 'nd_gr_postproc',
    'nd_f4_trace', 'nd_gr_trace', 'nd_weyl_sba', 'nd_sba', 'nd_gr', 'nd_f4', 'dp_gr_checklist', 'dp_gr_f_main',
    'dp_gr_mod_main', 'dp_interreduce', 'dp_gr_main', 'dp_lnf_f', 'dp_nf_tab_mod', 'dp_nf_tab_f', 'dp_lnf_mod',
    'dp_true_nf_and_quotient_marked_mod', 'dp_true_nf_and_quotient_marked', 'dp_true_nf_and_quotient_mod',
    'dp_true_nf_and_quotient', 'dp_true_lnf_mod', 'dp_true_lnf', 'dp_true_nf_marked_mod', 'dp_true_nf_marked_check_mod',
    'dp_true_nf_marked_check', 'dp_true_nf_marked', 'dp_true_nf_mod', 'dp_true_nf', 'dpm_weyl_sp', 'dpm_sp', 'dpm_nf',
    'dpm_weyl_nf_f', 'dpm_nf_f', 'dpm_nf_and_quotient2', 'dpm_nf_and_quotient', 'dp_nf_f', 'dp_nf_mod', 'dp_nf',
    'dp_red_mod', 'dp_red', 'dp_sp_mod', 'dp_sp', 'dp_quo', 'dp_mul_trunc', 'dpm_pos', 'dpm_prim', 'dpm_remove_cont',
    'dpm_ptozp', 'dp_cont', 'dp_red_coef', 'dp_prim', 'dp_ptozp2', 'dp_ptozp', 'sysinfo', 'asir_env', 'ctrl', 'imag', 'real',
    'conj', 'triangleq', 'lusolve_main', 'lusolve_prep', 'mat_col', 'mat_swap_col_destructive', 'mat_swap_row_destructive',
    'nbpoly_up2', 'irredpoly_up2', 'x962_irredpoly_up2', 'nbmul_gf2n', 'mul_mat_vect_int', 'mul_vect_mat_gf2n',
    'bconvmat_gf2n', 'mulmat_gf2n', 'sremainder', 'remainder', 'geninv_sf_swap', 'geninvm_swap', 'geninvm', 'leqm1',
    'leqm', 'invmat', 'nd_det', 'det', 'size', 'ltov', 'vtol', 'qsort', 'sepvect', 'sepmat_destructive', 'memoryplot_to_coord',
    'newbytearray', 'matc', 'matr', 'mat', 'matrix', 'newmat', 'exponent_vector', 'vector', 'vect', 'newvect',
    'indep_rows_mod', 'generic_gauss_elim_mod', 'generic_gauss_elim', 'mat_to_gfmmat', 'lu_gfmmat', 'solve_by_lu_gfmmat',
    'algv', 'alg', 'getalgtree', 'getalg', 'rattoalg', 'algtorat', 'mainalg', 'newalg', 'defpoly', 'invalg_le',
    'invalg_chrem', 'inv_or_split_dalg', 'dptodalg', 'dalgtoup', 'dalgtodp', 'dalgtoalg', 'algtodalg',
    'get_field_generator', 'get_field_defpoly', 'set_field', 'rk_ratmat', 'mpfr_round', 'mpfr_ceil', 'mpfr_floor',
    'mpfr_digamma', 'mpfr_lngamma', 'mpfr_gamma', 'mpfr_li2', 'mpfr_erfc', 'mpfr_erf', 'mpfr_eint', 'mpfr_y1', 'mpfr_y0',
    'mpfr_j1', 'mpfr_j0', 'mpfr_zeta', 'mpfr_ai', 'mpfr_pow', 'mpfr_log', 'mpfr_exp', 'mpfr_atanh', 'mpfr_acosh',
    'mpfr_asinh', 'mpfr_tanh', 'mpfr_cosh', 'mpfr_sinh', 'mpfr_atan', 'mpfr_acos', 'mpfr_asin', 'mpfr_tan', 'mpfr_cos',
    'mpfr_sin', 'todouble', 'setround', 'setbprec', 'setprec', 'eval'
];
//# sourceMappingURL=builtins.js.map

/***/ }),

/***/ "../pasirser/dist/data/pariSignatures.js":
/*!***********************************************!*\
  !*** ../pasirser/dist/data/pariSignatures.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PARI_SIGNATURES = void 0;
const types_1 = __webpack_require__(/*! ../semantics/types */ "../pasirser/dist/semantics/types.js");
// pari() で呼び出される関数のシグネチャ
exports.PARI_SIGNATURES = new Map([
    [
        "sqrt",
        {
            kind: 'function',
            parameters: [{ name: 'x', type: (0, types_1.p_type)('number') }],
            returnType: (0, types_1.u_type)([(0, types_1.p_type)('bigfloat'), (0, types_1.p_type)('complex')]),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "abs",
        {
            kind: 'function',
            parameters: [{ name: 'x', type: (0, types_1.p_type)('number') }],
            returnType: (0, types_1.p_type)('number'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "erfc",
        {
            kind: 'function',
            parameters: [{ name: 'x', type: (0, types_1.p_type)('number') }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "arg",
        {
            kind: 'function',
            parameters: [{ name: 'z', type: (0, types_1.p_type)('complex') }],
            returnType: (0, types_1.p_type)('float'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "isqrt",
        {
            kind: 'function',
            parameters: [{ name: 'n', type: (0, types_1.p_type)('integer') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "factor",
        {
            kind: 'function',
            parameters: [{ name: 'n', type: (0, types_1.u_type)([(0, types_1.p_type)('number'), (0, types_1.stdpoly_type)((0, types_1.p_type)('any'))]) }],
            returnType: (0, types_1.l_type)((0, types_1.l_type)((0, types_1.p_type)('any'))),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "adj",
        {
            kind: 'function',
            parameters: [{ name: 'mat', type: (0, types_1.m_type)((0, types_1.p_type)('any')) }],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('any')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "factorint",
        {
            kind: 'function',
            parameters: [
                { name: 'n', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.m_type)((0, types_1.p_type)('integer')),
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "isprime",
        {
            kind: 'function',
            parameters: [
                { name: 'n', type: (0, types_1.p_type)('integer') },
                { name: 'flag', type: (0, types_1.p_type)('integer') }
            ],
            returnType: (0, types_1.p_type)('integer'), // 0 or 1
            behavior: 'callable_and_symbol'
        }
    ],
    [
        "bigomega",
        {
            kind: 'function',
            parameters: [{ name: 'n', type: (0, types_1.p_type)('any') }],
            returnType: (0, types_1.p_type)('integer'),
            behavior: 'callable_and_symbol'
        }
    ],
]);
//# sourceMappingURL=pariSignatures.js.map

/***/ }),

/***/ "../pasirser/dist/features/completionProvider.js":
/*!*******************************************************!*\
  !*** ../pasirser/dist/features/completionProvider.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertTextFormat = exports.CompletionItemKind = void 0;
exports.getCompletions = getCompletions;
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const builtins_1 = __webpack_require__(/*! ../data/builtins */ "../pasirser/dist/data/builtins.js");
const builtinConstants_1 = __webpack_require__(/*! ../data/builtinConstants */ "../pasirser/dist/data/builtinConstants.js");
const builtinSignatures_1 = __webpack_require__(/*! ../data/builtinSignatures */ "../pasirser/dist/data/builtinSignatures.js");
const ctrl_handlers_1 = __webpack_require__(/*! ../semantics/builtins/ctrl_handlers */ "../pasirser/dist/semantics/builtins/ctrl_handlers.js");
const pariSignatures_1 = __webpack_require__(/*! ../data/pariSignatures */ "../pasirser/dist/data/pariSignatures.js");
const astUtils_1 = __webpack_require__(/*! ./utils/astUtils */ "../pasirser/dist/features/utils/astUtils.js");
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 1] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 2] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 3] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 4] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 5] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 6] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 7] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 8] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 9] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 10] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 11] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 12] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 13] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 14] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 15] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 16] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 17] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 18] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 19] = "Folder";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 20] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Constant"] = 21] = "Constant";
    CompletionItemKind[CompletionItemKind["Struct"] = 22] = "Struct";
    CompletionItemKind[CompletionItemKind["Event"] = 23] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 24] = "Operator";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 25] = "TypeParameter";
})(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
// LSPのInsertTextFormatを模倣
var InsertTextFormat;
(function (InsertTextFormat) {
    InsertTextFormat[InsertTextFormat["PlainText"] = 1] = "PlainText";
    InsertTextFormat[InsertTextFormat["Snippet"] = 2] = "Snippet";
})(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));
let cachedSnippets = null;
function loadSnippets() {
    if (cachedSnippets) {
        return cachedSnippets;
    }
    const snippetFilePath = path.join(__dirname, '../snippets/rr.json');
    try {
        const snippetContent = fs.readFileSync(snippetFilePath, 'utf-8');
        cachedSnippets = JSON.parse(snippetContent);
        return cachedSnippets;
    }
    catch (error) {
        console.error(`Failed to load snippets from ${snippetFilePath}:`, error);
        return {};
    }
}
function getCompletionKindFromType(type) {
    switch (type.kind) {
        case 'function':
        case 'overloaded_function': return CompletionItemKind.Function;
        case 'struct': return CompletionItemKind.Struct;
        case 'module': return CompletionItemKind.Module;
        default: return CompletionItemKind.Variable;
    }
}
function getCompletions(code, position, ast, symbolTable) {
    const completions = [];
    const lineContent = code.split('\n')[position.line] || '';
    const lineUnitilCursor = lineContent.substring(0, position.character);
    // --- 1. ::補完 ---
    const globalMatch = lineUnitilCursor.match(/::([a-zA-Z0-9_]*)$/);
    if (globalMatch) {
        if (symbolTable) {
            const rootScope = symbolTable.getRootScope();
            rootScope.symbols.forEach(symbol => {
                completions.push({
                    label: symbol.name,
                    kind: getCompletionKindFromType(symbol.type),
                    detail: `(grobal) ${symbol.name}`,
                    documentation: symbol.definedAt ? `Defined as L${symbol.definedAt.start.line}` : undefined
                });
            });
        }
        return completions;
    }
    // --- 2. ->補完 ---
    const structMatch = lineUnitilCursor.match(/([a-zA-Z_][a-zA-Z0-9_]*)\s*->\s*([a-zA-Z0-9_]*)$/);
    if (structMatch && symbolTable) {
        const varName = structMatch[1];
        const scope = symbolTable.findScopeAt({ line: position.line + 1, character: position.character });
        let symbol = scope ? scope.lookup(varName) : undefined;
        if (!symbol) {
            symbol = symbolTable.getRootScope().lookup(varName);
        }
        if (symbol && symbol.type.kind === 'struct') {
            const structType = symbol.type;
            structType.members.forEach((memberType, memberName) => {
                completions.push({
                    label: memberName,
                    kind: CompletionItemKind.Field,
                    detail: `(member) ${memberName}`,
                    // documentation: typeToString(memberType)
                });
            });
            return completions;
        }
    }
    // --- 3. module関数補完 ---
    const moduleMatch = lineUnitilCursor.match(/([a-zA-Z_][a-zA-Z0-9_]*)\.([a-zA-Z0-9_]*)$/);
    if (moduleMatch && symbolTable) {
        const moduleName = moduleMatch[1];
        let symbol;
        const scope = symbolTable.findScopeAt({ line: position.line + 1, character: position.character });
        if (scope) {
            symbol = scope.lookup(moduleName);
        }
        if (!symbol) {
            symbol = symbolTable.getRootScope().lookup(moduleName);
        }
        if (symbol && symbol.type.kind === 'module') {
            const moduleType = symbol.type;
            moduleType.members.forEach((memberSymbol, memberName) => {
                if (memberSymbol.type.kind === 'function' || memberSymbol.type.kind === 'overloaded_function') {
                    completions.push({
                        label: memberName,
                        kind: CompletionItemKind.Function,
                        detail: `(module function) ${moduleName}.${memberName}`,
                    });
                }
            });
            return completions;
        }
    }
    // --- 4. 特殊補完 ---
    // pari補完
    const pariMatch = lineUnitilCursor.match(/\bpari\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)$/);
    if (pariMatch) {
        const typedPrefix = pariMatch[1];
        pariSignatures_1.PARI_SIGNATURES.forEach((_signature, funcName) => {
            if (funcName.startsWith(typedPrefix)) {
                completions.push({
                    label: funcName,
                    kind: CompletionItemKind.Function,
                    detail: `pari function: ${funcName}`
                });
            }
        });
        return completions;
    }
    // ctrl補完
    const ctrlMatch = lineUnitilCursor.match(/\bctrl\s*\(\s*"([a-zA-Z0-9_]*)$/);
    if (ctrlMatch) {
        const typedPrefix = ctrlMatch[1];
        ctrl_handlers_1.ctrlCommandNames.forEach(CommandName => {
            if (CommandName.startsWith(typedPrefix)) {
                completions.push({
                    label: CommandName,
                    kind: CompletionItemKind.EnumMember,
                    detail: 'ctrl command'
                });
            }
        });
        return completions;
    }
    // --- 5. 標準補完 ---
    const identifierMatch = lineUnitilCursor.match(/([a-zA-Z_][a-zA-Z0-9_]*)$/);
    const typedPrefix = identifierMatch ? identifierMatch[1] : '';
    if (symbolTable) {
        // 1. 現在のスコープ内のシンボルを収集
        const astPosition = { line: position.line + 1, character: position.character };
        const scope = symbolTable.findScopeAt(astPosition);
        let currentScope = scope;
        while (currentScope) {
            currentScope.symbols.forEach(symbol => {
                if (symbol.name.startsWith(typedPrefix)) {
                    completions.push({
                        label: symbol.name,
                        kind: symbol.type.kind === 'function' || symbol.type.kind === 'overloaded_function' ? CompletionItemKind.Function : CompletionItemKind.Variable,
                        detail: `(${symbol.type.kind}) ${symbol.name}`,
                        documentation: symbol.definedAt ? `Defined at L${symbol.definedAt.start.line}:C${symbol.definedAt.start.column}` : undefined,
                    });
                }
            });
            currentScope = currentScope.parent;
        }
    }
    // 2. 組み込み関数を収集
    builtinSignatures_1.BUILTIN_SIGNATURES.forEach((type, name) => {
        if (name.startsWith(typedPrefix)) {
            completions.push({
                label: name,
                kind: CompletionItemKind.Function,
                detail: `(builtin function) ${name}`,
                documentation: `Type: ${type.kind}`,
            });
        }
    });
    // 3. 組み込み定数を収集
    builtinConstants_1.BUILTIN_CONSTANTS.forEach((type, name) => {
        if (name.startsWith(typedPrefix)) {
            completions.push({
                label: name,
                kind: CompletionItemKind.Constant,
                detail: `(builtin constant) ${name}`,
                documentation: `Type: ${type.kind}`,
            });
        }
    });
    // 4. キーワードを収集
    builtins_1.ASIR_KEYWORDS.forEach(keyword => {
        if (keyword.startsWith(typedPrefix)) {
            completions.push({
                label: keyword,
                kind: CompletionItemKind.Keyword,
                detail: '(keyword)',
            });
        }
    });
    // 5. スニペットを収集
    const snippets = loadSnippets();
    for (const key in snippets) {
        const snippet = snippets[key];
        if (snippet.prefix.startsWith(typedPrefix)) {
            completions.push({
                label: snippet.prefix,
                kind: CompletionItemKind.Snippet,
                detail: `(snippet) ${snippet.prefix}`,
                documentation: snippet.description.join('\n'),
                insertText: snippet.body.join('\n'),
                insertTextFormat: InsertTextFormat.Snippet,
            });
        }
    }
    if (ast) {
        const nodeStack = (0, astUtils_1.findNodeStackAtPosition)(ast, position);
        if (nodeStack.length > 0) {
            const currentNode = nodeStack[nodeStack.length - 1];
            const parentNode = nodeStack.length > 1 ? nodeStack[nodeStack.length - 2] : undefined;
            if (currentNode.kind === 'OptionPair') {
                const optPair = currentNode;
                const funcCallNode = nodeStack.find(n => n.kind === 'FunctionCall');
                if (funcCallNode) {
                    const funcName = funcCallNode.callee.functionName.name;
                    const sig = builtinSignatures_1.BUILTIN_SIGNATURES.get(funcName);
                    if (sig && (sig.kind === 'function' || sig.kind === 'overloaded_function')) {
                        const funcType = (sig.kind === 'function' ? sig : sig.signatures[0]);
                        const optName = optPair.key.name;
                        if (funcType.allowesOptions && funcType.allowesOptions.has(optName)) {
                            const optType = funcType.allowesOptions.get(optName);
                            if (optType.kind === 'literal_union') {
                                optType.values.forEach(val => {
                                    completions.push({
                                        label: String(val),
                                        kind: CompletionItemKind.EnumMember,
                                        detail: `Value for ${optName}`,
                                        insertText: typeof val === 'string' ? `"${val}"` : String(val)
                                    });
                                });
                                return completions;
                            }
                            if (optType.kind === 'primitive' && optType.name === 'integer') {
                                completions.push({ label: '1', kind: CompletionItemKind.Value, detail: 'True (Enable)' });
                                completions.push({ label: '2', kind: CompletionItemKind.Value, detail: 'False (Enable)' });
                            }
                        }
                    }
                }
            }
            const funcCallNode = nodeStack.find(n => n.kind === 'FunctionCall');
            if (funcCallNode) {
                const lineText = code.split('\n')[position.line];
                const hasMid = lineText.lastIndexOf('|');
                if (hasMid !== -1 && position.character > hasMid) {
                    const funcName = funcCallNode.callee.functionName.name;
                    const sig = builtinSignatures_1.BUILTIN_SIGNATURES.get(funcName);
                    if (sig) {
                        const signatures = sig.kind === 'overloaded_function' ? sig.signatures : [sig];
                        signatures.forEach(s => {
                            if (s.allowesOptions) {
                                s.allowesOptions.forEach((type, key) => {
                                    completions.push({
                                        label: key,
                                        kind: CompletionItemKind.Property,
                                        detail: `Option (${type.kind})`,
                                        insertText: `${key} = `
                                    });
                                });
                            }
                        });
                        if (completions.length > 0)
                            return completions;
                    }
                }
            }
        }
    }
    // TODO: モジュール名、構造体名なども収集する
    return completions;
}
//# sourceMappingURL=completionProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/definitionProvider.js":
/*!*******************************************************!*\
  !*** ../pasirser/dist/features/definitionProvider.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefinitionLocation = getDefinitionLocation;
/**
 * 指定された位置のシンボルの定義場所を取得します。
 * @param code コード文字列 (シンボル特定のために使用)
 * @param position カーソル位置
 * @param astNode プログラムのAST
 * @param symbolTable 構築済みのシンボルテーブル
 * @param currentFilePath 現在のファイルのパス (定義場所のfilePathとして使用)
 * @returns 定義場所、または見つからない場合は undefined
 */
function getDefinitionLocation(code, position, astNode, symbolTable, currentFilePath) {
    // hoverProvider.ts と同様に、カーソル位置の単語を特定する
    const lineContent = code.split('\n')[position.line];
    if (!lineContent) {
        return undefined;
    }
    // Find the word that contains the character at position.character
    const wordsInLine = lineContent.matchAll(/[a-zA-Z_][a-zA-Z0-9_]*/g);
    let targetWord;
    for (const match of wordsInLine) {
        if (match.index !== undefined) {
            const startChar1Based = match.index;
            const endChar1Based = match.index + match[0].length;
            // カーソルが単語の範囲内にあるか判定
            if (position.character >= startChar1Based && position.character <= endChar1Based) {
                targetWord = match[0];
                break;
            }
        }
    }
    if (!targetWord) {
        return undefined;
    }
    const word = targetWord;
    // const wordStartChar = position.character - word.length; // 現在は未使用だが、範囲特定に使える
    // カーソル位置のスコープを見つけ、シンボルをルックアップする
    const astPosition = { line: position.line + 1, character: position.character };
    const scope = symbolTable.findScopeAt(astPosition);
    if (!scope) {
        return undefined;
    }
    const symbol = scope.lookup(word);
    if (symbol && symbol.definedAt) {
        return {
            filePath: symbol.declaredFilePath ?? currentFilePath,
            startLine: symbol.definedAt.start.line,
            startColumn: symbol.definedAt.start.column,
            endLine: symbol.definedAt.end.line,
            endColumn: symbol.definedAt.end.column,
        };
    }
    return undefined;
}
//# sourceMappingURL=definitionProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/documentSymbolProvider.js":
/*!***********************************************************!*\
  !*** ../pasirser/dist/features/documentSymbolProvider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SymbolKind = void 0;
exports.getDocumentSymbols = getDocumentSymbols;
const validator_1 = __webpack_require__(/*! ../semantics/validator */ "../pasirser/dist/semantics/validator.js");
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 1] = "File";
    SymbolKind[SymbolKind["Module"] = 2] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 3] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 4] = "Package";
    SymbolKind[SymbolKind["Class"] = 5] = "Class";
    SymbolKind[SymbolKind["Method"] = 6] = "Method";
    SymbolKind[SymbolKind["Property"] = 7] = "Property";
    SymbolKind[SymbolKind["Field"] = 8] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 9] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 10] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 11] = "Interface";
    SymbolKind[SymbolKind["Function"] = 12] = "Function";
    SymbolKind[SymbolKind["Variable"] = 13] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 14] = "Constant";
    SymbolKind[SymbolKind["String"] = 15] = "String";
    SymbolKind[SymbolKind["Number"] = 16] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 17] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 18] = "Array";
    SymbolKind[SymbolKind["Object"] = 19] = "Object";
    SymbolKind[SymbolKind["Key"] = 20] = "Key";
    SymbolKind[SymbolKind["Null"] = 21] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 22] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 23] = "Struct";
    SymbolKind[SymbolKind["Event"] = 24] = "Event";
    SymbolKind[SymbolKind["Operator"] = 25] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 26] = "TypeParameter";
})(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
/**
 * ファイル内のドキュメントシンボル（アウトライン）を生成します。
 * @param astNode プログラムのAST
 * @param symbolTable 構築済みのシンボルテーブル
 * @returns ドキュメントシンボルの配列
 */
function getDocumentSymbols(astNode, symbolTable) {
    const documentSymbols = [];
    class DocumentSymbolCollector extends validator_1.AsirASTVisitor {
        constructor(symbolTable) {
            super();
            this.currentSymbols = documentSymbols;
            this.symbolStack = [];
            this.symbolTable = symbolTable;
        }
        // ヘルパー関数：ASTNodeのlocからRangeを作成
        createRange(loc) {
            if (!loc)
                return undefined;
            return {
                start: { line: loc.start.line, character: loc.start.column },
                end: { line: loc.end.line, character: loc.end.column }
            };
        }
        // シンボルを現在のスコープに追加
        addSymbol(symbol) {
            if (this.symbolStack.length > 0) {
                const parent = this.symbolStack[this.symbolStack.length - 1];
                if (!parent.children) {
                    parent.children = [];
                }
                parent.children.push(symbol);
            }
            else {
                this.currentSymbols.push(symbol);
            }
        }
        // --- 各ASTノードの訪問メソッド --- 
        visitFunctionDefinition(node) {
            if (node.name.loc) {
                const range = this.createRange(node.loc);
                const selectionRange = this.createRange(node.name.loc);
                if (range && selectionRange) {
                    const funcSymbol = {
                        name: node.name.name,
                        kind: SymbolKind.Function,
                        range: range,
                        selectionRange: selectionRange,
                        children: [] // パラメータなどを子として追加する可能性
                    };
                    this.addSymbol(funcSymbol);
                    this.symbolStack.push(funcSymbol);
                    super.visitFunctionDefinition(node);
                    this.symbolStack.pop();
                }
            }
            else {
                super.visitFunctionDefinition(node);
            }
        }
        visitAssignmentExpression(node) {
            if (node.left.kind === 'Indeterminate' && node.left.loc) {
                const symbol = this.symbolTable.currentScope.lookup(node.left.name);
                if (symbol && symbol.definedAt) {
                    const range = this.createRange(node.loc);
                    const selectionRange = this.createRange(symbol.definedAt);
                    if (range && selectionRange) {
                        this.addSymbol({
                            name: node.left.name,
                            kind: SymbolKind.Variable,
                            range: range,
                            selectionRange: selectionRange,
                        });
                    }
                }
            }
            super.visitAssignmentExpression(node);
        }
        visitStructStatement(node) {
            if (node.name.loc) {
                const range = this.createRange(node.loc);
                const selectionRange = this.createRange(node.name.loc);
                if (range && selectionRange) {
                    const structSymbol = {
                        name: node.name.name,
                        kind: SymbolKind.Struct,
                        range: range,
                        selectionRange: selectionRange,
                        children: []
                    };
                    this.addSymbol(structSymbol);
                    this.symbolStack.push(structSymbol);
                    super.visitStructStatement(node);
                    this.symbolStack.pop();
                }
            }
            else {
                super.visitStructStatement(node);
            }
        }
        visitModuleDeclaration(node) {
            if (node.name.loc) {
                const range = this.createRange(node.loc);
                const selectionRange = this.createRange(node.name.loc);
                if (range && selectionRange) {
                    const moduleSymbol = {
                        name: node.name.name,
                        kind: SymbolKind.Module,
                        range: range,
                        selectionRange: selectionRange,
                        children: []
                    };
                    this.addSymbol(moduleSymbol);
                    this.symbolStack.push(moduleSymbol);
                    super.visitModuleDeclaration(node);
                    this.symbolStack.pop();
                }
            }
            else {
                super.visitModuleDeclaration(node);
            }
        }
        // TODO: 他の定義ノード（例: FormDeclaration, ModuleVariableDeclaration）も追加
        // デフォルトの訪問メソッドは子ノードを走査する
        visitProgram(node) { super.visitProgram(node); }
        visitBlock(node) { super.visitBlock(node); }
    }
    const collector = new DocumentSymbolCollector(symbolTable);
    collector.visit(astNode);
    return documentSymbols;
}
//# sourceMappingURL=documentSymbolProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/formatter.js":
/*!**********************************************!*\
  !*** ../pasirser/dist/features/formatter.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsirFormatter = void 0;
class AsirFormatter {
    constructor() {
        this.indentLevel = 0;
        this.indentString = '  ';
    }
    format(node) {
        return this.visit(node);
    }
    indent() {
        this.indentLevel++;
    }
    dedent() {
        this.indentLevel--;
    }
    getCurrentIndent() {
        return this.indentString.repeat(this.indentLevel);
    }
    visit(node) {
        if (!node) {
            return '';
        }
        switch (node.kind) {
            case 'Program': return this.visitProgram(node);
            case 'FunctionDefinition': return this.visitFunctionDefinition(node);
            case 'Block': return this.visitBlock(node);
            case 'ExpressionStatement': return this.visitExpressionStatement(node);
            case 'ReturnStatement': return this.visitReturnStatement(node);
            case 'Indeterminate': return this.visitIndeterminate(node);
            case 'NumberLiteral': return this.visitNumberLiteral(node);
            case 'StringLiteral': return this.visitStringLiteral(node);
            case 'BinaryOperation': return this.visitBinaryOperation(node);
            case 'AssignmentExpression': return this.visitAssignmentExpression(node);
            case 'FunctionCall': return this.visitFunctionCall(node);
            case 'QualifiedName': return this.visitQualifiedName(node);
            case 'ListLiteral': return this.visitListLiteral(node);
            case 'IfStatement': return this.visitIfStatement(node);
            case 'ForStatement': return this.visitForStatement(node);
            case 'WhileStatement': return this.visitWhileStatement(node);
            case 'DoWhileStatement': return this.visitDoWhileStatement(node);
            case 'BreakStatement': return this.visitBreakStatement(node);
            case 'ContinueStatement': return this.visitContinueStatement(node);
            case 'StructStatement': return this.visitStructStatement(node);
            case 'ModuleDeclaration': return this.visitModuleDeclaration(node);
            case 'ModuleVariableDeclaration': return this.visitModuleVariableDeclaration(node);
            case 'EndModule': return this.visitEndModule(node);
            case 'PreprocessorDefine': return this.visitPreprocessorDefine(node);
            case 'PreprocessorIf': return this.visitPreprocessorIf(node);
            case 'PreprocessorIncludeNode': return this.visitPreprocessorInclude(node);
            case 'UnaryOperation': return this.visitUnaryOperation(node);
            case 'TernaryOperation': return this.visitTernaryOperation(node);
            case 'PowerOperation': return this.visitPowerOperation(node);
            case 'IndexAccess': return this.visitIndexAccess(node);
            case 'MemberAccess': return this.visitMemberAccess(node);
            case 'ParenExpression': return this.visitParenExpression(node);
            case 'DistributedPolynomialLiteral': return this.visitDistributedPolynomialLiteral(node);
            case 'ListDestructuringAssignment': return this.visitListDestructuringAssignment(node);
            case 'DottedIdentifier': return this.visitDottedIdentifier(node);
            case 'EmptyStatement': return this.visitEmptyStatement(node);
            case 'FormDeclaration': return this.visitFormDeclaration(node);
            case 'FunctorCall': return this.visitFunctorCall(node);
            case 'PreprocessorElif': return this.visitPreprocessorElif(node);
            case 'PreprocessorElse': return this.visitPreprocessorElse(node);
            case 'ExpressionList': return this.visitExpressionList(node);
            default:
                // 未実装のノードタイプはそのまま出力するか、エラーを出す
                console.warn(`[Formatter] Unhandled AST node kind: ${node.kind}`);
                return `/* Unhandled Node: ${node.kind} */`;
        }
    }
    visitProgram(node) {
        return node.statements.map(stmt => this.getCurrentIndent() + this.visit(stmt)).join('\n');
    }
    visitFunctionDefinition(node) {
        const params = node.parameters.map(p => this.visit(p)).join(', ');
        const body = this.visit(node.body);
        return `def ${this.visit(node.name)}(${params}) ${body}`;
    }
    visitBlock(node) {
        this.indent();
        const statements = node.statements.map(stmt => this.getCurrentIndent() + this.visit(stmt)).join('\n');
        this.dedent();
        return `{\n${statements}\n${this.getCurrentIndent()}}`;
    }
    visitExpressionStatement(node) {
        return `${this.visit(node.expression)};`;
    }
    visitReturnStatement(node) {
        const value = node.value ? ` ${this.visit(node.value)}` : '';
        return `return${value};`;
    }
    visitIndeterminate(node) {
        return node.name;
    }
    visitNumberLiteral(node) {
        return node.rawText ?? String(node.value);
    }
    visitStringLiteral(node) {
        return `"${node.value}"`;
    }
    visitBinaryOperation(node) {
        return `${this.visit(node.left)} ${node.operator} ${this.visit(node.right)}`;
    }
    visitAssignmentExpression(node) {
        return `${this.visit(node.left)} ${node.operator} ${this.visit(node.right)}`;
    }
    visitFunctionCall(node) {
        const callee = this.visit(node.callee);
        const args = node.args.map(arg => this.visit(arg)).join(', ');
        const options = node.options.map(opt => this.visit(opt)).join(', ');
        const parts = [args];
        if (options)
            parts.push(options);
        return `${callee}(${parts.join(', ')})`;
    }
    visitQualifiedName(node) {
        if (node.moduleName) {
            return `${this.visit(node.moduleName)}.${this.visit(node.functionName)}`;
        }
        return this.visit(node.functionName);
    }
    visitListLiteral(node) {
        const elements = node.elements.map(el => this.visit(el)).join(', ');
        return `[${elements}]`;
    }
    visitIfStatement(node) {
        let result = `if (${this.visit(node.condition)}) ${this.visit(node.thenStatement)}`;
        if (node.elseStatement) {
            result += ` else ${this.visit(node.elseStatement)}`;
        }
        return result;
    }
    visitForStatement(node) {
        const initializers = node.initializers.map(i => this.visit(i)).join(', ');
        const conditions = node.conditions.map(c => this.visit(c)).join(', ');
        const updaters = node.updaters.map(u => this.visit(u)).join(', ');
        const body = this.visit(node.body);
        return `for (${initializers}; ${conditions}; ${updaters}) ${body}`;
    }
    visitWhileStatement(node) {
        const conditions = node.conditions.map(c => this.visit(c)).join(', ');
        const body = this.visit(node.body);
        return `while (${conditions}) ${body}`;
    }
    visitDoWhileStatement(node) {
        const conditions = node.conditions.map(c => this.visit(c)).join(', ');
        const body = this.visit(node.body);
        return `do ${body} while (${conditions});`;
    }
    visitBreakStatement(node) {
        return `break;`;
    }
    visitContinueStatement(node) {
        return `continue;`;
    }
    visitStructStatement(node) {
        const members = node.members.map(m => this.visit(m)).join(', ');
        return `struct ${this.visit(node.name)} { ${members} };`;
    }
    visitModuleDeclaration(node) {
        return `module ${this.visit(node.name)}`;
    }
    visitModuleVariableDeclaration(node) {
        const vars = node.variables.map(v => this.visit(v)).join(', ');
        return `${node.scope} ${vars};`;
    }
    visitEndModule(node) {
        return `endmodule;`;
    }
    visitPreprocessorDefine(node) {
        const params = node.parameters.map(p => this.visit(p)).join(', ');
        const body = this.visit(node.body);
        return `#define ${this.visit(node.name)}(${params}) ${body}`;
    }
    visitPreprocessorIf(node) {
        let result = `#${node.directive} (${this.visit(node.condition)})\n`;
        this.indent();
        result += node.thenStatements.map(s => this.getCurrentIndent() + this.visit(s)).join('\n');
        this.dedent();
        for (const elif of node.elifClauses) {
            result += `\n${this.getCurrentIndent()}#elif (${this.visit(elif.condition)})\n`;
            this.indent();
            result += elif.statements.map(s => this.getCurrentIndent() + this.visit(s)).join('\n');
            this.dedent();
        }
        if (node.elseStatements) {
            result += `\n${this.getCurrentIndent()}#else\n`;
            this.indent();
            result += node.elseStatements.statements.map(s => this.getCurrentIndent() + this.visit(s)).join('\n');
            this.dedent();
        }
        result += `\n${this.getCurrentIndent()}#endif`;
        return result;
    }
    visitPreprocessorElif(node) {
        // Handled within visitPreprocessorIf
        return '';
    }
    visitPreprocessorElse(node) {
        // Handled within visitPreprocessorIf
        return '';
    }
    visitPreprocessorInclude(node) {
        const path = node.pathtype === 'system' ? `<${node.path}>` : `"${node.path}"`;
        return `#include ${path}`;
    }
    visitUnaryOperation(node) {
        const operand = this.visit(node.operand);
        if (node.isPostfix) {
            return `${operand}${node.operator}`;
        }
        else {
            return `${node.operator}${operand}`;
        }
    }
    visitTernaryOperation(node) {
        const condition = this.visit(node.condition);
        const consequence = this.visit(node.consequence);
        const alternative = this.visit(node.alternative);
        return `${condition} ? ${consequence} : ${alternative}`;
    }
    visitPowerOperation(node) {
        return `${this.visit(node.base)}^${this.visit(node.exponent)}`;
    }
    visitIndexAccess(node) {
        const base = this.visit(node.base);
        const indices = node.indices.map(i => this.visit(i)).join(', ');
        return `${base}[${indices}]`;
    }
    visitMemberAccess(node) {
        const base = this.visit(node.base);
        const members = node.members.map(m => this.visit(m)).join('.');
        return `${base}.${members}`;
    }
    visitParenExpression(node) {
        return `(${this.visit(node.expression)})`;
    }
    visitDistributedPolynomialLiteral(node) {
        const terms = node.terms.join(', ');
        const modulus = node.modulus !== undefined ? `:${node.modulus}` : '';
        return `<<${terms}${modulus}>>`;
    }
    visitListDestructuringAssignment(node) {
        const targets = node.targets.map(t => this.visit(t)).join(', ');
        return `[${targets}] ${node.operator} ${this.visit(node.right)}`;
    }
    visitDottedIdentifier(node) {
        return node.identifiers.map(id => this.visit(id)).join('.');
    }
    visitEmptyStatement(node) {
        return ''; // 空の文は何も出力しない
    }
    visitFormDeclaration(node) {
        const params = node.parameters.map(p => this.visit(p)).join(', ');
        return `form ${this.visit(node.name)}(${params});`;
    }
    visitFunctorCall(node) {
        const callee = this.visit(node.callee);
        const args = node.args.map(arg => this.visit(arg)).join(', ');
        const options = node.options.map(opt => this.visit(opt)).join(', ');
        const parts = [args];
        if (options)
            parts.push(options);
        return `${callee}(${parts.join(', ')})`;
    }
    visitExpressionList(node) {
        return node.expressions.map(e => this.visit(e)).join(', ');
    }
}
exports.AsirFormatter = AsirFormatter;
//# sourceMappingURL=formatter.js.map

/***/ }),

/***/ "../pasirser/dist/features/hoverProvider.js":
/*!**************************************************!*\
  !*** ../pasirser/dist/features/hoverProvider.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHoverInfo = getHoverInfo;
const typeFormatter_1 = __webpack_require__(/*! ../semantics/utils/typeFormatter */ "../pasirser/dist/semantics/utils/typeFormatter.js");
/**
 * 指定された位置のシンボルに関するホバー情報を取得します。
 * @param code コード文字列
 * @param position カーソル位置
 * @param ast プログラムのAST
 * @param symbolTable 構築済みのシンボルテーブル
 * @returns ホバー情報、または見つからない場合は undefined
 */
function getHoverInfo(code, position, astNode, symbolTable) {
    // 単語の特定
    const lineContent = code.split('\n')[position.line];
    if (!lineContent) {
        return undefined;
    }
    const wordRegex = /[a-zA-Z_@][a-zA-Z0-9_@]*/g;
    const wordsInLine = lineContent.matchAll(wordRegex);
    let targetWord;
    let wordStartChar;
    for (const match of wordsInLine) {
        if (match.index !== undefined) {
            const startChar = match.index;
            const endChar = match.index + match[0].length;
            if (position.character >= startChar && position.character <= endChar) {
                targetWord = match[0];
                wordStartChar = startChar;
                break;
            }
        }
    }
    if (!targetWord) {
        return undefined;
    }
    const word = targetWord;
    // シンボルの検索
    const astPosition = { line: position.line + 1, character: position.character };
    let scope = symbolTable.findScopeAt(astPosition);
    let foundSymbol = scope ? scope.lookup(word) : undefined;
    if (!foundSymbol) {
        const rootScope = symbolTable.getRootScope();
        foundSymbol = rootScope.lookup(word);
    }
    // ホバー情報の構築
    if (foundSymbol) {
        try {
            const contents = [];
            const typeString = (0, typeFormatter_1.typeToString)(foundSymbol.type);
            let codeBlock = '```asir\n';
            if (foundSymbol.type.kind === 'function' || foundSymbol.type.kind === 'overloaded_function') {
                let signature = typeString;
                if (typeString.startsWith('def ')) {
                    signature = `def ${foundSymbol.name}${typeString.substring(3)}`;
                }
                codeBlock += signature;
            }
            else {
                codeBlock += `${foundSymbol.name}: ${typeString}`;
            }
            codeBlock += '\n```';
            contents.push(codeBlock);
            let metaInfo = '';
            if (foundSymbol.definedAt) {
                metaInfo += `*Defined at line ${foundSymbol.definedAt.start.line}*`;
            }
            else {
                metaInfo += `*(Built-in or Predefined)*`;
            }
            contents.push(metaInfo);
            return {
                contents: contents,
                range: {
                    start: { line: position.line, character: wordStartChar },
                    end: { line: position.line, character: wordStartChar + word.length - 1 }
                }
            };
        }
        catch (e) {
            console.error(`[getHoverInfo] Error generating hover info for symbol '${foundSymbol.name}':`, e);
            return undefined;
        }
    }
    return undefined;
}
//# sourceMappingURL=hoverProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/renameProvider.js":
/*!***************************************************!*\
  !*** ../pasirser/dist/features/renameProvider.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRenameEdits = getRenameEdits;
const validator_1 = __webpack_require__(/*! ../semantics/validator */ "../pasirser/dist/semantics/validator.js");
/**
 * 指定された位置のシンボルを新しい名前にリファクタリングするための編集を生成します。
 * 現在は単一ファイル内での名前変更のみをサポートします。
 * @param code コード文字列
 * @param position カーソル位置
 * @param newName 新しいシンボル名
 * @param astNode プログラムのAST
 * @param symbolTable 構築済みのシンボルテーブル
 * @param currentFilePath 現在のファイルのパス
 * @returns 適用すべきTextEditの配列、またはリファクタリングできない場合は undefined
 */
function getRenameEdits(code, position, newName, astNode, symbolTable, currentFilePath) {
    // 1. カーソル位置のシンボルの定義を特定する
    // getDefinitionLocationのロジックを再利用して、シンボルと定義位置を取得
    const lineContent = code.split('\n')[position.line];
    if (!lineContent) {
        return undefined;
    }
    const wordsInLine = lineContent.matchAll(/[a-zA-Z_][a-zA-Z0-9_]*/g);
    let targetWord;
    let targetWordStartChar;
    let targetWordEndChar;
    for (const match of wordsInLine) {
        if (match.index !== undefined) {
            const startChar1Based = match.index + 1; // 1-based start character of the word
            const endChar1Based = match.index + match[0].length; // 1-based end character of the word (inclusive)
            // Check if the 1-based cursor position is within the 1-based word range
            if (position.character >= startChar1Based && position.character <= endChar1Based) {
                targetWord = match[0];
                targetWordStartChar = startChar1Based;
                targetWordEndChar = endChar1Based; // Store 1-based end char
                break;
            }
        }
    }
    if (!targetWord) {
        return undefined;
    }
    const astPosition = { line: position.line + 1, character: position.character };
    const scope = symbolTable.findScopeAt(astPosition);
    if (!scope) {
        return undefined;
    }
    const targetSymbol = scope.lookup(targetWord);
    if (!targetSymbol || !targetSymbol.definedAt) {
        return undefined; // シンボルが見つからないか、定義場所が不明
    }
    const edits = [];
    // 2. 定義場所の編集を追加
    // definedAtはASTNode['loc']なので、Rangeに変換
    const definitionRange = {
        start: { line: targetSymbol.definedAt.start.line, character: targetSymbol.definedAt.start.column },
        end: { line: targetSymbol.definedAt.end.line, character: targetSymbol.definedAt.end.column }
    };
    edits.push({ range: definitionRange, newText: newName });
    // 3. ASTを走査して、現在のファイル内のすべての参照を見つける
    // ValidatorのASTVisitorを参考に、参照を収集するVisitorを作成
    class ReferenceCollector extends validator_1.AsirASTVisitor {
        constructor(targetSymbol) {
            super();
            this.references = [];
            this.targetSymbol = targetSymbol;
        }
        getReferences() {
            const uniqueReferences = [];
            const seen = new Set();
            for (const ref of this.references) {
                const key = `${ref.start.line}:${ref.start.character}-${ref.end.line}:${ref.end.character}`;
                if (!seen.has(key)) {
                    uniqueReferences.push(ref);
                    seen.add(key);
                }
            }
            return uniqueReferences;
        }
        // IndeterminateNodeがシンボルを参照する主要な場所
        visitIndeterminate(node) {
            if (node.resolvedSymbol && node.loc && this.targetSymbol.node) {
                // resolvedSymbolがターゲットシンボルと一致し、loc情報がある場合
                // オブジェクト同一性ではなく、名前と定義ASTノードで比較する
                if (node.resolvedSymbol.name === this.targetSymbol.name &&
                    node.resolvedSymbol.node === this.targetSymbol.node) {
                    this.references.push({
                        start: { line: node.loc.start.line, character: node.loc.start.column },
                        end: { line: node.loc.end.line, character: node.loc.end.column }
                    });
                }
            }
            super.visitIndeterminate(node);
        }
        // QualifiedNameNode (例: module.func) の関数名部分も参照になりうる
        visitQualifiedName(node) {
            if (node.functionName.resolvedSymbol && node.functionName.loc && this.targetSymbol.node) { // Ensure targetSymbol.node exists
                // オブジェクト同一性ではなく、名前と定義ASTノードで比較する
                if (node.functionName.resolvedSymbol.name === this.targetSymbol.name &&
                    node.functionName.resolvedSymbol.node === this.targetSymbol.node) { // ASTNodeオブジェクトを比較
                    this.references.push({
                        start: { line: node.functionName.loc.start.line, character: node.functionName.loc.start.column },
                        end: { line: node.functionName.loc.end.line, character: node.functionName.loc.end.column }
                    });
                }
            }
            super.visitQualifiedName(node);
        }
    }
    const collector = new ReferenceCollector(targetSymbol);
    collector.visit(astNode);
    // 収集した参照の編集を追加
    for (const refRange of collector.getReferences()) {
        // 定義場所と参照場所が重複しないように注意が必要だが、
        // ここでは単純にすべて追加し、後で重複排除やマージを検討する
        // ただし、定義場所は既にeditsに追加されているため、ここでは参照のみを追加する
        // 定義場所と参照場所が同じRangeを持つ場合があるため、重複を避けるためにフィルタリングが必要
        const isDefinitionLocation = refRange.start.line === definitionRange.start.line &&
            refRange.start.character === definitionRange.start.character;
        if (!isDefinitionLocation) {
            edits.push({ range: refRange, newText: newName });
        }
    }
    return edits;
}
//# sourceMappingURL=renameProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/semanticTokensProvider.js":
/*!***********************************************************!*\
  !*** ../pasirser/dist/features/semanticTokensProvider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
exports.getSemanticTokens = getSemanticTokens;
const validator_1 = __webpack_require__(/*! ../semantics/validator */ "../pasirser/dist/semantics/validator.js");
const builtins_1 = __webpack_require__(/*! ../data/builtins */ "../pasirser/dist/data/builtins.js");
const builtinCategories_1 = __webpack_require__(/*! ../data/builtinCategories */ "../pasirser/dist/data/builtinCategories.js");
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes[SemanticTokenTypes["struct"] = 0] = "struct";
    SemanticTokenTypes[SemanticTokenTypes["module"] = 1] = "module";
    SemanticTokenTypes[SemanticTokenTypes["parameter"] = 2] = "parameter";
    SemanticTokenTypes[SemanticTokenTypes["variable"] = 3] = "variable";
    SemanticTokenTypes[SemanticTokenTypes["property"] = 4] = "property";
    SemanticTokenTypes[SemanticTokenTypes["function"] = 5] = "function";
    SemanticTokenTypes[SemanticTokenTypes["macro"] = 6] = "macro";
    SemanticTokenTypes[SemanticTokenTypes["keyword"] = 7] = "keyword";
    SemanticTokenTypes[SemanticTokenTypes["comment"] = 8] = "comment";
    SemanticTokenTypes[SemanticTokenTypes["string"] = 9] = "string";
    SemanticTokenTypes[SemanticTokenTypes["number"] = 10] = "number";
    SemanticTokenTypes[SemanticTokenTypes["operator"] = 11] = "operator";
    SemanticTokenTypes[SemanticTokenTypes["builtinFunction_keyword"] = 12] = "builtinFunction_keyword";
    SemanticTokenTypes[SemanticTokenTypes["formFunction"] = 13] = "formFunction";
    SemanticTokenTypes[SemanticTokenTypes["builtinFunction_default"] = 14] = "builtinFunction_default";
})(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers[SemanticTokenModifiers["declaration"] = 0] = "declaration";
    SemanticTokenModifiers[SemanticTokenModifiers["definition"] = 1] = "definition";
    SemanticTokenModifiers[SemanticTokenModifiers["readonly"] = 2] = "readonly";
    SemanticTokenModifiers[SemanticTokenModifiers["static"] = 3] = "static";
    SemanticTokenModifiers[SemanticTokenModifiers["documentation"] = 4] = "documentation";
})(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));
function getSemanticTokens(astNode, symbolTable) {
    const tokens = [];
    const visitor = new class extends validator_1.AsirASTVisitor {
        addToken(node, type, modifiers = []) {
            if (!node.loc)
                return;
            const line = node.loc.start.line;
            const character = node.loc.start.column;
            const length = (node.loc.end.column ?? character) - character;
            if (length <= 0)
                return;
            let modifierMask = 0;
            for (const modifier of modifiers) {
                modifierMask |= (1 << modifier);
            }
            tokens.push({
                line,
                character,
                length,
                tokenType: type,
                tokenModifiers: modifierMask,
            });
        }
        visitAssignmentExpression(node) {
            if (node.left.kind === 'Indeterminate') {
                const variableNode = node.left;
                let tokenType = SemanticTokenTypes.variable;
                if (variableNode.resolvedSymbol) {
                    if (variableNode.resolvedSymbol.type.kind === 'primitive' && variableNode.resolvedSymbol.type.name === 'parameter') {
                        tokenType = SemanticTokenTypes.parameter;
                    }
                }
                this.addToken(variableNode, tokenType);
            }
            this.visitChildren(node);
        }
        visitModuleVariableDeclaration(node) {
            node.variables.forEach(variable => {
                this.addToken(variable, SemanticTokenTypes.variable, [SemanticTokenModifiers.declaration]);
            });
        }
        visitIndeterminate(node) {
            if (node.resolvedSymbol && node.loc) {
                const symbol = node.resolvedSymbol;
                let type;
                switch (symbol.type.kind) {
                    case 'function':
                    case 'overloaded_function':
                        if (builtins_1.ALL_ASIR_BUILTIN.includes(symbol.name)) {
                            const category = builtinCategories_1.BUILTIN_CATEGORIES.get(symbol.name);
                            switch (category) {
                                case builtinCategories_1.BuiltinFunctionCategory.Keyword:
                                    type = SemanticTokenTypes.builtinFunction_keyword;
                                    break;
                                case builtinCategories_1.BuiltinFunctionCategory.Form:
                                    type = SemanticTokenTypes.formFunction;
                                    break;
                                default:
                                    type = SemanticTokenTypes.builtinFunction_default;
                                    break;
                            }
                        }
                        else {
                            type = SemanticTokenTypes.function;
                        }
                        break;
                    case 'struct':
                        type = SemanticTokenTypes.struct;
                        break;
                    case 'module':
                        type = SemanticTokenTypes.module;
                        break;
                    case 'primitive':
                        if (symbol.type.name === 'parameter') {
                            if (symbol.isFunctionArgument) {
                                type = SemanticTokenTypes.parameter;
                            }
                            else {
                                type = SemanticTokenTypes.variable;
                            }
                        }
                        else {
                            type = SemanticTokenTypes.variable;
                        }
                        break;
                    default:
                        type = SemanticTokenTypes.variable;
                        break;
                }
                this.addToken(node, type);
            }
        }
        visitFunctionDefinition(node) {
            this.addToken(node.name, SemanticTokenTypes.function, [SemanticTokenModifiers.definition]);
            // Explicitly add tokens for parameters in the definition
            node.parameters.forEach(param => {
                this.addToken(param, SemanticTokenTypes.parameter, [SemanticTokenModifiers.declaration]);
            });
            this.visitChildren(node);
        }
        visitStructStatement(node) {
            this.addToken(node.name, SemanticTokenTypes.struct, [SemanticTokenModifiers.definition]);
            node.members.forEach(member => {
                this.addToken(member, SemanticTokenTypes.property);
            });
            this.visitChildren(node);
        }
        visitModuleDeclaration(node) {
            this.addToken(node.name, SemanticTokenTypes.module);
            this.visitChildren(node);
        }
        visitPreprocessorDefine(node) {
            this.addToken(node.name, SemanticTokenTypes.macro);
            this.visitChildren(node);
        }
        visitFormDeclaration(node) {
            this.addToken(node.name, SemanticTokenTypes.formFunction, [SemanticTokenModifiers.declaration]); // Use new name
            this.visitChildren(node);
        }
        visitNumberLiteral(node) {
            this.addToken(node, SemanticTokenTypes.number);
        }
        visitStringLiteral(node) {
            this.addToken(node, SemanticTokenTypes.string);
        }
        visitMemberAccess(node) {
            this.visit(node.base);
            node.members.forEach(member => {
                this.addToken(member, SemanticTokenTypes.property);
            });
        }
    };
    visitor.visit(astNode);
    return tokens;
}
//# sourceMappingURL=semanticTokensProvider.js.map

/***/ }),

/***/ "../pasirser/dist/features/utils/astUtils.js":
/*!***************************************************!*\
  !*** ../pasirser/dist/features/utils/astUtils.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findNodeAtPosition = findNodeAtPosition;
exports.findNodeStackAtPosition = findNodeStackAtPosition;
/**
 * カーソル位置にある最深のノードを探す
 */
function findNodeAtPosition(node, position) {
    if (!node.loc)
        return undefined;
    const startLine = node.loc.start.line - 1; // AST is 1-based
    const endLine = node.loc.end.line - 1;
    if (position.line < startLine || position.line > endLine)
        return undefined;
    if (position.line === startLine && position.character < node.loc.start.column)
        return undefined;
    if (position.line === endLine && position.character > node.loc.end.column)
        return undefined;
    for (const key in node) {
        if (key === 'loc' || key === 'kind')
            continue;
        const child = node[key];
        if (Array.isArray(child)) {
            for (const c of child) {
                if (c && typeof c.kind === 'string') {
                    const found = findNodeAtPosition(c, position);
                    if (found)
                        return found;
                }
            }
        }
        else if (child && typeof child.kind === 'string') {
            const found = findNodeAtPosition(child, position);
            if (found)
                return found;
        }
    }
    return node;
}
/**
 * ノードの親をたどって特定の型を探す (FunctionCallを探すため)
 * ※ 現在のASTは親ポインタを持っていないため、Visitorで親スタックを管理するか、
 * findNodeAtPosition でスタックを返すように修正する必要がある。
 * 今は簡易的に「findNodeWithStack」で。
 */
function findNodeStackAtPosition(node, position, stack = []) {
    if (!node.loc)
        return [];
    const startLine = node.loc.start.line - 1;
    const endLine = node.loc.end.line - 1;
    if (position.line < startLine || position.line > endLine)
        return [];
    if (position.line === startLine && position.character < node.loc.start.column)
        return [];
    if (position.line === endLine && position.character > node.loc.end.column)
        return [];
    stack.push(node);
    for (const key in node) {
        if (key === 'loc' || key === 'kind')
            continue;
        const child = node[key];
        if (Array.isArray(child)) {
            for (const c of child) {
                if (c && typeof c.kind === 'string') {
                    const res = findNodeStackAtPosition(c, position, [...stack]);
                    if (res.length > 0)
                        return res;
                }
            }
        }
        else if (child && typeof child.kind === 'string') {
            const res = findNodeStackAtPosition(child, position, [...stack]);
            if (res.length > 0)
                return res;
        }
    }
    return stack;
}
//# sourceMappingURL=astUtils.js.map

/***/ }),

/***/ "../pasirser/dist/index.js":
/*!*********************************!*\
  !*** ../pasirser/dist/index.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ASIR_KEYWORDS = exports.ALL_ASIR_BUILTIN = exports.asirLexer = exports.parseAndBuildAST = exports.ASTBuilderError = exports.CustomErrorListener = exports.AsirASTBuilder = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SymbolKind = exports.InsertTextFormat = exports.CompletionItemKind = exports.Scope = exports.SymbolTable = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.LanguageService = void 0;
// ライブラリの主要なエントリーポイント
var languageService_js_1 = __webpack_require__(/*! ./services/languageService.js */ "../pasirser/dist/services/languageService.js");
Object.defineProperty(exports, "LanguageService", ({ enumerable: true, get: function () { return languageService_js_1.LanguageService; } }));
// クライアント側で必要となる共通の型定義
__exportStar(__webpack_require__(/*! ./core/ast/asirAst.js */ "../pasirser/dist/core/ast/asirAst.js"), exports);
var diagnostics_js_1 = __webpack_require__(/*! ./utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
Object.defineProperty(exports, "DiagnosticSeverity", ({ enumerable: true, get: function () { return diagnostics_js_1.DiagnosticSeverity; } }));
Object.defineProperty(exports, "DiagnosticTag", ({ enumerable: true, get: function () { return diagnostics_js_1.DiagnosticTag; } }));
var symbolTable_js_1 = __webpack_require__(/*! ./semantics/symbolTable.js */ "../pasirser/dist/semantics/symbolTable.js");
Object.defineProperty(exports, "SymbolTable", ({ enumerable: true, get: function () { return symbolTable_js_1.SymbolTable; } }));
var types_js_1 = __webpack_require__(/*! ./semantics/types.js */ "../pasirser/dist/semantics/types.js");
Object.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return types_js_1.Scope; } }));
var completionProvider_js_1 = __webpack_require__(/*! ./features/completionProvider.js */ "../pasirser/dist/features/completionProvider.js");
Object.defineProperty(exports, "CompletionItemKind", ({ enumerable: true, get: function () { return completionProvider_js_1.CompletionItemKind; } }));
Object.defineProperty(exports, "InsertTextFormat", ({ enumerable: true, get: function () { return completionProvider_js_1.InsertTextFormat; } }));
var documentSymbolProvider_js_1 = __webpack_require__(/*! ./features/documentSymbolProvider.js */ "../pasirser/dist/features/documentSymbolProvider.js");
Object.defineProperty(exports, "SymbolKind", ({ enumerable: true, get: function () { return documentSymbolProvider_js_1.SymbolKind; } }));
var semanticTokensProvider_js_1 = __webpack_require__(/*! ./features/semanticTokensProvider.js */ "../pasirser/dist/features/semanticTokensProvider.js");
Object.defineProperty(exports, "SemanticTokenTypes", ({ enumerable: true, get: function () { return semanticTokensProvider_js_1.SemanticTokenTypes; } }));
Object.defineProperty(exports, "SemanticTokenModifiers", ({ enumerable: true, get: function () { return semanticTokensProvider_js_1.SemanticTokenModifiers; } }));
// 高度な利用やデバッグ向けの型定義
var asirASTBuilder_js_1 = __webpack_require__(/*! ./core/ast/asirASTBuilder.js */ "../pasirser/dist/core/ast/asirASTBuilder.js");
Object.defineProperty(exports, "AsirASTBuilder", ({ enumerable: true, get: function () { return asirASTBuilder_js_1.AsirASTBuilder; } }));
var customErrorListener_js_1 = __webpack_require__(/*! ./core/parser/customErrorListener.js */ "../pasirser/dist/core/parser/customErrorListener.js");
Object.defineProperty(exports, "CustomErrorListener", ({ enumerable: true, get: function () { return customErrorListener_js_1.CustomErrorListener; } }));
var errors_js_1 = __webpack_require__(/*! ./utils/errors.js */ "../pasirser/dist/utils/errors.js");
Object.defineProperty(exports, "ASTBuilderError", ({ enumerable: true, get: function () { return errors_js_1.ASTBuilderError; } }));
var parserUtils_js_1 = __webpack_require__(/*! ./core/parser/parserUtils.js */ "../pasirser/dist/core/parser/parserUtils.js");
Object.defineProperty(exports, "parseAndBuildAST", ({ enumerable: true, get: function () { return parserUtils_js_1.parseAndBuildAST; } }));
var asirLexer_js_1 = __webpack_require__(/*! ./.antlr/asirLexer.js */ "../pasirser/dist/.antlr/asirLexer.js");
Object.defineProperty(exports, "asirLexer", ({ enumerable: true, get: function () { return asirLexer_js_1.asirLexer; } }));
var builtins_js_1 = __webpack_require__(/*! ./data/builtins.js */ "../pasirser/dist/data/builtins.js");
Object.defineProperty(exports, "ALL_ASIR_BUILTIN", ({ enumerable: true, get: function () { return builtins_js_1.ALL_ASIR_BUILTIN; } }));
Object.defineProperty(exports, "ASIR_KEYWORDS", ({ enumerable: true, get: function () { return builtins_js_1.ASIR_KEYWORDS; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/ctrl_handlers.js":
/*!************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/ctrl_handlers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ctrlCommandNames = exports.ctrlSubHandlers = void 0;
const types_1 = __webpack_require__(/*! ../types */ "../pasirser/dist/semantics/types.js");
const diagnostics_1 = __webpack_require__(/*! ../../utils/diagnostics */ "../pasirser/dist/utils/diagnostics.js");
const handleLoadpath = (validator, node, argResults) => {
    // 引数が1つの場合
    if (argResults.length === 1) {
        return {
            type: (0, types_1.l_type)((0, types_1.p_type)('string')),
            constantValue: validator.loadPaths
        };
    }
    // 引数が2つの場合
    if (argResults.length === 2) {
        const newPathsResult = argResults[1];
        if (Array.isArray(newPathsResult.constantValue)) {
            // すべての要素が文字列であることを確認
            if (newPathsResult.constantValue.every(p => typeof p === 'string')) {
                validator.loadPaths = newPathsResult.constantValue;
            }
            else {
                validator.addDiagnostic(node.args[1], `ctrl("loadpath", ...)の第2引数のリストには、文字列以外の定数が含まれています。`, diagnostics_1.DiagnosticSeverity.Error);
            }
        }
        else {
            validator.addDiagnostic(node.args[1], `ctrl("loadpath", ...) の第2引数の値が追跡できません。`, diagnostics_1.DiagnosticSeverity.Hint);
        }
        return { type: (0, types_1.p_type)('integer'), constantValue: 0 };
    }
    validator.addDiagnostic(node, `ctrl("loadpath", ...) の引数の数が正しくありません。`, diagnostics_1.DiagnosticSeverity.Error);
    return { type: (0, types_1.p_type)('any') };
};
exports.ctrlSubHandlers = new Map([
    ['loadpath', handleLoadpath],
]);
exports.ctrlCommandNames = Array.from(exports.ctrlSubHandlers.keys());
//# sourceMappingURL=ctrl_handlers.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlerMap.js":
/*!*********************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlerMap.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.builtinHandlers = void 0;
const ListHandlers = __importStar(__webpack_require__(/*! ./handlers/list */ "../pasirser/dist/semantics/builtins/handlers/list.js"));
const SystemHandlers = __importStar(__webpack_require__(/*! ./handlers/system */ "../pasirser/dist/semantics/builtins/handlers/system.js"));
const NumberHandlers = __importStar(__webpack_require__(/*! ./handlers/number */ "../pasirser/dist/semantics/builtins/handlers/number.js"));
const TypeHandlers = __importStar(__webpack_require__(/*! ./handlers/type */ "../pasirser/dist/semantics/builtins/handlers/type.js"));
const ArrayHandlers = __importStar(__webpack_require__(/*! ./handlers/array */ "../pasirser/dist/semantics/builtins/handlers/array.js"));
const KeywordHandlers = __importStar(__webpack_require__(/*! ./handlers/keyword */ "../pasirser/dist/semantics/builtins/handlers/keyword.js"));
exports.builtinHandlers = new Map([
    // List
    ['append', ListHandlers.handleAppend],
    ['cons', ListHandlers.handleCons],
    ['length', ListHandlers.handleLength],
    ['reverse', ListHandlers.handleReverse],
    // System
    ['chdir', SystemHandlers.handleChdir],
    ['ctrl', SystemHandlers.handleCtrl],
    ['import', SystemHandlers.handleLoadOrImport],
    ['load', SystemHandlers.handleLoadOrImport],
    // Type
    ['type', TypeHandlers.handleType],
    // Number
    ['deval', NumberHandlers.handleDeval],
    ['eval', NumberHandlers.handleDeval],
    // Array (Matrix/Vector)
    ['ltov', ArrayHandlers.handleLtov],
    ['vtol', ArrayHandlers.handleVtol],
    // Keyword
    ['car', KeywordHandlers.handleCar],
    ['cdr', KeywordHandlers.handleCdr],
    ['map', KeywordHandlers.handleMap],
    ['newstruct', KeywordHandlers.handleNewstruct],
    ['pari', KeywordHandlers.handlePari],
]);
//# sourceMappingURL=handlerMap.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/array.js":
/*!*************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/array.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleVtol = exports.handleLtov = void 0;
exports.isVectorLike = isVectorLike;
exports.isMatrixLike = isMatrixLike;
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const typeSystem_js_1 = __webpack_require__(/*! ../../utils/typeSystem.js */ "../pasirser/dist/semantics/utils/typeSystem.js");
// ----------------------------------------
// ベクトルとして扱えるか
function isVectorLike(type) {
    if (type.kind === 'union') {
        return type.types.some(t => isVectorLike(t));
    }
    return type.kind === 'vector' || (type.kind === 'primitive' && (type.name === 'parameter' || type.name === 'any'));
}
// 行列として扱えるか
function isMatrixLike(type) {
    if (type.kind === 'union') {
        return type.types.some(t => isMatrixLike(t));
    }
    return type.kind === 'matrix' || (type.kind === 'primitive' && (type.name === 'parameter' || type.name === 'any'));
}
// ----------------------------------------
const handleLtov = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `ltov は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    let newConstantValue = undefined;
    if (Array.isArray(argResult.constantValue)) {
        newConstantValue = [...argResult.constantValue]; // リストからベクトルへの変換では要素の順序は変わらない
    }
    let actualListType;
    if (argType.kind === 'union') {
        const findListOrTupleInUnion = (unionType) => {
            for (const type of unionType.types) {
                if (type.kind === 'list' || type.kind === 'tuple') {
                    return type;
                }
                if (type.kind === 'union') {
                    const nestedListOrTuple = findListOrTupleInUnion(type);
                    if (nestedListOrTuple) {
                        return nestedListOrTuple;
                    }
                }
            }
            return undefined;
        };
        actualListType = findListOrTupleInUnion(argType);
    }
    else if (argType.kind === 'list' || argType.kind === 'tuple') {
        actualListType = argType;
    }
    if (actualListType) {
        if (actualListType.kind === 'list') {
            return { type: { kind: 'vector', elementType: actualListType.elementType }, constantValue: newConstantValue };
        }
        else if (actualListType.kind === 'tuple') {
            const commonElementType = (0, typeSystem_js_1.getCommonSupertype)(actualListType.elements.map(e => e.type));
            return { type: { kind: 'vector', elementType: commonElementType }, constantValue: newConstantValue };
        }
    }
    validator.addDiagnostic(node, `ltov の引数はリストまたはタプルでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleLtov = handleLtov;
const handleVtol = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `vtol は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    let newConstantValue = undefined;
    if (Array.isArray(argResult.constantValue)) {
        newConstantValue = [...argResult.constantValue]; // ベクトルからリストへの変換では要素の順序は変わらない
    }
    if (isVectorLike(argType)) {
        if (argType.kind === 'primitive' && (argType.name === 'parameter' || argType.name === 'any')) {
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')), constantValue: undefined };
        }
        else if (argType.kind === 'union') {
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')), constantValue: undefined };
        }
        else if (argType.kind === 'vector') {
            return { type: (0, types_js_1.l_type)(argType.elementType), constantValue: newConstantValue };
        }
    }
    validator.addDiagnostic(node, `vtol の引数はベクトルでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleVtol = handleVtol;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/keyword.js":
/*!***************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/keyword.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handlePari = exports.handleNewstruct = exports.handleMap = exports.handleCdr = exports.handleCar = void 0;
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const typeSystem_js_1 = __webpack_require__(/*! ../../utils/typeSystem.js */ "../pasirser/dist/semantics/utils/typeSystem.js");
const typeFormatter_js_1 = __webpack_require__(/*! ../../utils/typeFormatter.js */ "../pasirser/dist/semantics/utils/typeFormatter.js");
const builtinSignatures_js_1 = __webpack_require__(/*! ../../../data/builtinSignatures.js */ "../pasirser/dist/data/builtinSignatures.js");
const pariSignatures_js_1 = __webpack_require__(/*! ../../../data/pariSignatures.js */ "../pasirser/dist/data/pariSignatures.js");
const list_js_1 = __webpack_require__(/*! ./list.js */ "../pasirser/dist/semantics/builtins/handlers/list.js");
const handleCar = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `car 関数は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    if ((0, list_js_1.isListLikeOrUnknown)(argType)) {
        if (argType.kind === 'tuple') {
            let resultType;
            if (argType.elements.length > 0) {
                resultType = argType.elements[0].type;
            }
            else {
                resultType = { kind: 'tuple', elements: [] };
            }
            let constantValue = undefined;
            if (Array.isArray(argResult.constantValue) && argResult.constantValue.length > 0) {
                constantValue = argResult.constantValue[0] ?? undefined;
            }
            return { type: resultType, constantValue };
        }
        else if (argType.kind === 'list') {
            return { type: argType.elementType };
        }
        else {
            return { type: (0, types_js_1.p_type)('any') }; // union を厳密にやってもいいかも
        }
    }
    else {
        validator.addDiagnostic(node.args[0], `car 関数の引数はリストでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
};
exports.handleCar = handleCar;
const handleCdr = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `cdr 関数は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    if ((0, list_js_1.isListLikeOrUnknown)(argType)) {
        if (argType.kind === 'tuple') {
            const resultElements = (argType.elements.length > 1) ? argType.elements.slice(1) : [];
            const resultType = { kind: 'tuple', elements: resultElements };
            let constantValue = undefined;
            if (Array.isArray(argResult.constantValue) && argResult.constantValue.length > 1) {
                constantValue = argResult.constantValue.slice(1);
            }
            else if (Array.isArray(argResult.constantValue)) {
                constantValue = [];
            }
            return { type: resultType, constantValue };
        }
        else if (argType.kind === 'list') {
            return { type: argType };
        }
        else {
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')) };
        }
    }
    else {
        validator.addDiagnostic(node.args[0], `cdr 関数の引数はリストでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
};
exports.handleCdr = handleCdr;
const handleMap = (validator, node, argResults) => {
    if (argResults.length < 2) {
        validator.addDiagnostic(node, `map は少なくとも2つの引数を取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const funcArgNode = node.args[0];
    let resolvedFuncType;
    if (funcArgNode.kind === 'Indeterminate') {
        const funcNameToFind = funcArgNode.name;
        const symbol = validator.symbolTable.currentScope.lookup(funcNameToFind);
        if (symbol) {
            resolvedFuncType = symbol.type;
        }
        else if (builtinSignatures_js_1.BUILTIN_SIGNATURES.has(funcNameToFind)) {
            resolvedFuncType = builtinSignatures_js_1.BUILTIN_SIGNATURES.get(funcNameToFind);
        }
    }
    if (resolvedFuncType && resolvedFuncType.kind === 'union') {
        const funcPart = resolvedFuncType.types.find(t => t.kind === 'function' || t.kind === 'overloaded_function');
        if (funcPart) {
            resolvedFuncType = funcPart;
        }
    }
    if (!resolvedFuncType || (resolvedFuncType.kind !== 'function' && resolvedFuncType.kind !== 'overloaded_function')) {
        validator.addDiagnostic(funcArgNode, `map の第一引数は関数である必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    if (resolvedFuncType.kind === 'overloaded_function') {
        validator.addDiagnostic(funcArgNode, `map にこの関数を渡した場合の型推論は、まだサポートされていません。`, diagnostics_js_1.DiagnosticSeverity.Information);
        return { type: { kind: 'list', elementType: (0, types_js_1.p_type)('any') } };
    }
    const mappedFunctionType = resolvedFuncType; // Assuming it's a single function type after resolution
    const containerResult = argResults[1];
    const containerType = containerResult.type;
    const fixedArgTypes = argResults.slice(2).map(r => r.type);
    let newConstantValue = undefined;
    // Constant value propagation for map is complex, skip for now.
    // Helper to apply the mapped function to an element type
    const applyFunctionToElementType = (elementType) => {
        const callArgTypes = [elementType, ...fixedArgTypes];
        // Check if the number of arguments matches
        if (mappedFunctionType.restParameter) {
            if (callArgTypes.length < mappedFunctionType.parameters.length) {
                validator.addDiagnostic(node, `map の関数引数の数が足りません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return (0, types_js_1.p_type)('any');
            }
        }
        else {
            if (callArgTypes.length !== mappedFunctionType.parameters.length) {
                validator.addDiagnostic(node, `map の関数引数の数が一致しません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return (0, types_js_1.p_type)('any');
            }
        }
        // Check type compatibility for fixed parameters
        const fixedArgCount = Math.min(callArgTypes.length, mappedFunctionType.parameters.length);
        for (let i = 0; i < fixedArgCount; i++) {
            if (!(0, typeSystem_js_1.isTypeCompatible)(callArgTypes[i], mappedFunctionType.parameters[i].type)) {
                validator.addDiagnostic(node, `map の関数引数 ${i + 1} の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(mappedFunctionType.parameters[i].type)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(callArgTypes[i])}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return (0, types_js_1.p_type)('any');
            }
        }
        // Check type compatibility for rest parameter
        if (mappedFunctionType.restParameter) {
            for (let i = fixedArgCount; i < callArgTypes.length; i++) {
                if (!(0, typeSystem_js_1.isTypeCompatible)(callArgTypes[i], mappedFunctionType.restParameter.type)) {
                    validator.addDiagnostic(node, `map の関数引数 ${i + 1} の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(mappedFunctionType.restParameter.type)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(callArgTypes[i])}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                    return (0, types_js_1.p_type)('any');
                }
            }
        }
        return mappedFunctionType.returnType;
    };
    switch (containerType.kind) {
        case 'list':
            const newElementTypeList = applyFunctionToElementType(containerType.elementType);
            return { type: { kind: 'list', elementType: newElementTypeList }, constantValue: newConstantValue };
        case 'vector':
            const newElementTypeVector = applyFunctionToElementType(containerType.elementType);
            return { type: { kind: 'vector', elementType: newElementTypeVector }, constantValue: newConstantValue };
        case 'matrix':
            const newElementTypeMatrix = applyFunctionToElementType(containerType.elementType);
            return { type: { kind: 'matrix', elementType: newElementTypeMatrix }, constantValue: newConstantValue };
        case 'tuple':
            const newElementsTuple = containerType.elements.map(element => ({
                ...element,
                type: applyFunctionToElementType(element.type)
            }));
            return { type: { kind: 'tuple', elements: newElementsTuple }, constantValue: newConstantValue };
        case 'primitive':
            if (containerType.name === 'any' || containerType.name === 'parameter') {
                // If the container type is unknown, the result is also unknown.
                return { type: (0, types_js_1.p_type)('any') };
            }
            break; // Fall through to default error
    }
    validator.addDiagnostic(node.args[1], `map の第二引数はリスト、ベクトル、行列、またはタプルである必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleMap = handleMap;
const handleNewstruct = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `newstruct は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argNode = node.args[0];
    const argResult = argResults[0];
    if (argResult.type.kind === 'structure_definition') {
        const defType = argResult.type;
        console.log('[DEBUG] Newstruct returning:', (0, typeFormatter_js_1.typeToString)(defType.instanceType));
        return { type: defType.instanceType };
    }
    validator.addDiagnostic(argNode, `newstruct の引数は定義済みの構造体名である必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleNewstruct = handleNewstruct;
const handlePari = (validator, node, argResults) => {
    if (argResults.length < 2) {
        validator.addDiagnostic(node, `pari 関数には、少なくとも2つの引数が必要です。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const funcNameNode = node.args[0];
    const funcNameResult = argResults[0];
    if (funcNameNode.kind !== 'Indeterminate') {
        validator.addDiagnostic(funcNameNode, `pari 関数の第一引数は、関数名である必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const pariFuncName = funcNameNode.name;
    const pariFuncSignature = pariSignatures_js_1.PARI_SIGNATURES.get(pariFuncName);
    if (!pariFuncSignature) {
        validator.addDiagnostic(funcNameNode, `pari 関数 '${pariFuncName}' の型定義が見つかりません。`, diagnostics_js_1.DiagnosticSeverity.Information);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const pariArgs = argResults.slice(1);
    const pariArgTypes = pariArgs.map(r => r.type);
    const expectedParams = pariFuncSignature.parameters;
    if (pariArgTypes.length !== expectedParams.length) {
        validator.addDiagnostic(node, `pari 関数 '${pariFuncName}' の引数の数が一致しません。 ${expectedParams.length} 個が必要ですが、${pariArgTypes.length} 個が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
    }
    const fixedArgCount = Math.min(pariArgTypes.length, expectedParams.length);
    for (let i = 0; i < fixedArgCount; i++) {
        if (!(0, typeSystem_js_1.isTypeCompatible)(pariArgTypes[i], expectedParams[i].type)) {
            validator.addDiagnostic(node, `pari 関数 '${pariFuncName}' の引数 ${i + 1} の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(expectedParams[i].type)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(pariArgTypes[i])}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
    }
    return { type: pariFuncSignature.returnType };
};
exports.handlePari = handlePari;
//# sourceMappingURL=keyword.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/list.js":
/*!************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/list.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleReverse = exports.handleLength = exports.handleCons = exports.handleAppend = void 0;
exports.isListLikeOrUnknown = isListLikeOrUnknown;
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const typeSystem_js_1 = __webpack_require__(/*! ../../utils/typeSystem.js */ "../pasirser/dist/semantics/utils/typeSystem.js");
// ----------------------------------------
// リストとして扱えるかを判定するヘルパー関数
function isListLikeOrUnknown(type) {
    // union チェック
    if (type.kind === 'union') {
        return type.types.some(t => isListLikeOrUnknown(t)); // 一つでもlistlikeならok
    }
    return type.kind === 'tuple' || type.kind === 'list' || (type.kind === 'primitive' && (type.name === 'parameter' || type.name === 'any'));
}
;
// ----------------------------------------
const handleAppend = (validator, node, argResults) => {
    if (argResults.length !== 2) {
        validator.addDiagnostic(node, `append は引数を2つ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const list1Result = argResults[0];
    const list2Result = argResults[1];
    const list1Type = list1Result.type;
    const list2Type = list2Result.type;
    let newConstantValue = undefined;
    if (Array.isArray(list1Result.constantValue) && Array.isArray(list2Result.constantValue)) {
        newConstantValue = [...list1Result.constantValue, ...list2Result.constantValue];
    }
    const isList1Ok = isListLikeOrUnknown(list1Type);
    const isList2Ok = isListLikeOrUnknown(list2Type);
    if (isList1Ok && isList2Ok) {
        if ((list1Type.kind === 'list' || list1Type.kind === 'tuple') && (list2Type.kind === 'list' || list2Type.kind === 'tuple')) {
            if (list1Type.kind === 'tuple' && list2Type.kind === 'tuple') {
                const newElements = list1Type.elements.concat(list2Type.elements);
                return { type: { kind: 'tuple', elements: newElements }, constantValue: newConstantValue };
            }
            else {
                const elem1Type = list1Type.kind === 'list' ? list1Type.elementType : (0, typeSystem_js_1.getCommonSupertype)(list1Type.elements.map(e => e.type));
                const elem2Type = list2Type.kind === 'list' ? list2Type.elementType : (0, typeSystem_js_1.getCommonSupertype)(list2Type.elements.map(e => e.type));
                return { type: { kind: 'list', elementType: (0, typeSystem_js_1.getCommonSupertype)([elem1Type, elem2Type]) }, constantValue: newConstantValue };
            }
        }
        else {
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')), constantValue: newConstantValue };
        }
    }
    else {
        validator.addDiagnostic(node, `append の引数は両方ともリストでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
};
exports.handleAppend = handleAppend;
const handleCons = (validator, node, argResults) => {
    if (argResults.length !== 2) {
        validator.addDiagnostic(node, `cons()関数は引数を2つ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any'), constantValue: undefined };
    }
    const itemResult = argResults[0];
    const listResult = argResults[1];
    const listType = listResult.type;
    let newConstantValue = undefined;
    if (itemResult.constantValue !== undefined && Array.isArray(listResult.constantValue)) {
        newConstantValue = [itemResult.constantValue, ...listResult.constantValue];
    }
    if (isListLikeOrUnknown(listType)) {
        if (listType.kind === 'primitive' && (listType.name === 'parameter' || listType.name === 'any')) {
            return { type: (0, types_js_1.l_type)((0, typeSystem_js_1.getCommonSupertype)([itemResult.type, (0, types_js_1.p_type)('any')])), constantValue: newConstantValue };
        }
        if (listType.kind === 'tuple') {
            const newElements = [{ type: itemResult.type }, ...listType.elements];
            return { type: { kind: 'tuple', elements: newElements }, constantValue: newConstantValue };
        }
        else if (listType.kind === 'list') {
            const commonElementType = (0, typeSystem_js_1.getCommonSupertype)([itemResult.type, listType.elementType]);
            return { type: { kind: 'list', elementType: commonElementType }, constantValue: newConstantValue };
        }
        else if (listType.kind === 'union') {
            // 厳密には計算しないでおく
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')), constantValue: undefined };
        }
    }
    validator.addDiagnostic(node.args[1], `cons() の第二引数はリストである必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleCons = handleCons;
const handleLength = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `length は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    let lengthValue = undefined;
    if (argResult.constantValue !== undefined) {
        if (Array.isArray(argResult.constantValue)) {
            lengthValue = argResult.constantValue.length;
        }
    }
    if (lengthValue === undefined) {
        if (argType.kind === 'tuple') {
            lengthValue = argType.elements.length;
        }
        else if (argType.kind === 'vector' && argType.length !== undefined) {
            lengthValue = argType.length;
        }
    }
    return { type: (0, types_js_1.p_type)('integer'), constantValue: lengthValue };
};
exports.handleLength = handleLength;
const handleReverse = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `reverse は引数を1つだけ取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    let newConstantValue = undefined;
    if (Array.isArray(argResult.constantValue)) {
        newConstantValue = [...argResult.constantValue].reverse();
    }
    if (isListLikeOrUnknown(argType)) {
        if (argType.kind === 'tuple') {
            const reversedElements = [...argType.elements].reverse();
            return { type: { kind: 'tuple', elements: reversedElements }, constantValue: newConstantValue };
        }
        else if (argType.kind === 'list') {
            return { type: argType, constantValue: newConstantValue };
        }
        else {
            return { type: (0, types_js_1.l_type)((0, types_js_1.p_type)('any')), constantValue: undefined };
        }
    }
    else {
        validator.addDiagnostic(node.args[0], `reverse の引数はリストでなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
};
exports.handleReverse = handleReverse;
//# sourceMappingURL=list.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/number.js":
/*!**************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/number.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleDeval = void 0;
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const typeSystem_js_1 = __webpack_require__(/*! ../../utils/typeSystem.js */ "../pasirser/dist/semantics/utils/typeSystem.js");
const typeFormatter_js_1 = __webpack_require__(/*! ../../utils/typeFormatter.js */ "../pasirser/dist/semantics/utils/typeFormatter.js");
function devalTypeTransform(inputType, node) {
    switch (inputType.kind) {
        case 'primitive':
            if (inputType.name === 'complex') {
                return (0, types_js_1.p_type)('complex');
            }
            if (['integer', 'rational', 'float', 'bigfloat', 'number'].includes(inputType.name)) {
                return (0, types_js_1.p_type)('float');
            }
            if (inputType.name === 'form') {
                return (0, types_js_1.u_type)([(0, types_js_1.p_type)('number'), (0, types_js_1.p_type)('form')]);
            }
            if (inputType.name === 'parameter') {
                return (0, types_js_1.p_type)('any'); // Changed from p_type('form')
            }
            this.addDiagnostic(node, `devalは型'${(0, typeFormatter_js_1.typeToString)(inputType)}'を評価できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return (0, types_js_1.p_type)('error');
        case 'standard_polynomial':
        case 'distributed_polynomial':
        case 'dmod_polynomial':
        case 'non_commutative_polynomial':
        case 'rational_function':
            const newCoeffType = devalTypeTransform.call(this, inputType.coefficientType, node);
            if (newCoeffType.kind === 'primitive' && newCoeffType.name === 'error') {
                return (0, types_js_1.p_type)('error');
            }
            return { ...inputType, coefficientType: newCoeffType };
        case 'union':
            const transformedTypes = inputType.types.map(t => devalTypeTransform.call(this, t, node));
            const validTypes = transformedTypes.filter(t => !(t.kind === 'primitive' && t.name === 'error'));
            if (validTypes.length === 0) {
                return (0, types_js_1.p_type)('error');
            }
            return (0, typeSystem_js_1.getCommonSupertype)(validTypes);
        case 'vector':
        case 'matrix':
        case 'list':
        case 'tuple':
            this.addDiagnostic(node, `devalはコンテナ型'${inputType.kind}'を直接評価できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return (0, types_js_1.p_type)('error');
        default:
            this.addDiagnostic(node, `devalで未対応の型'${inputType.kind}'です。`, diagnostics_js_1.DiagnosticSeverity.Warning);
            return (0, types_js_1.p_type)('any');
    }
}
const handleDeval = (validator, node, argResults) => {
    if (argResults.length === 0 || argResults.length > 2) {
        validator.addDiagnostic(node, `deval/eval は1つまたは2つの引数を取ります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    const inputType = argResults[0].type;
    const argNode = node.args[0];
    const resultType = devalTypeTransform.call(validator, inputType, argNode);
    return { type: resultType };
};
exports.handleDeval = handleDeval;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/system.js":
/*!**************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/system.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleCtrl = exports.handleLoadOrImport = exports.handleChdir = void 0;
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const ctrl_handlers_js_1 = __webpack_require__(/*! ../ctrl_handlers.js */ "../pasirser/dist/semantics/builtins/ctrl_handlers.js");
const astCache_js_1 = __webpack_require__(/*! ../../../analysis/astCache.js */ "../pasirser/dist/analysis/astCache.js");
// パスに関する関数
const handleChdir = (validator, node, argResults) => {
    if (argResults.length !== 1) {
        validator.addDiagnostic(node, `chdir 関数には、引数としてパスの文字列が1つだけ必要です。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: -1 };
    }
    const pathArg = argResults[0];
    if (typeof pathArg.constantValue === 'string') {
        validator.effectiveCwd = path.resolve(validator.effectiveCwd, pathArg.constantValue);
    }
    else {
        validator.addDiagnostic(node.args[0], `chdirの引数は解決可能な定数文字列である必要があります。`, diagnostics_js_1.DiagnosticSeverity.Warning);
    }
    return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
};
exports.handleChdir = handleChdir;
// ファイルを読む関数
const handleLoadOrImport = (validator, node, argResults) => {
    // メモ: `load`におけるOS依存のパス解決（CWD対asir.exeのパス）は、ここでは処理しない。
    // 呼び出し元（例: VSCode拡張機能）が、環境に応じた正しい検索パスを
    // コンストラクタ引数 `loadPaths` 経由で提供する責務を負う。
    const funcName = node.callee.functionName.name;
    if (argResults.length !== 1 || argResults[0].type.kind !== 'primitive' || argResults[0].type.name !== 'string' || typeof argResults[0].constantValue !== 'string') {
        validator.addDiagnostic(node, `${funcName}()関数には、引数としてファイルパスの文字列が1つだけ必要です。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
    }
    const filePathArgument = argResults[0].constantValue;
    let resolvedPath = null;
    const searchPaths = [validator.effectiveCwd, ...validator.loadPaths];
    for (const dir of searchPaths) {
        const testPath = path.resolve(dir, filePathArgument);
        if (fs.existsSync(testPath)) {
            resolvedPath = testPath;
            break;
        }
    }
    if (!resolvedPath) {
        validator.addDiagnostic(node.args[0], `${funcName}するファイルが見つかりません: ${filePathArgument}`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
    }
    if (funcName === 'import') {
        if (validator.importedFiles.has(resolvedPath)) {
            validator.addDiagnostic(node, `ファイルは既にimport済みです: ${filePathArgument}`, diagnostics_js_1.DiagnosticSeverity.Information);
            return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
        }
        validator.importedFiles.add(resolvedPath);
    }
    if (validator.inclusionStack.includes(resolvedPath)) {
        validator.addDiagnostic(node, `循環参照が検出されました: ${validator.inclusionStack.join(' -> ')} -> ${resolvedPath}`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: 0 };
    }
    const { ast: loadedAst, diagnostics: loadDiagnostics } = astCache_js_1.ASTCache.getInstance().getAST(resolvedPath);
    if (!validator.isHeaderMode) {
        validator.diagnostics.push(...loadDiagnostics);
    }
    if (loadedAst) {
        const previousFilePath = validator.currentFilePath;
        validator.currentFilePath = resolvedPath;
        validator.inclusionStack.push(resolvedPath);
        const previousMode = validator.isHeaderMode;
        validator.isHeaderMode = true;
        const previousReachable = validator.isReachable;
        validator.isReachable = true;
        const previousProgramTerminated = validator.isProgramTerminated;
        validator.isProgramTerminated = false;
        try {
            validator.visit(loadedAst);
        }
        finally {
            validator.isHeaderMode = previousMode;
            validator.inclusionStack.pop();
            validator.currentFilePath = previousFilePath;
            validator.isReachable = previousReachable;
            validator.isProgramTerminated = previousProgramTerminated;
        }
    }
    return { type: (0, types_js_1.p_type)('integer'), constantValue: 1 };
};
exports.handleLoadOrImport = handleLoadOrImport;
const handleCtrl = (validator, node, argResults) => {
    if (argResults.length === 0) {
        return { type: (0, types_js_1.l_type)((0, types_js_1.l_type)((0, types_js_1.p_type)('any'))) };
    }
    ;
    const commandResult = argResults[0];
    if (typeof commandResult.constantValue === 'string') {
        const commandName = commandResult.constantValue;
        if (ctrl_handlers_js_1.ctrlSubHandlers.has(commandName)) {
            const subHandler = ctrl_handlers_js_1.ctrlSubHandlers.get(commandName);
            return subHandler(validator, node, argResults);
        }
    }
    validator.addDiagnostic(node.args[0], `ctrl 関数の第1引数が解決できないか、サポートされていないコマンドです。`, diagnostics_js_1.DiagnosticSeverity.Warning);
    return { type: (0, types_js_1.p_type)('any') };
};
exports.handleCtrl = handleCtrl;
//# sourceMappingURL=system.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/handlers/type.js":
/*!************************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/handlers/type.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleType = void 0;
const types_js_1 = __webpack_require__(/*! ../../types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../../../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const handleType = (Validator, node, argResults) => {
    if (argResults.length !== 1) {
        Validator.addDiagnostic(node, `type() 関数は引数を1つとります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('integer'), constantValue: undefined };
    }
    const argResult = argResults[0];
    const argType = argResult.type;
    const argValue = argResult.constantValue;
    let typeCode = undefined;
    if (argValue === 0) {
        typeCode = 0;
    }
    else {
        if (argType.kind === 'primitive') {
            switch (argType.name) {
                case 'number':
                case 'integer':
                case 'rational':
                case 'float':
                case 'alg':
                case 'bigfloat':
                case 'complex':
                case 'fsmall':
                case 'flarge':
                case 'fchar2':
                case 'fcharp':
                case 'fcharpsmall':
                case 'fchardefp':
                case 'dalg':
                    typeCode = 1;
                    break;
                case 'indeterminate':
                case 'uc':
                case 'form':
                case 'pp':
                    typeCode = 2;
                    break;
                case 'ratfunction':
                    typeCode = 3;
                    break;
                case 'string':
                    typeCode = 7;
                    break;
                case 'struct':
                    typeCode = 8;
                    break;
                case 'dpoly':
                    typeCode = 9;
                    break;
                case 'usint':
                    typeCode = 10;
                    break;
                case 'error':
                    typeCode = 11;
                    break;
                case 'gf2mat':
                    typeCode = 12;
                    break;
                case 'mathcap':
                    typeCode = 13;
                    break;
                case 'qeformula':
                    typeCode = 14;
                    break;
                case 'gfmmat':
                    typeCode = 15;
                    break;
                case 'bytearray':
                    typeCode = 16;
                    break;
                case 'quote':
                    typeCode = 17;
                    break;
                case 'option':
                    typeCode = 18;
                    break;
                case 'symbol':
                    typeCode = 19;
                    break;
                case 'range':
                    typeCode = 20;
                    break;
                case 'textbuffer':
                    typeCode = 21;
                    break;
                case 'dpolyvector':
                    typeCode = 22;
                    break;
                case 'quotearg':
                    typeCode = 23;
                    break;
                case 'imatrix':
                    typeCode = 24;
                    break;
                case 'ncpoly':
                    typeCode = 25;
                    break;
                case 'dmodpoly':
                    typeCode = 26;
                    break;
                case 'void':
                    typeCode = -1;
                    break;
            }
        }
        else {
            switch (argType.kind) {
                case 'list':
                case 'tuple':
                    typeCode = 4;
                    break;
                case 'vector':
                    typeCode = 5;
                    break;
                case 'matrix':
                    typeCode = 6;
                    break;
                case 'struct':
                    typeCode = 8;
                    break;
                case 'standard_polynomial':
                    typeCode = 2;
                    break;
                case 'rational_function':
                    typeCode = 3;
                    break;
                case 'distributed_polynomial':
                    typeCode = 9;
                    break;
                case 'dmod_polynomial':
                    typeCode = 26;
                    break;
                case 'non_commutative_polynomial':
                    typeCode = 25;
                    break;
            }
        }
    }
    return { type: (0, types_js_1.p_type)('integer'), constantValue: typeCode };
};
exports.handleType = handleType;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/index.js":
/*!****************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.builtinHandlers = void 0;
var handlerMap_1 = __webpack_require__(/*! ./handlerMap */ "../pasirser/dist/semantics/builtins/handlerMap.js");
Object.defineProperty(exports, "builtinHandlers", ({ enumerable: true, get: function () { return handlerMap_1.builtinHandlers; } }));
__exportStar(__webpack_require__(/*! ./types */ "../pasirser/dist/semantics/builtins/types.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/builtins/types.js":
/*!****************************************************!*\
  !*** ../pasirser/dist/semantics/builtins/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/symbolTable.js":
/*!*************************************************!*\
  !*** ../pasirser/dist/semantics/symbolTable.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SymbolTable = void 0;
const types_js_1 = __webpack_require__(/*! ./types.js */ "../pasirser/dist/semantics/types.js");
class SymbolTable {
    constructor(programNode) {
        this.currentScope = new types_js_1.Scope(programNode);
    }
    enterScope(node) {
        const newScope = new types_js_1.Scope(node, this.currentScope);
        this.currentScope.children.push(newScope);
        this.currentScope = newScope;
    }
    exitScope() {
        if (this.currentScope.parent) {
            this.currentScope = this.currentScope.parent;
        }
    }
    findScopeAt(position) {
        const rootScope = this.getRootScope();
        return this.findScopeRecursive(rootScope, position) || rootScope;
    }
    getRootScope() {
        let scope = this.currentScope;
        while (scope.parent) {
            scope = scope.parent;
        }
        return scope;
    }
    findScopeRecursive(scope, position) {
        for (const child of scope.children) {
            const found = this.findScopeRecursive(child, position);
            if (found) {
                return found;
            }
        }
        if (scope.node.loc) {
            const startLine = scope.node.loc.start.line;
            const startChar = scope.node.loc.start.column;
            const endLine = scope.node.loc.end.line;
            const endChar = scope.node.loc.end.column;
            if (position.line >= startLine && position.line <= endLine) {
                if (position.line === startLine && position.character < startChar) {
                    return null;
                }
                if (position.line === endLine && position.character > endChar) {
                    return null;
                }
                return scope;
            }
        }
        return null;
    }
    getAllSymbols() {
        const allSymbols = new Map(); // Use Map to ensure uniqueness by name
        const visitedScopes = new Set();
        const collectSymbolsRecursive = (scope) => {
            if (visitedScopes.has(scope)) {
                return;
            }
            visitedScopes.add(scope);
            scope.symbols.forEach(symbol => {
                // Only add if not already present (e.g., from a parent scope)
                if (!allSymbols.has(symbol.name)) {
                    allSymbols.set(symbol.name, symbol);
                }
            });
            scope.children.forEach(childScope => {
                collectSymbolsRecursive(childScope);
            });
        };
        collectSymbolsRecursive(this.getRootScope());
        return Array.from(allSymbols.values());
    }
}
exports.SymbolTable = SymbolTable;
//# sourceMappingURL=symbolTable.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/types.js":
/*!*******************************************!*\
  !*** ../pasirser/dist/semantics/types.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p_type = exports.PARAMETER_TYPE = exports.VOID_TYPE = exports.UNDEFINED_TYPE = exports.STRING_TYPE = exports.NUMBER_TYPE = exports.INTEGER_TYPE = exports.ANY_TYPE = exports.type_0_1_2 = exports.type_m1_0_1 = exports.type_0_1 = exports.type_1 = exports.type_0 = exports.ncpoly_type = exports.rat_type = exports.dpm_type = exports.dpoly_type = exports.stdpoly_type = exports.m_type = exports.v_type = exports.l_type = exports.u_type = exports.Scope = exports.TYPE_METADATA = void 0;
exports.TYPE_METADATA = new Map([
    ['integer', { parent: 'rational', category: 'general_numeric' }],
    ['rational', { parent: 'number', category: 'general_numeric' }],
    ['float', { parent: 'number', category: 'general_numeric' }],
    ['alg', { parent: 'number', category: 'algebric_numeric' }],
    ['bigfloat', { parent: 'number', category: 'general_numeric' }],
    ['complex', { parent: 'number', category: 'general_numeric' }],
    ['fsmall', { parent: 'number', category: 'finite_field' }],
    ['flarge', { parent: 'number', category: 'finite_field' }],
    ['fchar2', { parent: 'number', category: 'finite_field' }],
    ['fcharp', { parent: 'number', category: 'finite_field' }],
    ['fcharpsmall', { parent: 'number', category: 'finite_field' }],
    ['fchardefp', { parent: 'number', category: 'finite_field' }],
    ['dalg', { parent: 'number', category: 'finite_field' }],
    ['number', { category: 'general_numeric' }],
    ['indeterminate', { parent: 'pp', category: 'polynomial' }],
    ['uc', { parent: 'pp', category: 'polynomial' }],
    ['form', { parent: 'pp', category: 'polynomial' }],
    // ['functor', { parent: 'pp', category: 'polynomial' }],
    ['pp', { category: 'polynomial' }],
    ['ratfunction', { category: 'polynomial' }],
    ['string', { category: 'string' }],
    ['dpoly', { category: 'polynomial' }],
    ['usint', { category: 'other' }],
    ['error', { category: 'other' }],
    ['gf2mat', { category: 'other' }],
    ['mathcap', { category: 'other' }],
    ['qeformula', { category: 'other' }],
    ['gfmmat', { category: 'other' }],
    ['bytearray', { category: 'other' }],
    ['quote', { category: 'polynomial' }],
    ['option', { category: 'other' }],
    ['symbol', { category: 'other' }],
    ['range', { category: 'other' }],
    ['textbuffer', { category: 'other' }],
    ['dpolyvector', { category: 'other' }],
    ['quotearg', { category: 'other' }],
    ['imatrix', { category: 'other' }],
    ['ncpoly', { category: 'polynomial' }],
    ['dmodpoly', { category: 'polynomial' }],
    ['void', { category: 'other' }],
    ['any', { category: 'other' }],
    ['undefined', { category: 'other' }],
    ['parameter', { category: 'other' }],
    ['struct', { category: 'other' }]
]);
class Scope {
    constructor(node, parent = null) {
        this.symbols = new Map();
        this.hasLocalDeclaration = false;
        this.children = [];
        this.node = node;
        this.parent = parent;
    }
    define(symbol) {
        if (this.symbols.has(symbol.name)) {
            return false;
        }
        this.symbols.set(symbol.name, symbol);
        return true;
    }
    lookup(name) {
        let scope = this;
        while (scope) {
            const symbol = scope.symbols.get(name);
            if (symbol) {
                return symbol;
            }
            scope = scope.parent;
        }
        return undefined;
    }
    lookupCurrentScope(name) {
        return this.symbols.get(name);
    }
}
exports.Scope = Scope;
// 型生成用ヘルパー
// export const p_type = (name: PrimitiveAsirTypeName): PrimitiveAsirType => ({ kind: 'primitive', name });
const u_type = (types) => ({ kind: 'union', types });
exports.u_type = u_type;
const l_type = (elementType) => ({ kind: 'list', elementType });
exports.l_type = l_type;
const v_type = (elementType) => ({ kind: 'vector', elementType });
exports.v_type = v_type;
const m_type = (elementType) => ({ kind: 'matrix', elementType });
exports.m_type = m_type;
const stdpoly_type = (coeffType) => ({ kind: 'standard_polynomial', coefficientType: coeffType });
exports.stdpoly_type = stdpoly_type;
const dpoly_type = (coeffType) => ({ kind: 'distributed_polynomial', coefficientType: coeffType });
exports.dpoly_type = dpoly_type;
const dpm_type = (coeffType) => ({ kind: 'dmod_polynomial', coefficientType: coeffType });
exports.dpm_type = dpm_type;
const rat_type = (coeffType) => ({ kind: 'rational_function', coefficientType: coeffType });
exports.rat_type = rat_type;
const ncpoly_type = (coeffType) => ({ kind: 'non_commutative_polynomial', coefficientType: coeffType });
exports.ncpoly_type = ncpoly_type;
exports.type_0 = { kind: 'literal_union', values: [0] };
exports.type_1 = { kind: 'literal_union', values: [1] };
exports.type_0_1 = { kind: 'literal_union', values: [0, 1] };
exports.type_m1_0_1 = { kind: 'literal_union', values: [-1, 0, 1] };
exports.type_0_1_2 = { kind: 'literal_union', values: [0, 1, 2] };
// メモリ消費とGC負荷の軽減用
exports.ANY_TYPE = { kind: 'primitive', name: 'any' };
exports.INTEGER_TYPE = { kind: 'primitive', name: 'integer' };
exports.NUMBER_TYPE = { kind: 'primitive', name: 'number' };
exports.STRING_TYPE = { kind: 'primitive', name: 'string' };
exports.UNDEFINED_TYPE = { kind: 'primitive', name: 'undefined' };
exports.VOID_TYPE = { kind: 'primitive', name: 'void' };
exports.PARAMETER_TYPE = { kind: 'primitive', name: 'parameter' };
const p_type = (name) => {
    switch (name) {
        case 'any': return exports.ANY_TYPE;
        case 'integer': return exports.INTEGER_TYPE;
        case 'number': return exports.NUMBER_TYPE;
        case 'string': return exports.STRING_TYPE;
        case 'undefined': return exports.UNDEFINED_TYPE;
        case 'void': return exports.VOID_TYPE;
        case 'parameter': return exports.PARAMETER_TYPE;
        default: return { kind: 'primitive', name };
    }
};
exports.p_type = p_type;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/utils/operatorLogic.js":
/*!*********************************************************!*\
  !*** ../pasirser/dist/semantics/utils/operatorLogic.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWiderNumericType = getWiderNumericType;
exports.checkNumericTypeMismatch = checkNumericTypeMismatch;
exports.getBinaryOperationResultType = getBinaryOperationResultType;
const types_1 = __webpack_require__(/*! ../types */ "../pasirser/dist/semantics/types.js");
const typeSystem_1 = __webpack_require__(/*! ./typeSystem */ "../pasirser/dist/semantics/utils/typeSystem.js");
function getWiderNumericType(type1, type2) {
    const precedence = ['integer', 'rational', 'float', 'alg', 'bigfloat', 'complex', 'fsmall', 'flarge', 'fchar2', 'fcharp', 'fcharpsmall', 'fchardefp', 'dalg', 'number'];
    const index1 = precedence.indexOf(type1);
    const index2 = precedence.indexOf(type2);
    return precedence[Math.max(index1, index2)];
}
function checkNumericTypeMismatch(type1, type2) {
    if (type1.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(type1.name, 'number') && type2.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(type2.name, 'number')) {
        if (type1.name !== type2.name) {
            return `異なる数値型 '${type1.name}' と '${type2.name}'`;
        }
    }
    else if ((0, typeSystem_1.isPolynomialType)(type1) && (0, typeSystem_1.isPolynomialType)(type2) && type1.kind === type2.kind) {
        const coeffWarning = checkNumericTypeMismatch(type1.coefficientType, type2.coefficientType);
        if (coeffWarning) {
            return `異なる係数型を持つ多項式 (${coeffWarning})`;
        }
    }
    else if ((type1.kind === 'list' && type2.kind === 'list') || (type1.kind === 'vector' && type2.kind === 'vector') || (type1.kind === 'matrix' && type2.kind === 'matrix')) {
        const elementWarning = checkNumericTypeMismatch(type1.elementType, type2.elementType);
        if (elementWarning) {
            return `異なる要素型を持つ ${type1.kind} (${elementWarning})`;
        }
    }
    else if (type1.kind === 'tuple' && type2.kind === 'tuple') {
        if (type1.elements.length === type2.elements.length) {
            for (let i = 0; i < type1.elements.length; i++) {
                const elementWarning = checkNumericTypeMismatch(type1.elements[i].type, type2.elements[i].type);
                if (elementWarning) {
                    return `${i + 1} 番目の要素で型が異なるリスト (${elementWarning})`;
                }
            }
        }
    }
    else if (type1.kind === 'struct' && type2.kind === 'struct' && type1.name === type2.name) {
        for (const [key, type1Member] of type1.members.entries()) {
            const type2Member = type2.members.get(key);
            if (type2Member) {
                const memberWarning = checkNumericTypeMismatch(type1Member, type2Member);
                if (memberWarning) {
                    return `メンバー '${key}' の型が異なる構造体 '${type1.name}' (${memberWarning})`;
                }
            }
        }
    }
    return null;
}
function getBinaryOperationResultType(leftType, rightType, operator) {
    if (['==', '!=', '<', '>', '<=', '>=', '&&', '||'].includes(operator)) {
        return (0, types_1.p_type)('integer');
    }
    if ((leftType.kind === 'primitive' && leftType.name === 'parameter') || (rightType.kind === 'primitive' && rightType.name === 'parameter')) {
        return (0, types_1.p_type)('parameter');
    }
    // QE系のロジック
    if (operator.startsWith('@')) {
        return (0, types_1.p_type)('qeformula');
    }
    if (leftType.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(leftType.name, 'pp')) {
        return { kind: 'standard_polynomial', coefficientType: (0, types_1.p_type)('integer') };
    }
    if (rightType.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(rightType.name, 'pp')) {
        return { kind: 'standard_polynomial', coefficientType: (0, types_1.p_type)('integer') };
    }
    switch (operator) {
        case '+':
        case '-':
        case '*':
        case '/':
            // matrix(後で考える)
            if (leftType.kind === 'matrix' && rightType.kind === 'matrix') {
                const elementResultType = (0, typeSystem_1.getCommonSupertype)([leftType.elementType, rightType.elementType]);
                return { kind: 'matrix', elementType: elementResultType };
            }
            const isLeftPoly = (0, typeSystem_1.isPolynomialType)(leftType);
            const isRightPoly = (0, typeSystem_1.isPolynomialType)(rightType);
            const isLeftNumeric = leftType.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(leftType.name, 'number');
            const isRightNumeric = rightType.kind === 'primitive' && (0, typeSystem_1.isSubtypeOf)(rightType.name, 'number');
            const isLeftParametoric = leftType.kind === 'primitive' && leftType.name === 'parameter';
            const isRightParametoric = rightType.kind === 'primitive' && rightType.name === 'parameter';
            // --- 多項式 ---
            if ((leftType.kind === 'dmod_polynomial' && rightType.kind !== 'dmod_polynomial') ||
                (leftType.kind !== 'dmod_polynomial' && rightType.kind === 'dmod_polynomial') ||
                (leftType.kind === 'non_commutative_polynomial' && rightType.kind !== 'non_commutative_polynomial') ||
                (leftType.kind !== 'non_commutative_polynomial' && rightType.kind === 'non_commutative_polynomial')) {
                return (0, types_1.p_type)('any');
            }
            if (isLeftPoly && isRightPoly) {
                const poly1 = leftType;
                const poly2 = rightType;
                const resultCoeffType = (0, typeSystem_1.getCommonSupertype)([poly1.coefficientType, poly2.coefficientType]);
                if (resultCoeffType.kind === 'union') {
                    return (0, types_1.p_type)('any');
                }
                const polyPrecedence = ['standard_polynomial', 'rational_function', 'distributed_polynomial'];
                const kind1_idx = polyPrecedence.indexOf(poly1.kind);
                const kind2_idx = polyPrecedence.indexOf(poly2.kind);
                const resultKind = kind1_idx > kind2_idx ? poly1.kind : poly2.kind;
                if (operator === '/') {
                    const allowedKinds = ['standard_polynomial', 'rational_function'];
                    if (allowedKinds.includes(poly1.kind) && allowedKinds.includes(poly2.kind)) {
                        return { kind: 'rational_function', coefficientType: resultCoeffType };
                    }
                    else {
                        return (0, types_1.p_type)('any');
                    }
                }
                if (['+', '-', '*'].includes(operator)) {
                    return { kind: resultKind, coefficientType: resultCoeffType };
                }
            }
            if ((isLeftPoly && isRightNumeric) || (isLeftNumeric && isRightPoly)) {
                const polyType = (isLeftPoly ? leftType : rightType);
                const numericType = isLeftNumeric ? leftType : rightType;
                const resultCoeffType = (0, typeSystem_1.getCommonSupertype)([polyType.coefficientType, numericType]);
                /*
                if (resultCoeffType.kind === 'union') {
                    return p_type('any');
                }
                */
                return { kind: polyType.kind, coefficientType: resultCoeffType };
            }
            // --- プリミティブ ---
            if (leftType.kind === 'primitive' && rightType.kind === 'primitive') {
                const leftMeta = types_1.TYPE_METADATA.get(leftType.name);
                const rightMeta = types_1.TYPE_METADATA.get(rightType.name);
                if (!leftMeta || !rightMeta) {
                    return (0, types_1.p_type)('any');
                }
                if (leftMeta.category === 'general_numeric' && rightMeta.category === 'general_numeric') {
                    const resultTempType = getWiderNumericType(leftType.name, rightType.name);
                    return (0, types_1.p_type)(resultTempType);
                }
                if (leftType.name === 'rational' && rightMeta.category === 'finite_field') {
                    return rightType;
                }
                if (leftMeta.category === 'finite_field' && rightType.name === 'rational') {
                    return leftType;
                }
                if (leftMeta.category === 'finite_field' && rightMeta.category === 'finite_field') {
                    if (leftType.name === rightType.name) {
                        return leftType;
                    }
                }
                if (leftMeta.category === 'algebric_numeric' && rightMeta.category === 'general_numeric') {
                    if (rightType.name === 'complex') {
                        return rightType;
                    }
                    else if (rightType.name === 'rational') {
                        return leftType;
                    }
                }
                if (leftMeta.category === 'general_numeric' && rightMeta.category === 'algebric_numeric') {
                    if (leftType.name === 'complex') {
                        return leftType;
                    }
                    else if (leftType.name === 'rational') {
                        return rightType;
                    }
                }
                if (leftMeta.category === 'algebric_numeric' && rightMeta.category === 'algebric_numeric') {
                    if (leftType.name === rightType.name) {
                        return leftType;
                    }
                }
                if (operator === '+' && leftMeta.category === 'string' && rightMeta.category === 'string') {
                    return (0, types_1.p_type)('string');
                }
            }
            break;
        case '%':
            const isRightInt = rightType.kind === 'primitive' && rightType.name === 'integer';
            if (!isRightInt) {
                return (0, types_1.p_type)('any');
            }
            const isLeftInt = leftType.kind === 'primitive' && leftType.name === 'integer';
            const isLeftPolyOfInt = leftType.kind === 'standard_polynomial' &&
                leftType.coefficientType.kind === 'primitive' &&
                leftType.coefficientType.name === 'integer';
            if (isLeftInt || isLeftPolyOfInt) {
                return leftType;
            }
            else {
                return (0, types_1.p_type)('any');
            }
        case '==':
        case '!=':
        case '<':
        case '>':
        case '<=':
        case '>=':
        case '&&':
        case '||':
            return (0, types_1.p_type)('integer');
    }
    return (0, types_1.p_type)('any');
}
//# sourceMappingURL=operatorLogic.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/utils/typeFormatter.js":
/*!*********************************************************!*\
  !*** ../pasirser/dist/semantics/utils/typeFormatter.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typeToString = typeToString;
function typeToString(type, simplify = false) {
    if (!type)
        return 'undefined';
    switch (type.kind) {
        case 'primitive': // if (type.name === 'indeterminate) return 'Variable'; のように個別に名前を付けるべき
            return type.name;
        case 'list':
            return `list<${typeToString(type.elementType, true)}>`;
        case 'tuple':
            const tuple = type;
            if (simplify && tuple.elements.length > 3) {
                return `[${typeToString(tuple.elements[0].type, true)}, ...]`;
            }
            const elements = tuple.elements.map(elm => {
                if (elm.name) {
                    return `${elm.name}: ${typeToString(elm.type, true)}`;
                }
                return typeToString(elm.type, true);
            }).join(', ');
            return `[${elements}]`;
        case 'vector':
            return `Vector<${typeToString(type.elementType, true)}>`;
        case 'matrix':
            return `Matrix<${typeToString(type.elementType, true)}>`;
        case 'function':
            const func = type;
            const params = func.parameters.map(p => {
                const pTypeStr = typeToString(p.type, true);
                if (pTypeStr === 'parameter' || pTypeStr === 'any') {
                    return p.name;
                }
                return `${p.name}: ${pTypeStr}`;
            }).join(', ');
            const returnTypeStr = typeToString(func.returnType, true);
            return `def (${params}) -> ${returnTypeStr}`;
        case 'overloaded_function':
            return type.signatures
                .map(sig => typeToString(sig, simplify))
                .join('\n');
        case 'standard_polynomial':
            return `Poly<${typeToString(type.coefficientType, true)}>`;
        case 'distributed_polynomial':
            return `Dpoly<${typeToString(type.coefficientType, true)}>`;
        case 'dmod_polynomial':
            return `DMP<${typeToString(type.coefficientType, true)}>`;
        case 'non_commutative_polynomial':
            return `NBP<${typeToString(type.coefficientType, true)}>`;
        case 'rational_function':
            return `RatFunc<${typeToString(type.coefficientType, true)}>`;
        case 'struct':
            return `struct ${type.name}`;
        case 'structure_definition':
            return `struct definition ${type.name}`;
        case 'module':
            return `module ${type.name}`;
        case 'union':
            const unionTypes = type.types;
            if (simplify && unionTypes.length > 3)
                return 'Variant';
            const uniqueTypeStrs = Array.from(new Set(unionTypes.map(t => typeToString(t, true))));
            if (uniqueTypeStrs.length > 3 && simplify)
                return 'Variant';
            return uniqueTypeStrs.join(' | ');
        case 'literal_union':
            const values = type.values.map(v => typeof v === 'string' ? `'${v}'` : v);
            if (values.length > 5)
                return `${values.slice(0, 5).join(' | ')} | ...`;
            return values.join(' | ');
        default:
            const exhaustiveCheck = type;
            return 'unknown';
    }
}
//# sourceMappingURL=typeFormatter.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/utils/typeSystem.js":
/*!******************************************************!*\
  !*** ../pasirser/dist/semantics/utils/typeSystem.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSubtypeOf = isSubtypeOf;
exports.isPolynomialType = isPolynomialType;
exports.areTypesDeeplyEqual = areTypesDeeplyEqual;
exports.isTypeCompatible = isTypeCompatible;
exports.getCommonSupertype = getCommonSupertype;
exports.getTypeFromCode = getTypeFromCode;
const types_1 = __webpack_require__(/*! ../types */ "../pasirser/dist/semantics/types.js");
const typeFormatter_1 = __webpack_require__(/*! ./typeFormatter */ "../pasirser/dist/semantics/utils/typeFormatter.js");
const operatorLogic_1 = __webpack_require__(/*! ./operatorLogic */ "../pasirser/dist/semantics/utils/operatorLogic.js");
function isSubtypeOf(subtypeName, supertypeName) {
    if (subtypeName === supertypeName) {
        return true;
    }
    if (supertypeName === 'any') {
        return true;
    }
    let currentType = subtypeName;
    while (currentType) {
        currentType = types_1.TYPE_METADATA.get(currentType)?.parent;
        if (currentType === supertypeName) {
            return true;
        }
    }
    return false;
}
function isPolynomialType(type) {
    return [
        'standard_polynomial',
        'distributed_polynomial',
        'dmod_polynomial',
        'non_commutative_polynomial',
        'rational_function'
    ].includes(type.kind);
}
function areTypesDeeplyEqual(type1, type2) {
    // 参照が同じなら等しい
    if (type1 === type2)
        return true;
    // どちらかがnull/undefinedなら、もう一方もそうでないと等しくない
    if (!type1 || !type2)
        return false;
    // kindが異なるなら等しくない
    if (type1.kind !== type2.kind)
        return false;
    // kindに応じて比較ロジックを分岐
    switch (type1.kind) {
        case 'primitive':
            return type1.name === type2.name;
        case 'list':
            return areTypesDeeplyEqual(type1.elementType, type2.elementType);
        case 'tuple':
            const tuple1 = type1;
            const tuple2 = type2;
            if (tuple1.elements.length !== tuple2.elements.length)
                return false;
            for (let i = 0; i < tuple1.elements.length; i++) {
                // Compare type of each element
                if (!areTypesDeeplyEqual(tuple1.elements[i].type, tuple2.elements[i].type))
                    return false;
                if (tuple1.elements[i].name !== tuple2.elements[i].name)
                    return false; // 名前付き要素も比較
            }
            return true;
        case 'vector':
        case 'matrix':
            return areTypesDeeplyEqual(type1.elementType, type2.elementType);
        case 'function':
            const func1 = type1;
            const func2 = type2;
            if (func1.behavior !== func2.behavior)
                return false;
            if (!areTypesDeeplyEqual(func1.returnType, func2.returnType))
                return false;
            if (func1.parameters.length !== func2.parameters.length)
                return false;
            for (let i = 0; i < func1.parameters.length; i++) {
                if (!areTypesDeeplyEqual(func1.parameters[i].type, func2.parameters[i].type))
                    return false;
                if (func1.parameters[i].name !== func2.parameters[i].name)
                    return false;
            }
            // restParameterの比較
            if ((func1.restParameter && !func2.restParameter) || (!func1.restParameter && func2.restParameter))
                return false;
            if (func1.restParameter && func2.restParameter) {
                if (!areTypesDeeplyEqual(func1.restParameter.type, func2.restParameter.type))
                    return false;
                if (func1.restParameter.name !== func2.restParameter.name)
                    return false;
            }
            return true;
        case 'overloaded_function':
            const ovl1 = type1;
            const ovl2 = type2;
            if (ovl1.behavior !== ovl2.behavior)
                return false;
            if (ovl1.signatures.length !== ovl2.signatures.length)
                return false;
            // シグネチャの順序は重要ではないため、ソートして比較するか、Setで比較する
            // ここでは、typeToStringを使って文字列化しSetで比較する。
            // typeToStringも深さ比較してるわけではないので、厳密にはtypeToStringによる文字列が一致しないと等しくないと判断される。
            // よって、この方法は暫定的。
            const sig1Strings = new Set(ovl1.signatures.map(s => (0, typeFormatter_1.typeToString)(s)));
            const sig2Strings = new Set(ovl2.signatures.map(s => (0, typeFormatter_1.typeToString)(s)));
            if (sig1Strings.size !== sig2Strings.size)
                return false;
            for (const s of sig1Strings) {
                if (!sig2Strings.has(s))
                    return false;
            }
            return true;
        case 'struct':
            const struct1 = type1;
            const struct2 = type2;
            if (struct1.name !== struct2.name)
                return false;
            if (struct1.members.size !== struct2.members.size)
                return false;
            for (const [key, memberType1] of struct1.members.entries()) {
                const memberType2 = struct2.members.get(key);
                if (!memberType2 || !areTypesDeeplyEqual(memberType1, memberType2))
                    return false;
            }
            return true;
        case 'module':
            const module1 = type1;
            const module2 = type2;
            if (module1.name !== module2.name)
                return false;
            if (module1.members.size !== module2.members.size)
                return false;
            for (const [key, symbol1] of module1.members.entries()) {
                const symbol2 = module2.members.get(key);
                if (!symbol2 || !areTypesDeeplyEqual(symbol1.type, symbol2.type))
                    return false;
            }
            return true;
        case 'union':
            const union1 = type1;
            const union2 = type2;
            if (union1.types.length !== union2.types.length)
                return false;
            // Union型も順序が重要ではないため、Setを使って比較する。
            // ここでは typeToString を使って文字列化する。
            // より厳密には、Set<AsirType>で管理し、各要素のequalityをareTypesDeeplyEqualで比較すべき
            const union1Strings = new Set(union1.types.map(t => (0, typeFormatter_1.typeToString)(t)));
            const union2Strings = new Set(union2.types.map(t => (0, typeFormatter_1.typeToString)(t)));
            if (union1Strings.size !== union2Strings.size)
                return false;
            for (const s of union1Strings) {
                if (!union2Strings.has(s))
                    return false;
            }
            return true;
        case 'literal_union':
            const litUnion1 = type1;
            const litUnion2 = type2;
            if (litUnion1.values.length !== litUnion2.values.length)
                return false;
            const litUnion1Set = new Set(litUnion1.values);
            const litUnion2Set = new Set(litUnion2.values);
            if (litUnion1Set.size !== litUnion2Set.size)
                return false;
            for (const v of litUnion1Set) {
                if (!litUnion2Set.has(v))
                    return false;
            }
            return true;
        case 'standard_polynomial':
        case 'distributed_polynomial':
        case 'dmod_polynomial':
        case 'non_commutative_polynomial':
        case 'rational_function':
            const poly1 = type1;
            const poly2 = type2;
            if (poly1.kind !== poly2.kind)
                return false;
            return areTypesDeeplyEqual(poly1.coefficientType, poly2.coefficientType);
        default:
            // 未知の型、または比較ロジックが未実装の型
            return false;
    }
}
function isTypeCompatible(sourceType, targetType) {
    // R1: ターゲットとソースがanyなら何でも受け入れる
    if ((targetType.kind === 'primitive' && targetType.name === 'any') || (sourceType.kind === 'primitive' && sourceType.name === 'any')) {
        return true;
    }
    // R2: ターゲットとソースがparameterならほとんどの型に代入可能
    if ((targetType.kind === 'primitive' && targetType.name === 'parameter') || (sourceType.kind === 'primitive' && sourceType.name === 'parameter')) {
        return true;
    }
    // R3: ppは多項式の一種とみなす
    if (sourceType.kind === 'primitive' && (isSubtypeOf(sourceType.name, 'pp') || sourceType.name === 'indeterminate') && isPolynomialType(targetType)) {
        return true;
    }
    // R4: 多項式が期待される場所にnumberが来ることを許可
    if (isPolynomialType(targetType) && sourceType.kind === 'primitive' && isSubtypeOf(sourceType.name, 'number')) {
        return true;
    }
    // R4.1: rational_functionはstandard_polynomialと互換性がある
    if (sourceType.kind === 'rational_function' && targetType.kind === 'standard_polynomial') {
        return isTypeCompatible(sourceType.coefficientType, targetType.coefficientType);
    }
    // R4.2: standard_polynomialはrational_functionと互換性がある
    if (sourceType.kind === 'standard_polynomial' && targetType.kind === 'rational_function') {
        return isTypeCompatible(sourceType.coefficientType, targetType.coefficientType);
    }
    // R4.3: polynomial<integer>はpolynomial<finite_field_type>と互換性がある
    if (sourceType.kind === 'standard_polynomial' && sourceType.coefficientType.kind === 'primitive' && sourceType.coefficientType.name === 'integer' &&
        targetType.kind === 'standard_polynomial' && targetType.coefficientType.kind === 'primitive' &&
        ['fchar2', 'fcharp', 'fcharpsmall', 'fchardefp', 'fsmall', 'flarge'].includes(targetType.coefficientType.name)) {
        return true;
    }
    // R5: ターゲットかソースがunionなら、そのうちのどれか一つと互換性があればよい
    if (targetType.kind === 'union') {
        const result = targetType.types.some(one => isTypeCompatible(sourceType, one));
        return result;
    }
    if (sourceType.kind === 'union') {
        const result = sourceType.types.some(one => isTypeCompatible(one, targetType));
        return result;
    }
    // R6: primitive同士ならサブタイプ関係にあれば互換
    if (sourceType.kind === 'primitive' && targetType.kind === 'primitive') {
        const result = isSubtypeOf(sourceType.name, targetType.name);
        return result;
    }
    // R7: 多項式同士の互換性チェック
    if (isPolynomialType(sourceType) && isPolynomialType(targetType)) {
        if (sourceType.kind !== targetType.kind) {
            return false;
        }
        return isTypeCompatible(sourceType.coefficientType, targetType.coefficientType);
    }
    // R8: リストなどの互換性チェック
    if (sourceType.kind === 'list' && targetType.kind === 'list') {
        const result = isTypeCompatible(sourceType.elementType, targetType.elementType);
        return result;
    }
    if (sourceType.kind === 'vector' && targetType.kind === 'vector') {
        const result = isTypeCompatible(sourceType.elementType, targetType.elementType);
        return result;
    }
    if (sourceType.kind === 'matrix' && targetType.kind === 'matrix') {
        const result = isTypeCompatible(sourceType.elementType, targetType.elementType);
        return result;
    }
    if (sourceType.kind === 'struct' && targetType.kind === 'struct') {
        const result = sourceType.name === targetType.name;
        return result;
    }
    // R9: タプル型同士の互換性チェック
    if (targetType.kind === 'tuple' && sourceType.kind === 'tuple') {
        if (sourceType.elements.length !== targetType.elements.length) {
            return false;
        }
        const result = sourceType.elements.every((sourceElm, i) => {
            const targetElm = targetType.elements[i];
            return isTypeCompatible(sourceElm.type, targetElm.type);
        });
        return result;
    }
    // R10: function同士の互換性チェック
    if (sourceType.kind === 'function' && targetType.kind === 'function') {
        if (sourceType.parameters.length !== targetType.parameters.length) {
            return false;
        }
        if (!isTypeCompatible(sourceType.returnType, targetType.returnType)) {
            return false;
        }
        return sourceType.parameters.every((sourceParam, i) => {
            const targetParam = targetType.parameters[i];
            return areTypesDeeplyEqual(sourceParam.type, targetParam.type);
        });
    }
    // R11: overloaded_functionを考える場合
    if (targetType.kind === 'overloaded_function') {
        if (sourceType.kind === 'function') {
            const result = targetType.signatures.some(sig => isTypeCompatible(sourceType, sig));
            return result;
        }
        if (sourceType.kind === 'overloaded_function') {
            const result = areTypesDeeplyEqual(sourceType, targetType);
            return result;
        }
    }
    if (sourceType.kind === 'overloaded_function' && targetType.kind === 'function') {
        const result = sourceType.signatures.some(sig => isTypeCompatible(sig, targetType));
        return result;
    }
    // R12: タプルはリストに代入可能
    if (sourceType.kind === 'tuple' && targetType.kind === 'list') {
        const result = sourceType.elements.every(sourceElm => isTypeCompatible(sourceElm.type, targetType.elementType));
        return result;
    }
    const result = areTypesDeeplyEqual(sourceType, targetType);
    return result;
}
function getCommonSupertype(types) {
    if (types.length === 0) {
        return (0, types_1.p_type)('any');
    }
    // union 型ならフラットにする
    const flattenedInputTypes = [];
    const stack = [...types];
    while (stack.length > 0) {
        const t = stack.pop();
        if (t.kind === 'union') {
            stack.push(...t.types);
        }
        else {
            flattenedInputTypes.push(t);
        }
    }
    const uniqueTypes = [];
    let hasAnyOrParameter = false;
    for (const type of flattenedInputTypes) {
        if (type.kind === 'primitive' && (type.name === 'any' || type.name === 'parameter')) {
            hasAnyOrParameter = true;
            continue;
        }
        let found = false;
        for (const existingType of uniqueTypes) {
            if (areTypesDeeplyEqual(type, existingType)) {
                found = true;
                break;
            }
        }
        if (!found) {
            uniqueTypes.push(type);
        }
    }
    if (hasAnyOrParameter && uniqueTypes.length > 0) {
        uniqueTypes.push((0, types_1.p_type)('parameter'));
        return { kind: 'union', types: uniqueTypes };
    }
    if (hasAnyOrParameter) {
        return (0, types_1.p_type)('parameter');
    }
    if (uniqueTypes.length === 0) {
        return (0, types_1.p_type)('any');
    }
    if (uniqueTypes.length === 1) {
        return uniqueTypes[0];
    }
    if (uniqueTypes.some(t => t.kind === 'primitive' && t.name === 'any')) {
        return (0, types_1.p_type)('any');
    }
    const allNumeric = uniqueTypes.every(t => t.kind === 'primitive' && isSubtypeOf(t.name, 'number'));
    if (allNumeric) {
        let widerTypeName = uniqueTypes[0].name;
        for (let i = 1; i < uniqueTypes.length; i++) {
            widerTypeName = (0, operatorLogic_1.getWiderNumericType)(widerTypeName, uniqueTypes[i].name);
        }
        return (0, types_1.p_type)(widerTypeName);
    }
    return { kind: 'union', types: uniqueTypes };
}
function getTypeFromCode(code) {
    switch (code) {
        case 0: return (0, types_1.p_type)('integer'); // 0 
        case 1: return (0, types_1.p_type)('number'); // 数 (number) - general numeric type
        case 2: return (0, types_1.stdpoly_type)((0, types_1.p_type)('any')); // 多項式 (standard_polynomial)
        case 3: return (0, types_1.rat_type)((0, types_1.p_type)('any')); // 有理関数 (rational_function)
        case 4: return (0, types_1.l_type)((0, types_1.p_type)('any')); // リスト (list or tuple) - using generic list for now
        case 5: return (0, types_1.v_type)((0, types_1.p_type)('any')); // ベクトル (vector)
        case 6: return (0, types_1.m_type)((0, types_1.p_type)('any')); // 行列 (matrix)
        case 7: return (0, types_1.p_type)('string'); // 文字列 (string)
        case 8: return { kind: 'struct', name: 'any', members: new Map() }; // 構造体 (struct) - generic struct
        case 9: return (0, types_1.dpoly_type)((0, types_1.p_type)('any')); // 分散表現多項式 (distributed_polynomial)
        case 10: return (0, types_1.p_type)('usint'); // 符号付32bit整数 (usint)
        case 11: return (0, types_1.p_type)('error'); // エラーオブジェクト (error)
        case 12: return (0, types_1.p_type)('gf2mat'); // GF(2)上行列 (gf2mat)
        case 13: return (0, types_1.p_type)('mathcap'); // MATHCAP (mathcap)
        case 14: return (0, types_1.p_type)('qeformula'); // 一階述語論理式 (qeformula)
        case 15: return (0, types_1.p_type)('gfmmat'); // GF(M)上行列 (gfmmat)
        case 16: return (0, types_1.p_type)('bytearray'); // byte行列 (byteaaray)
        case 17: return (0, types_1.p_type)('quote'); // QUOTE (quote)
        case 18: return (0, types_1.p_type)('option'); // オプションリスト (option)
        case 19: return (0, types_1.p_type)('symbol'); // シンボル (symbol)
        case 20: return (0, types_1.p_type)('range'); // 変数範囲 (range)
        case 21: return (0, types_1.p_type)('textbuffer'); // テキストバッファ (textbuffer)
        case 22: return (0, types_1.p_type)('dpolyvector'); // 分散表現多項式ベクトル (dpolyvector)
        case 23: return (0, types_1.p_type)('quotearg'); // QUOTEノード (quotearg)
        case 24: return (0, types_1.p_type)('imatrix'); // 疎行列 (imatrix)
        case 25: return (0, types_1.ncpoly_type)((0, types_1.p_type)('any')); // 非可換多項式 (non_commutative_polynomial)
        case 26: return (0, types_1.dpm_type)((0, types_1.p_type)('any')); // 分散表現加群多項式 (dmod_polynomial)
        case -1: return (0, types_1.p_type)('void'); // VOID (void)
        default: return undefined;
    }
}
//# sourceMappingURL=typeSystem.js.map

/***/ }),

/***/ "../pasirser/dist/semantics/validator.js":
/*!***********************************************!*\
  !*** ../pasirser/dist/semantics/validator.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = exports.AsirASTVisitor = void 0;
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const parserUtils_js_1 = __webpack_require__(/*! ../core/parser/parserUtils.js */ "../pasirser/dist/core/parser/parserUtils.js");
const symbolTable_js_1 = __webpack_require__(/*! ./symbolTable.js */ "../pasirser/dist/semantics/symbolTable.js");
const types_js_1 = __webpack_require__(/*! ./types.js */ "../pasirser/dist/semantics/types.js");
const diagnostics_js_1 = __webpack_require__(/*! ../utils/diagnostics.js */ "../pasirser/dist/utils/diagnostics.js");
const builtins_js_1 = __webpack_require__(/*! ../data/builtins.js */ "../pasirser/dist/data/builtins.js");
const builtinSignatures_js_1 = __webpack_require__(/*! ../data/builtinSignatures.js */ "../pasirser/dist/data/builtinSignatures.js");
const builtinConstants_js_1 = __webpack_require__(/*! ../data/builtinConstants.js */ "../pasirser/dist/data/builtinConstants.js");
const index_js_1 = __webpack_require__(/*! ./builtins/index.js */ "../pasirser/dist/semantics/builtins/index.js");
const typeFormatter_js_1 = __webpack_require__(/*! ./utils/typeFormatter.js */ "../pasirser/dist/semantics/utils/typeFormatter.js");
const typeSystem_js_1 = __webpack_require__(/*! ./utils/typeSystem.js */ "../pasirser/dist/semantics/utils/typeSystem.js");
const operatorLogic_js_1 = __webpack_require__(/*! ./utils/operatorLogic.js */ "../pasirser/dist/semantics/utils/operatorLogic.js");
// TODO: データフロー解析
// A simple base class for visiting our custom AST
class AsirASTVisitor {
    visit(node) {
        switch (node.kind) {
            // --- Program & Block ---
            case 'Program': return this.visitProgram(node);
            case 'Block': return this.visitBlock(node);
            // --- Statements ---
            case 'ExpressionStatement': return this.visitExpressionStatement(node);
            case 'EmptyStatement': return this.createDefaultResult();
            case 'FunctionDefinition': return this.visitFunctionDefinition(node);
            case 'FormDeclaration': return this.visitFormDeclaration(node);
            case 'StructStatement': return this.visitStructStatement(node);
            // Module Statements
            case 'ModuleDeclaration': return this.visitModuleDeclaration(node);
            case 'ModuleVariableDeclaration': return this.visitModuleVariableDeclaration(node);
            case 'EndModule': return this.visitEndModule(node);
            // Control Flow
            case 'IfStatement': return this.visitIfStatement(node);
            case 'ForStatement': return this.visitForStatement(node);
            case 'WhileStatement': return this.visitWhileStatement(node);
            case 'DoWhileStatement': return this.visitDoWhileStatement(node);
            case 'ReturnStatement': return this.visitReturnStatement(node);
            case 'BreakStatement': return this.visitBreakStatement(node);
            case 'ContinueStatement': return this.visitContinueStatement(node);
            case 'EndStatement': return this.visitEndStatement(node);
            case 'QuitStatement': return this.visitQuitStatement(node);
            case 'DebugStatement': return this.visitDebugStatement(node);
            // --- Expressions ---
            // Assignment
            case 'AssignmentExpression': return this.visitAssignmentExpression(node);
            case 'ListDestructuringAssignment': return this.visitListDestructuringAssignment(node);
            // Call & Access
            case 'FunctionCall': return this.visitFunctionCall(node);
            case 'FunctorCall': return this.visitFunctorCall(node);
            case 'QualifiedName': return this.visitQualifiedName(node);
            case 'IndexAccess': return this.visitIndexAccess(node);
            case 'MemberAccess': return this.visitMemberAccess(node);
            case 'OptionPair': return this.visitOptionPair(node);
            // Operations
            case 'BinaryOperation': return this.visitBinaryOperation(node);
            case 'UnaryOperation': return this.visitUnaryOperation(node);
            case 'TernaryOperation': return this.visitTernaryOperation(node);
            case 'PowerOperation': return this.visitPowerOperation(node);
            case 'ParenExpression': return this.visitParenExpression(node);
            // Literals & Identifiers
            case 'Indeterminate': return this.visitIndeterminate(node);
            case 'DottedIdentifier': return this.visitDottedIdentifier(node);
            case 'NumberLiteral': return this.visitNumberLiteral(node);
            case 'StringLiteral': return this.visitStringLiteral(node);
            case 'IdLiteral': return this.visitIdLiteral(node);
            case 'ListLiteral': return this.visitListLiteral(node);
            case 'DistributedPolynomialLiteral': return this.visitDPolyLiteral(node);
            // --- Preprocessor ---
            case 'PreprocessorDefine': return this.visitPreprocessorDefine(node);
            case 'PreprocessorIf': return this.visitPreprocessorIf(node);
            case 'PreprocessorInclude': return this.visitPreprocessorInclude(node);
            case 'PreprocessorElif': return this.visitPreprocessorElif(node);
            case 'PreprocessorElse': return this.visitPreprocessorElse(node);
            // --- Others ---
            case 'ExpressionList': return this.visitExpressionList(node);
            default:
                return this.visitChildren(node);
        }
    }
    createDefaultResult() {
        return undefined;
    }
    aggregateResult(aggregate, nextResult) {
        return nextResult !== undefined ? nextResult : aggregate;
    }
    visitChildren(node) {
        let result = this.createDefaultResult();
        for (const key in node) {
            if (key === 'loc' || key === 'kind')
                continue;
            const child = node[key];
            if (Array.isArray(child)) {
                for (const item of child) {
                    if (item && typeof item.kind === 'string') {
                        const childResult = this.visit(item);
                        result = this.aggregateResult(result, childResult);
                    }
                }
            }
            else if (child && typeof child.kind === 'string') {
                const childResult = this.visit(child);
                result = this.aggregateResult(result, childResult);
            }
        }
        return result;
    }
    // --- Abstract Visit Methods ---
    // Program & block
    visitProgram(node) { return this.visitChildren(node); }
    visitBlock(node) { return this.visitChildren(node); }
    // Statements
    visitExpressionStatement(node) { return this.visitChildren(node); }
    visitFunctionDefinition(node) { return this.visitChildren(node); }
    visitFormDeclaration(node) { return this.visitChildren(node); }
    visitStructStatement(node) { return this.visitChildren(node); }
    // Module
    visitModuleDeclaration(node) { return this.visitChildren(node); }
    visitModuleVariableDeclaration(node) { return this.visitChildren(node); }
    visitEndModule(node) { return this.visitChildren(node); }
    // Control Flow
    visitIfStatement(node) { return this.visitChildren(node); }
    visitForStatement(node) { return this.visitChildren(node); }
    visitWhileStatement(node) { return this.visitChildren(node); }
    visitDoWhileStatement(node) { return this.visitChildren(node); }
    visitReturnStatement(node) { return this.visitChildren(node); }
    visitBreakStatement(node) { return this.visitChildren(node); }
    visitContinueStatement(node) { return this.visitChildren(node); }
    visitEndStatement(node) { return this.visitChildren(node); }
    visitQuitStatement(node) { return this.visitChildren(node); }
    visitDebugStatement(node) { return this.visitChildren(node); }
    // Assignments
    visitAssignmentExpression(node) { return this.visitChildren(node); }
    visitListDestructuringAssignment(node) { return this.visitChildren(node); }
    // Calls
    visitFunctionCall(node) { return this.visitChildren(node); }
    visitFunctorCall(node) { return this.visitChildren(node); }
    visitQualifiedName(node) { return this.visitChildren(node); }
    visitOptionPair(node) { return this.visitChildren(node); }
    // Operations
    visitBinaryOperation(node) { return this.visitChildren(node); }
    visitUnaryOperation(node) { return this.visitChildren(node); }
    visitTernaryOperation(node) { return this.visitChildren(node); }
    visitPowerOperation(node) { return this.visitChildren(node); }
    visitParenExpression(node) { return this.visitChildren(node); }
    // Access
    visitIndexAccess(node) { return this.visitChildren(node); }
    visitMemberAccess(node) { return this.visitChildren(node); }
    // Literals & Identifiers
    visitIndeterminate(node) { return this.visitChildren(node); }
    visitDottedIdentifier(node) { return this.visitChildren(node); }
    visitListLiteral(node) { return this.visitChildren(node); }
    visitStringLiteral(node) { return this.visitChildren(node); }
    visitNumberLiteral(node) { return this.visitChildren(node); }
    visitDPolyLiteral(node) { return this.visitChildren(node); }
    visitIdLiteral(node) { return this.visitChildren(node); }
    // Preprocessor
    visitPreprocessorDefine(node) { return this.visitChildren(node); }
    visitPreprocessorIf(node) { return this.visitChildren(node); }
    visitPreprocessorInclude(node) { return this.visitChildren(node); }
    visitPreprocessorElif(node) { return this.visitChildren(node); }
    visitPreprocessorElse(node) { return this.visitChildren(node); }
    // Others
    visitExpressionList(node) { return this.visitChildren(node); }
}
exports.AsirASTVisitor = AsirASTVisitor;
class Validator extends AsirASTVisitor {
    constructor(programNode, filePath = null, systemIncludePaths = [], loadPaths = []) {
        super();
        this.diagnostics = [];
        this.currentFunction = null;
        this.isInLoop = false;
        this.currentModuleScope = null;
        this.currentModule = null;
        this.inclusionStack = [];
        this.importedFiles = new Set();
        this.isReachable = true;
        this.isProgramTerminated = false;
        this.analysisStack = [];
        this.isHeaderMode = false;
        this.symbolTable = new symbolTable_js_1.SymbolTable(programNode);
        this.initialFilePath = filePath;
        this.currentFilePath = filePath;
        this.systemIncludePaths = systemIncludePaths;
        this.loadPaths = loadPaths;
        this.effectiveCwd = process.cwd();
        if (filePath) {
            const resolvedPath = path.resolve(filePath);
            this.inclusionStack.push(resolvedPath);
            this.importedFiles.add(resolvedPath);
        }
        this.registerBuiltinFunctions();
    }
    // --- ヘルパー ---
    checkVariableNameConvention(IdentifierNode) {
        if (!IdentifierNode.name.match(/^(?:[A-Z]|_[A-Z])/)) {
            this.addDiagnostic(IdentifierNode, `変数名 '${IdentifierNode.name}' は大文字で始まる必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
    }
    checkFunctionNameConvention(node) {
        const name = node.name;
        if (name.match(/^(?:[A-Z]|_[A-Z])/)) {
            if (!this.symbolTable.currentScope.lookup(name)) {
                this.addDiagnostic(node, `関数名または不定元 '${node.name}' は小文字で始まる必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
    }
    registerBuiltinFunctions() {
        const globalScope = this.symbolTable.getRootScope();
        builtinSignatures_js_1.BUILTIN_SIGNATURES.forEach((funcType, name) => {
            const symbol = {
                name: name,
                type: funcType,
                definedAt: undefined,
                node: {},
                isUsed: false,
                declaredFilePath: this.currentFilePath ?? undefined
            };
            globalScope.define(symbol);
        });
        for (const name of index_js_1.builtinHandlers.keys()) {
            if (globalScope.lookup(name))
                continue;
            const genericFunctionType = {
                kind: 'function',
                parameters: [],
                restParameter: { name: 'args', type: (0, types_js_1.p_type)('any') },
                returnType: (0, types_js_1.p_type)('any'),
                behavior: 'callable_and_symbol'
            };
            const symbol = {
                name: name,
                type: genericFunctionType,
                definedAt: undefined,
                node: {},
                isUsed: false,
                declaredFilePath: undefined
            };
            globalScope.define(symbol);
        }
    }
    analyze(node) {
        const previousIsReachable = this.isReachable;
        const previousIsProgramTerminated = this.isProgramTerminated;
        this.isReachable = true;
        this.isProgramTerminated = false;
        this.visit(node);
        this.isReachable = previousIsReachable;
        this.isProgramTerminated = previousIsProgramTerminated;
        const savecReachableForCheck = this.isReachable;
        this.isReachable = true;
        this.symbolTable.getAllSymbols().forEach(symbol => {
            if (!symbol.isUsed && symbol.definedAt &&
                !builtinSignatures_js_1.BUILTIN_SIGNATURES.has(symbol.name) &&
                !builtinConstants_js_1.BUILTIN_CONSTANTS.has(symbol.name) &&
                !(symbol.type.kind === 'primitive' && symbol.type.name === 'parameter')) {
                // 編集しているファイル以外で定義された場合は未使用でも警告しない
                if (this.initialFilePath && symbol.declaredFilePath) {
                    const current = path.resolve(this.initialFilePath).toLowerCase();
                    const declared = path.resolve(symbol.declaredFilePath).toLowerCase();
                    if (current !== declared) {
                        return;
                    }
                }
                else if (symbol.declaredFilePath && !this.initialFilePath) {
                    return;
                }
                if (symbol.node.loc) {
                    const range = {
                        start: {
                            line: symbol.node.loc.start.line,
                            character: symbol.node.loc.start.column
                        },
                        end: {
                            line: symbol.node.loc.end.line,
                            character: symbol.node.loc.end.column
                        }
                    };
                    this.diagnostics.push({
                        range,
                        message: `未使用のシンボル '${symbol.name}' が定義されています。`,
                        severity: diagnostics_js_1.DiagnosticSeverity.Information,
                        source: 'AsirValidator',
                        filePath: this.currentFilePath ?? undefined,
                        tags: [diagnostics_js_1.DiagnosticTag.Unnecessary]
                    });
                }
            }
        });
        return this.diagnostics;
    }
    addDiagnostic(node, message, severity, force = false) {
        // dead code は原則報告しない
        if (!this.isReachable && !force) {
            return;
        }
        // ヘッドモードのエラーは無視
        if (this.isHeaderMode) {
            return;
        }
        if (node.loc) {
            const range = {
                start: { line: node.loc.start.line, character: node.loc.start.column },
                end: { line: node.loc.end.line, character: node.loc.end.column }
            };
            this.diagnostics.push({ range, message, severity, source: 'AsirValidator', filePath: this.currentFilePath ?? undefined });
        }
    }
    handleReturn(node, returnType) {
        if (!this.currentFunction) {
            this.addDiagnostic(node, `return文は関数定義の外では使えません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return;
        }
        const funcSymbol = this.symbolTable.currentScope.lookup(this.currentFunction.name.name);
        if (funcSymbol && funcSymbol.type.kind === 'function') {
            const existingReturnType = funcSymbol.type.returnType;
            if (existingReturnType.kind === 'primitive' && existingReturnType.name === 'any') {
                funcSymbol.type.returnType = returnType;
            }
            else {
                funcSymbol.type.returnType = (0, typeSystem_js_1.getCommonSupertype)([existingReturnType, returnType]);
            }
        }
    }
    validateOptions(funcName, allowesOptions, providedOptions) {
        // --- オプションを正規化 ---
        const normalizedOptions = [];
        for (const optionNode of providedOptions) {
            if (optionNode.key.name === 'option_list') {
                if (optionNode.value.kind === 'ListLiteral') {
                    for (const pairNode of optionNode.value.elements) {
                        if (pairNode.kind === 'ListLiteral' && pairNode.elements.length === 2) {
                            const keyAstNode = pairNode.elements[0];
                            const valueAstNode = pairNode.elements[1];
                            if (keyAstNode.kind === 'StringLiteral') {
                                const keyName = keyAstNode.value;
                                normalizedOptions.push({
                                    kind: 'OptionPair',
                                    key: { kind: 'Indeterminate', name: keyName, loc: keyAstNode.loc },
                                    value: valueAstNode,
                                    loc: pairNode.loc
                                });
                            }
                            else {
                                this.addDiagnostic(keyAstNode, `option_list内のキーは文字列である必要があります。キーをダブルクォート（"）で囲んでください。`, diagnostics_js_1.DiagnosticSeverity.Error);
                            }
                        }
                        else {
                            this.addDiagnostic(pairNode, `option_listの中身は、[key, value]という形式の2つの要素からなるリストである必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        }
                    }
                }
                else {
                    this.addDiagnostic(optionNode.value, `option_listは、 [[key1, value1], [key2, value2], ...] という形式のリストである必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
            }
            else {
                normalizedOptions.push(optionNode);
            } // option_listを使ってない奴はそのまま
        }
        // --- 正規化されたオプションを検証 ---
        if (!allowesOptions) {
            if (normalizedOptions.length > 0) {
                this.addDiagnostic(normalizedOptions[0], `関数 '${funcName}' はオプション引数を取りません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
            return;
        }
        for (const optionNode of normalizedOptions) {
            const keyName = optionNode.key.name;
            // オプションが有効かどうか
            if (!allowesOptions.has(keyName)) {
                this.addDiagnostic(optionNode.key, `'${keyName}' は関数 '${funcName}' の有効なオプションではありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                continue;
            }
            // オプションの型のチェック
            const expecedType = allowesOptions.get(keyName);
            const actualResult = this.visit(optionNode.value) || { type: (0, types_js_1.p_type)('any') };
            if (!(0, typeSystem_js_1.isTypeCompatible)(actualResult.type, expecedType)) {
                this.addDiagnostic(optionNode.value, `オプション '${keyName}' の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(expecedType)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(actualResult.type)}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
    }
    checkUsageAsValue(node, type) {
        // 1. 型が純粋な関数またはオーバーロードされた関数の場合
        if (type.kind === 'function' || type.kind === 'overloaded_function') {
            // behaviorが'callable_only'なら、値としての使用はエラー
            if (type.behavior === 'callable_only') {
                const funcName = (node.kind === 'Indeterminate') ? node.name : '関数';
                this.addDiagnostic(node, `呼び出し専用の関数 '${funcName}' を値として使用することはできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return false;
            }
        }
        // 2. 型がUnion型の場合
        else if (type.kind === 'union') {
            // Unionの構成要素の中に、一つでも「値として使える型」があるかどうかを調べる
            const canBeValue = type.types.some(t => {
                if (t.kind === 'function' || t.kind === 'overloaded_function') {
                    // 関数型なら、'callable_and_symbol'であるか
                    return t.behavior === 'callable_and_symbol';
                }
                // そもそも関数でなければ、それは値として使える
                return true;
            });
            // もし値として使える要素が一つもなければ（＝構成要素が全て'callable_only'の関数）、エラー
            if (!canBeValue) {
                const funcName = (node.kind === 'Indeterminate') ? node.name : '関数';
                this.addDiagnostic(node, `呼び出し専用の関数 '${funcName}' を値として使用することはできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return false;
            }
        }
        // 上記のいずれにも当てはまらない場合は、値として使用可能
        return true;
    }
    isTypeLiteral(node) {
        if (node.kind === 'NumberLiteral' || node.kind === 'StringLiteral') {
            return true;
        }
        if (node.kind === 'UnaryOperation') {
            const unaryNode = node;
            if (unaryNode.operator === '-' && unaryNode.operand.kind === 'NumberLiteral') {
                return true;
            }
        }
        return false;
    }
    substractType(unionType, typeToSubtract) {
        const newTypes = unionType.types.filter(t => !(0, typeSystem_js_1.areTypesDeeplyEqual)(t, typeToSubtract));
        if (newTypes.length === 0) {
            return (0, types_js_1.p_type)('any');
        }
        else if (newTypes.length === 1) {
            return newTypes[0];
        }
        return { kind: 'union', types: newTypes };
    }
    getIntegerLiteralValue(n) {
        if (n.kind === 'NumberLiteral') {
            const strVal = String(n.rawText ?? n.value);
            if (!strVal.includes('.') && !strVal.toLowerCase().includes('e')) {
                const val = Number(strVal);
                if (Number.isInteger(val))
                    return val;
            }
        }
        if (n.kind === 'UnaryOperation' && n.operator === '-' && n.operand.kind === 'NumberLiteral') {
            const strVal = String(n.operand.rawText ?? n.operand.value);
            if (!strVal.includes('.') && !strVal.toLowerCase().includes('e')) {
                const val = Number(strVal);
                if (Number.isInteger(val))
                    return -val;
            }
        }
        return null;
    }
    analyzeFunctionBodyWithArgs(funcNode, parameterTypes) {
        // Detect recursion
        if (this.analysisStack.includes(funcNode)) {
            return (0, types_js_1.p_type)('any');
        }
        this.analysisStack.push(funcNode);
        const oldFunction = this.currentFunction;
        this.currentFunction = funcNode;
        this.symbolTable.enterScope(funcNode);
        funcNode.parameters.forEach((param, i) => {
            if (param.loc) {
                this.checkVariableNameConvention(param);
                const paramSymbol = {
                    name: param.name,
                    type: parameterTypes[i] || (0, types_js_1.p_type)('parameter'),
                    definedAt: param.loc,
                    node: param,
                    isUsed: false,
                    isFunctionArgument: true,
                    declaredFilePath: this.currentFilePath ?? undefined
                };
                this.symbolTable.currentScope.define(paramSymbol);
                this.visit(param);
            }
        });
        this.visit(funcNode.body);
        const inferredReturnType = this.symbolTable.currentScope.lookup(funcNode.name.name)?.type?.returnType || (0, types_js_1.p_type)('any');
        this.symbolTable.exitScope();
        this.currentFunction = oldFunction;
        this.analysisStack.pop();
        return inferredReturnType;
    }
    // type()用
    refineTypesFromCondition(condition) {
        if (condition.kind !== 'BinaryOperation' || condition.operator !== '==') {
            return;
        }
        const matchTypeCheck = (expr, value) => {
            if (expr.kind === 'FunctionCall' &&
                expr.callee.kind === 'QualifiedName' &&
                expr.callee.functionName.name === 'type' &&
                expr.args.length === 1 &&
                expr.args[0].kind === 'Indeterminate' &&
                value.kind === 'NumberLiteral') {
                return [expr.args[0].name, Number(value.value)];
            }
            return null;
        };
        const match = matchTypeCheck(condition.left, condition.right) || matchTypeCheck(condition.right, condition.left);
        if (match) {
            const [varName, typeCode] = match;
            const refinedType = (0, typeSystem_js_1.getTypeFromCode)(typeCode);
            if (refinedType) {
                const symbol = this.symbolTable.currentScope.lookup(varName);
                if (symbol) {
                    if (symbol.type.kind === 'union') {
                        const filteredTypes = symbol.type.types.filter(t => (0, typeSystem_js_1.isTypeCompatible)(t, refinedType));
                        if (filteredTypes.length === 1) {
                            symbol.type = filteredTypes[0];
                        }
                        else if (filteredTypes.length > 0) {
                            symbol.type = { kind: 'union', types: filteredTypes };
                        }
                        else {
                            symbol.type = refinedType;
                        }
                    }
                    else {
                        symbol.type = refinedType;
                    }
                }
            }
        }
    }
    // --- visitメソッド ---
    visitProgram(node) {
        for (const stmt of node.statements) {
            if (!this.isReachable || this.isProgramTerminated) {
                if (stmt.kind !== 'EmptyStatement') {
                    this.addDiagnostic(stmt, "到達不能なコードです。", diagnostics_js_1.DiagnosticSeverity.Warning, true);
                }
            }
            const result = this.visit(stmt);
            if (stmt.kind === 'EndStatement' || stmt.kind === 'QuitStatement') {
                this.isProgramTerminated = true;
            }
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitAssignmentExpression(node) {
        const rightResult = this.visit(node.right) || { type: (0, types_js_1.p_type)('any') };
        this.checkUsageAsValue(node.right, rightResult.type);
        let finalType;
        let isCompoundAssignment = node.operator !== '=';
        if (!isCompoundAssignment) {
            finalType = rightResult.type;
        }
        else {
            const leftResult = this.visit(node.left);
            if (!leftResult) {
                finalType = (0, types_js_1.p_type)('any');
            }
            else {
                const leftType = 'type' in leftResult ? leftResult.type : (0, types_js_1.p_type)('any');
                const rightType = rightResult.type;
                if ((leftType.kind === 'primitive' && leftType.name === 'parameter') || (rightType.kind === 'primitive' && rightType.name === 'parameter')) {
                    finalType = (0, types_js_1.p_type)('parameter');
                }
                else if (leftType.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(leftType.name, 'number') && rightType.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(rightType.name, 'number')) {
                    finalType = (0, types_js_1.p_type)((0, operatorLogic_js_1.getWiderNumericType)(leftType.name, rightType.name));
                }
                else {
                    // 多項式など
                    finalType = (0, types_js_1.p_type)('any');
                }
            }
        }
        if (node.left.kind === 'Indeterminate') {
            const varName = node.left.name;
            const symbol = this.symbolTable.currentScope.lookup(varName);
            if (!symbol) {
                this.checkVariableNameConvention(node.left);
                if (this.currentModuleScope && !this.currentFunction) {
                    this.addDiagnostic(node.left, `モジュールのトップレベルの変数 '${varName}' は、static または extern で事前に宣言する必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
                else if (this.currentFunction && this.symbolTable.currentScope.hasLocalDeclaration) {
                    this.addDiagnostic(node.left, `未宣言のローカル変数 '${varName}' に代入されました。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                }
                if (node.left.loc) {
                    this.symbolTable.currentScope.define({
                        name: varName,
                        type: finalType,
                        definedAt: node.left.loc,
                        node: node.left,
                        isUsed: false,
                        constantValue: isCompoundAssignment ? undefined : rightResult.constantValue
                    });
                }
            }
            else {
                const existingType = symbol.type;
                // if (existingType.kind !== 'primitive' || (existingType.name !== 'any' && existingType.name !== 'parameter')) {
                //     if (!isTypeCompatible(finalType, existingType)) {
                //         this.addDiagnostic(
                //             node,
                //             `変数の型が変更されました。 '${typeToString(existingType)}' から ${typeToString(rightResult.type)} に変わっています。これは意図しないエラーの原因になる可能性があるため、型を一致させることを推奨します。`,
                //             DiagnosticSeverity.Warning
                //         );
                //     }
                // }
                symbol.type = finalType;
                symbol.constantValue = isCompoundAssignment ? undefined : rightResult.constantValue;
            }
        }
        else if (node.left.kind === 'IndexAccess' || node.left.kind === 'MemberAccess') {
            let baseNode = node.left;
            while (baseNode.kind === 'IndexAccess' || baseNode.kind === 'MemberAccess') {
                baseNode = baseNode.base;
            }
            if (baseNode.kind === 'Indeterminate') {
                const baseSymbol = this.symbolTable.currentScope.lookup(baseNode.name);
                if (baseSymbol) {
                    baseSymbol.constantValue = undefined;
                }
            }
            const leftResult = this.visit(node.left);
            // if (leftResult && !isTypeCompatible(finalType, leftResult.type)) {
            //     this.addDiagnostic(node.right, `代入の型が一致しません。型 '${typeToString(leftResult.type)}' から型 '${typeToString(finalType)}'へと変更されました。これは意図しないエラーの原因になる可能性があるため、型を一致させることを推奨します。`, DiagnosticSeverity.Warning);
            // }
            if (node.left.kind === 'IndexAccess') {
                const IndexAccessNode = node.left;
                const IndexAccessResult = this.visit(IndexAccessNode);
                if (IndexAccessResult.baseNode.kind === 'Indeterminate') {
                    const baseSymbol = this.symbolTable.currentScope.lookup(IndexAccessResult.baseNode.name);
                    if (baseSymbol) {
                        baseSymbol.constantValue = undefined;
                        const updateTypeRecursively = (collectionType, indices, newElementType) => {
                            if (indices.length === 0) {
                                return newElementType;
                            }
                            const [currentIndex, ...remainingIndices] = indices;
                            if (collectionType.kind === 'vector' || collectionType.kind === 'list' || collectionType.kind === 'matrix') {
                                const updatedElementType = updateTypeRecursively(collectionType.elementType, remainingIndices, newElementType);
                                return { ...collectionType, elementType: (0, typeSystem_js_1.getCommonSupertype)([collectionType.elementType, updatedElementType]) };
                            }
                            else if (collectionType.kind === 'tuple') {
                                const indexValue = this.getIntegerLiteralValue(currentIndex);
                                if (indexValue !== null) {
                                    const updatedElements = [...collectionType.elements];
                                    if (indexValue >= 0 && indexValue < updatedElements.length) {
                                        const elementToUpdate = updatedElements[indexValue];
                                        const updatedElementType = updateTypeRecursively(elementToUpdate.type, remainingIndices, newElementType);
                                        updatedElements[indexValue] = { ...elementToUpdate, type: updatedElementType };
                                    }
                                    return { ...collectionType, elements: updatedElements };
                                }
                                else {
                                    const originalElementType = (0, typeSystem_js_1.getCommonSupertype)(collectionType.elements.map(e => e.type));
                                    const updatedElementType = updateTypeRecursively(originalElementType, remainingIndices, newElementType);
                                    const newOverallType = (0, typeSystem_js_1.getCommonSupertype)([originalElementType, updatedElementType]);
                                    return { kind: 'list', elementType: newOverallType };
                                }
                            }
                            return collectionType;
                        };
                        baseSymbol.type = updateTypeRecursively(baseSymbol.type, IndexAccessResult.indices, finalType);
                    }
                }
            }
            if (node.left.kind === 'MemberAccess') {
                const memberAccessNode = node.left;
                let currentResult = this.visit(memberAccessNode.base);
                if (!currentResult) {
                    return { type: finalType };
                }
                let currentType = currentResult.type;
                const membersToTrace = memberAccessNode.members.slice(0, -1);
                const finalMember = memberAccessNode.members[memberAccessNode.members.length - 1];
                for (const memberIndeterminate of membersToTrace) {
                    if (!currentType) {
                        return { type: finalType };
                    }
                    const memberName = memberIndeterminate.name;
                    if (currentType.kind !== 'struct') {
                        this.addDiagnostic(memberIndeterminate, `'${(0, typeFormatter_js_1.typeToString)(currentType)}' 型にメンバー '${memberName}' はありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        return { type: finalType };
                    }
                    const memberType = currentType.members.get(memberName);
                    if (!memberType) {
                        this.addDiagnostic(memberIndeterminate, `構造体 '${currentType.name}' にメンバー '${memberName}' はありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        return { type: finalType };
                    }
                    currentType = memberType;
                }
                if (!currentType || currentType.kind !== 'struct') {
                    this.addDiagnostic(finalMember, `'${(0, typeFormatter_js_1.typeToString)(currentType)}' 型は構造体ではないため、メンバーにアクセスできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                    return { type: finalType };
                }
                const finalMemberName = finalMember.name;
                const expecedType = currentType.members.get(finalMemberName);
                if (!expecedType) {
                    this.addDiagnostic(finalMember, `構造体 '${currentType.name}' にメンバー '${finalMemberName}' はありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
                else {
                    // if (!isTypeCompatible(finalType, expecedType)) {
                    //     this.addDiagnostic(
                    //         node.right,
                    //         `メンバー '${finalMemberName}' の型が一致しません。型 '${typeToString(expecedType)}' から型 '${typeToString(finalType)}' へ変更されました。これは意図しないエラーの原因になる可能性があるため、型を一致させることを推奨します。`,
                    //         DiagnosticSeverity.Warning
                    //     );
                    // }
                    currentType.members.set(finalMemberName, finalType);
                }
            }
            // if (leftResult!.type && !isTypeCompatible(finalType, leftResult!.type)) {
            //     this.addDiagnostic(
            //         node.right,
            //         `代入の型が一致しません。型 '${typeToString(leftResult!.type)}' から型 '${typeToString(finalType)}' へと変更されました。これは意図しないエラーの原因になる可能性があるため、型を一致させることを推奨します。`,
            //         DiagnosticSeverity.Warning
            //     );
            // }
            if (isCompoundAssignment) {
                let baseNode = node.left;
                while (baseNode.kind === 'IndexAccess' || baseNode.kind === 'MemberAccess') {
                    baseNode = baseNode.base;
                }
                if (baseNode.kind === 'Indeterminate') {
                    const baseSymbol = this.symbolTable.currentScope.lookup(baseNode.name);
                    if (baseSymbol) {
                        baseSymbol.constantValue = undefined;
                    }
                }
            }
        }
        return { type: finalType };
    }
    visitExpressionStatement(node) {
        const exprType = this.visit(node.expression);
        if (exprType) {
            this.checkUsageAsValue(node.expression, exprType.type);
        }
        return exprType || { type: (0, types_js_1.p_type)('undefined') };
    }
    visitFunctionDefinition(node, parameterOverrideTypes) {
        const funcName = node.name.name;
        // モジュール内の宣言チェック
        if (this.currentModuleScope) {
            const symbol = this.symbolTable.currentScope.lookup(funcName);
            if (!symbol || (symbol.type.kind !== 'function' && symbol.type.kind !== 'overloaded_function')) {
                this.addDiagnostic(node.name, `モジュール内の関数 '${funcName}' は、localfで事前に宣言する必要があります。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
        // 関数が定義済みかをチェックする。
        const existingSymbol = this.symbolTable.currentScope.lookupCurrentScope(funcName);
        let isOverwritingDeclation = false;
        if (existingSymbol) {
            const isForwardDecl = existingSymbol.node.kind === 'FormDeclaration';
            const isModuleDecl = existingSymbol.node.kind === 'Indeterminate';
            const isPreprocess = existingSymbol.node.kind === 'PreprocessorDefine';
            if (isForwardDecl) {
                this.addDiagnostic(node.name, `関数 '${funcName}' は前方宣言されているため、この 'def' による定義は無視されます。この関数への呼び出しは常に「関数形式」を返します。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                return { type: (0, types_js_1.p_type)('undefined') };
            }
            else if (isPreprocess) {
                this.addDiagnostic(node.name, `関数 '${funcName}' はマクロとして定義されているため、この 'def' による定義は無視されます。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                return { type: (0, types_js_1.p_type)('undefined') };
            }
            else if (isModuleDecl) {
                isOverwritingDeclation = true;
                existingSymbol.node = node;
                if (node.name.loc) {
                    existingSymbol.definedAt = node.name.loc;
                }
            }
            else {
                this.addDiagnostic(node.name, `関数 '${funcName}' はこのスコープで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
        this.checkFunctionNameConvention(node.name);
        // 関数の型情報を作成する。
        const parameterTypes = node.parameters.map((p, i) => ({
            name: p.name,
            type: parameterOverrideTypes && parameterOverrideTypes[i] ? parameterOverrideTypes[i] : (0, types_js_1.p_type)('parameter')
        }));
        const functionType = {
            kind: 'function',
            parameters: parameterTypes,
            returnType: (0, types_js_1.p_type)('any'), // 戻り値は後で解析する
            behavior: 'callable_and_symbol'
        };
        // シンボルテーブルに関数を登録する
        if (node.loc) {
            if (!existingSymbol) {
                const newSymbol = {
                    name: funcName,
                    type: functionType,
                    definedAt: node.name.loc,
                    node,
                    declaredFilePath: this.currentFilePath ?? undefined,
                    isUsed: false
                };
                this.symbolTable.currentScope.define(newSymbol);
                if (this.currentModule && this.currentModuleScope === this.symbolTable.currentScope) {
                    this.currentModule.members.set(funcName, newSymbol);
                }
            }
            else if (isOverwritingDeclation) {
                existingSymbol.type = functionType;
            }
        }
        this.visit(node.name);
        // ヘッダーモードなら関数の中身の解析はスキップ
        if (this.isHeaderMode) {
            node.parameters.forEach(param => this.visit(param));
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // --- 関数ボディの解析 ---
        const oldFunction = this.currentFunction;
        this.currentFunction = node;
        this.symbolTable.enterScope(node);
        node.parameters.forEach((param, i) => {
            if (param.loc) {
                this.checkVariableNameConvention(param);
                const paramSymbol = { name: param.name, type: functionType.parameters[i].type, definedAt: param.loc, node: param, isUsed: false, isFunctionArgument: true, declaredFilePath: this.currentFilePath ?? undefined };
                this.symbolTable.currentScope.define(paramSymbol);
                // Explicitly visit the parameter name node to set its resolvedSymbol
                this.visit(param);
            }
        });
        this.visit(node.body);
        this.symbolTable.exitScope();
        this.currentFunction = oldFunction; // null?
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitFormDeclaration(node) {
        const funcName = node.name.name;
        // 関数名チェック
        this.checkFunctionNameConvention(node.name);
        if (this.symbolTable.currentScope.lookupCurrentScope(funcName)) {
            this.addDiagnostic(node.name, `シンボル '${funcName}' はこのスコープで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
        // 引数名チェック
        for (const param of node.parameters) {
            if (param.name.match(/^(?:[A-Z]|_[A-Z])/)) {
                this.addDiagnostic(param, `前方宣言の引数名 '${param.name}' に大文字で始まる変数は使用できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
        // シンボルテーブルに登録
        const functionType = {
            kind: 'function',
            parameters: node.parameters.map(p => ({ name: p.name, type: (0, types_js_1.p_type)('any') })),
            returnType: (0, types_js_1.p_type)('form'),
            behavior: 'callable_and_symbol'
        };
        if (node.loc) {
            this.symbolTable.currentScope.define({
                name: funcName,
                type: functionType,
                definedAt: node.loc,
                node,
                isUsed: false
            });
        }
        this.visit(node.name);
        node.parameters.forEach(param => {
            this.visit(param);
        });
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitIndeterminate(node) {
        const name = node.name;
        const symbol = this.symbolTable.currentScope.lookup(name);
        // キーワードをチェック
        if (builtins_js_1.ASIR_KEYWORDS.includes(name)) {
            this.addDiagnostic(node, `'${name}' はキーワードであり、式の中では使用できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('any') };
        }
        // 変数・関数としてシンボルテーブルに登録されていないか探す
        if (symbol) {
            node.resolvedSymbol = symbol;
            symbol.isUsed = true;
            return { type: symbol.type, constantValue: symbol.constantValue };
        }
        // 組み込み関数をチェック
        if (builtinSignatures_js_1.BUILTIN_SIGNATURES.has(name)) {
            return { type: builtinSignatures_js_1.BUILTIN_SIGNATURES.get(name) };
        }
        // 組み込み定数をチェック
        if (builtinConstants_js_1.BUILTIN_CONSTANTS.has(name)) {
            return { type: builtinConstants_js_1.BUILTIN_CONSTANTS.get(name) };
        }
        // 詳細不明な組み込み関数
        if (builtins_js_1.ALL_ASIR_BUILTIN.includes(name)) {
            this.addDiagnostic(node, `組み込み関数 '${name}' の型シグネチャは未定義です。型チェックは行われません。`, diagnostics_js_1.DiagnosticSeverity.Information);
            const genericFunctionType = {
                kind: 'function',
                parameters: [],
                restParameter: { name: 'args', type: (0, types_js_1.p_type)('any') },
                returnType: (0, types_js_1.p_type)('any'),
                behavior: 'callable_and_symbol'
            };
            return { type: genericFunctionType };
        }
        // シンボルテーブルにない場合
        if (name.match(/^(?:[A-Z]|_[A-Z])/)) {
            this.addDiagnostic(node, `未定義の変数 '${name}' が参照されました。暗黙的に 0 として扱われます。`, diagnostics_js_1.DiagnosticSeverity.Warning);
            // return { type: p_type('integer'), constantValue: 0};
            return { type: (0, types_js_1.p_type)('parameter') };
        }
        else {
            return { type: (0, types_js_1.p_type)('indeterminate') };
        }
    }
    visitFunctionCall(node) {
        const calleeNode = node.callee;
        const funcName = calleeNode.functionName.name;
        this.visit(calleeNode.functionName);
        const argResults = [];
        for (let i = 0; i < node.args.length; i++) {
            const arg = node.args[i];
            const argResult = this.visit(arg) || { type: (0, types_js_1.p_type)('any') };
            argResults.push(argResult);
        }
        if (index_js_1.builtinHandlers.has(funcName)) {
            const handler = index_js_1.builtinHandlers.get(funcName);
            return handler(this, node, argResults);
        }
        const calleeResult = this.visit(calleeNode.functionName);
        const actualArgTypes = argResults.map(r => r.type);
        let calleeType = calleeResult?.type;
        let funcSymbol;
        // --- 呼び出し方に応じたロジック ---
        if (node.isGlobal) {
            if (calleeNode.moduleName) {
                this.addDiagnostic(node, `'::' と '.'を同時に使用することはできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
            const globalScope = this.symbolTable.getRootScope();
            funcSymbol = globalScope.lookup(funcName);
            calleeType = funcSymbol?.type;
            if (!calleeType && builtinSignatures_js_1.BUILTIN_SIGNATURES.has(funcName)) {
                calleeType = builtinSignatures_js_1.BUILTIN_SIGNATURES.get(funcName);
            }
        }
        else if (calleeNode.moduleName) {
            const moduleName = calleeNode.moduleName.name;
            this.visit(calleeNode.moduleName);
            const moduleSymbol = this.symbolTable.currentScope.lookup(moduleName);
            if (!moduleSymbol) {
                this.addDiagnostic(calleeNode.moduleName, `モジュール '${moduleName}' は定義されていません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
            if (moduleSymbol.type.kind !== 'module') {
                this.addDiagnostic(calleeNode.moduleName, `'${moduleName}' はモジュールではありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
            funcSymbol = moduleSymbol.type.members.get(funcName);
            calleeType = funcSymbol?.type;
        }
        else {
            funcSymbol = this.symbolTable.currentScope.lookup(funcName);
            if (funcSymbol) {
                calleeType = funcSymbol.type;
            }
            else if (builtinSignatures_js_1.BUILTIN_SIGNATURES.has(funcName)) {
                calleeType = builtinSignatures_js_1.BUILTIN_SIGNATURES.get(funcName);
            }
        }
        // --- 型チェック ---
        if (!calleeType) {
            this.addDiagnostic(calleeNode.functionName, `関数 '${funcName}' は定義されていません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('any') };
        }
        if (calleeType.kind === 'union') {
            const funcPart = calleeType.types.find(t => t.kind === 'function' || t.kind === 'overloaded_function');
            if (funcPart) {
                calleeType = funcPart;
            }
        }
        // 引数が一定の関数のチェック
        if (calleeType.kind === 'function') {
            if (funcSymbol && funcSymbol.node && funcSymbol.node.kind === 'FunctionDefinition') {
                const inferredReturnType = this.analyzeFunctionBodyWithArgs(funcSymbol.node, actualArgTypes);
                this.validateOptions(funcName, calleeType.allowesOptions, node.options);
                return { type: inferredReturnType };
            }
            const expectedParams = calleeType.parameters;
            const restParam = calleeType.restParameter;
            if (restParam) {
                if (actualArgTypes.length < expectedParams.length) {
                    this.addDiagnostic(node, `引数の数が足りません。少なくとも ${expectedParams.length} 個の引数が必要ですが、${argResults.length}個が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
            }
            else {
                if (actualArgTypes.length !== expectedParams.length) {
                    this.addDiagnostic(node, `引数の数が一致しません。 ${expectedParams.length} 個の引数が必要ですが、 ${argResults.length} 個が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
            }
            // 各固定引数の型をチェック
            const fixedArgCount = Math.min(actualArgTypes.length, expectedParams.length);
            for (let i = 0; i < fixedArgCount; i++) {
                if (node.args[i].kind === 'Indeterminate') {
                    const argName = node.args[i].name;
                    const symbol = this.symbolTable.currentScope.lookup(argName);
                    if (symbol && symbol.isFunctionArgument && symbol.type.kind === 'primitive' && symbol.type.name === 'parameter') {
                        if (!(expectedParams[i].type.kind === 'primitive' && expectedParams[i].type.name === 'any')) {
                            symbol.type = expectedParams[i].type;
                            actualArgTypes[i] = symbol.type;
                        }
                    }
                }
                this.checkUsageAsValue(actualArgTypes[i], actualArgTypes[i]);
                if (!(0, typeSystem_js_1.isTypeCompatible)(actualArgTypes[i], expectedParams[i].type)) {
                    this.addDiagnostic(node.args[i], `引数${i + 1}の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(expectedParams[i].type)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(actualArgTypes[i])}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                }
            }
            // 可変長引数の型チェック
            if (restParam) {
                for (let i = fixedArgCount; i < actualArgTypes.length; i++) {
                    if (!(0, typeSystem_js_1.isTypeCompatible)(actualArgTypes[i], restParam.type)) {
                        this.addDiagnostic(node.args[i], `引数${i + 1}の型が一致しません。型 '${(0, typeFormatter_js_1.typeToString)(restParam.type)}' が必要ですが、型 '${(0, typeFormatter_js_1.typeToString)(actualArgTypes[i])}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
                    }
                }
            }
            this.validateOptions(funcName, calleeType.allowesOptions, node.options);
            return { type: calleeType.returnType };
        }
        // 引数の数が可変の関数のチェック（Overloaded Function）
        if (calleeType.kind === 'overloaded_function') {
            const matchingSignature = calleeType.signatures.find(sig => {
                // 引数の数チェック
                if (sig.restParameter) {
                    if (actualArgTypes.length < sig.parameters.length) {
                        return false;
                    }
                }
                else {
                    if (actualArgTypes.length !== sig.parameters.length) {
                        return false;
                    }
                }
                // 固定引数の型チェック
                const fixedArgsMatch = sig.parameters.every((expectedParam, i) => {
                    return (0, typeSystem_js_1.isTypeCompatible)(actualArgTypes[i], expectedParam.type);
                });
                if (!fixedArgsMatch) {
                    return false;
                }
                // 可変長引数の型チェック
                if (sig.restParameter) {
                    for (let i = sig.parameters.length; i < actualArgTypes.length; i++) {
                        if (!(0, typeSystem_js_1.isTypeCompatible)(actualArgTypes[i], sig.restParameter.type)) {
                            return false;
                        }
                    }
                }
                return true;
            });
            if (matchingSignature) {
                this.validateOptions(funcName, matchingSignature.allowesOptions, node.options);
                return { type: matchingSignature.returnType };
            }
            else {
                const argTypesString = actualArgTypes.map(t => (0, typeFormatter_js_1.typeToString)(t)).join(', ');
                this.addDiagnostic(node, `${funcName} に引数 ${argTypesString} にマッチする定義が見つかりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
        }
        // 関数でないものを呼び出す場合はエラーを返す
        this.addDiagnostic(calleeNode.functionName, `'${funcName}' は関数として呼び出せません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
    visitBinaryOperation(node) {
        const leftResult = this.visit(node.left) || { type: (0, types_js_1.p_type)('any') };
        const rightResult = this.visit(node.right) || { type: (0, types_js_1.p_type)('any') };
        const leftType = leftResult.type;
        const rightType = rightResult.type;
        const operator = node.operator;
        const isLeftAny = leftType.kind === 'primitive' && leftType.name === 'any';
        const isRightAny = rightType.kind === 'primitive' && rightType.name === 'any';
        // union型の処理
        if (leftType.kind === 'union' || rightType.kind === 'union') {
            const leftTypes = leftType.kind === 'union' ? leftType.types : [leftType];
            const rightTypes = rightType.kind === 'union' ? rightType.types : [rightType];
            const possibleResultTypes = [];
            for (const lType of leftTypes) {
                for (const rType of rightTypes) {
                    possibleResultTypes.push((0, operatorLogic_js_1.getBinaryOperationResultType)(lType, rType, operator));
                }
            }
            const finalType = (0, typeSystem_js_1.getCommonSupertype)(possibleResultTypes);
            if (finalType.kind === 'primitive' && finalType.name === 'any') {
                this.addDiagnostic(node, `演算子 '${operator}' は、型 '${(0, typeFormatter_js_1.typeToString)(leftType)}' と '${(0, typeFormatter_js_1.typeToString)(rightType)}' の組み合わせの一部に適用できない可能性があります。`, diagnostics_js_1.DiagnosticSeverity.Warning);
            }
            return { type: finalType };
        }
        // parameter の型推論
        const isLeftParameter = leftType.kind === 'primitive' && leftType.name === 'parameter';
        const isRightParameter = rightType.kind === 'primitive' && rightType.name === 'parameter';
        if (['+', '-', '*', '/', '%', '<', '>', '<=', '>='].includes(operator)) {
            if (isLeftParameter && !isRightParameter && (0, typeSystem_js_1.isSubtypeOf)(rightType.kind === 'primitive' ? rightType.name : 'number', 'number')) {
                if (node.left.kind === 'Indeterminate') {
                    const symbol = this.symbolTable.currentScope.lookup(node.left.name);
                    if (symbol && symbol.type.kind === 'primitive' && symbol.type.name === 'parameter') {
                        symbol.type = (0, types_js_1.p_type)('integer');
                    }
                }
            }
            else if (!isLeftParameter && isRightParameter && (0, typeSystem_js_1.isSubtypeOf)(leftType.kind === 'primitive' ? leftType.name : 'number', 'number')) {
                if (node.right.kind === 'Indeterminate') {
                    const symbol = this.symbolTable.currentScope.lookup(node.right.name);
                    if (symbol && symbol.type.kind === 'primitive' && symbol.type.name === 'parameter') {
                        symbol.type = (0, types_js_1.p_type)('integer');
                    }
                }
            }
        }
        this.checkUsageAsValue(node.left, leftType);
        this.checkUsageAsValue(node.right, rightType);
        if (operator.startsWith('@')) {
            this.visit(node.left);
            this.visit(node.right);
        }
        if (operator === '%') {
            const isRightInt = rightType.kind === 'primitive' && rightType.name === 'integer';
            if (!isRightInt) {
                this.addDiagnostic(node.right, `演算子 '%' の右辺は整数である必要がありますが、型 '${(0, typeFormatter_js_1.typeToString)(rightType)}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
            const isLeftInt = leftType.kind === 'primitive' && leftType.name === 'integer';
            const isLeftPolyOfInt = leftType.kind === 'standard_polynomial' && leftType.coefficientType.kind === 'primitive' && leftType.coefficientType.name === 'integer';
            if (!isLeftInt && !isLeftPolyOfInt) {
                this.addDiagnostic(node.left, `演算子 '%' の左辺は、整数または整数係数多項式である必要がありますが、型 '${(0, typeFormatter_js_1.typeToString)(leftType)}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
        if (['==', '!='].includes(operator)) {
            const warningDetails = (0, operatorLogic_js_1.checkNumericTypeMismatch)(leftType, rightType);
            if (warningDetails) {
                this.addDiagnostic(node, `${warningDetails} を '${operator}' で比較しています。比較は可能ですが、意図しない問題が発生する可能性があります。`, diagnostics_js_1.DiagnosticSeverity.Warning);
            }
        }
        if (['<', '>', '<=', '>=', '&&', '||'].includes(operator)) {
            if (leftType.kind === 'primitive' && rightType.kind === 'primitive') {
                if (!isLeftParameter && !isRightParameter && !isLeftAny && !isRightAny) {
                    const isNumeric = (0, typeSystem_js_1.isSubtypeOf)(leftType.name, 'number') && (0, typeSystem_js_1.isSubtypeOf)(rightType.name, 'number');
                    const isString = leftType.name === 'string' && rightType.name === 'string';
                    if (!isNumeric && !isString) {
                        this.addDiagnostic(node, `この演算は意図しない値を返す可能性があります。型 '${(0, typeFormatter_js_1.typeToString)(leftType)}' と型 '${(0, typeFormatter_js_1.typeToString)(rightType)}' の間での '${operator}' 演算は意図しない結果になる可能性があります。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                }
            }
            else {
                this.addDiagnostic(node, `この演算は意図しない値を返す可能性があります。型 '${(0, typeFormatter_js_1.typeToString)(leftType)}' と型 '${(0, typeFormatter_js_1.typeToString)(rightType)}' の間での '${operator}' 演算は意図しない結果になる可能性があります。`, diagnostics_js_1.DiagnosticSeverity.Warning);
            }
        }
        const resultType = (0, operatorLogic_js_1.getBinaryOperationResultType)(leftType, rightType, operator);
        if (resultType.kind === 'primitive' && resultType.name === 'any') {
            if (!isLeftAny && !isRightAny && !isLeftParameter && !isRightParameter) {
                this.addDiagnostic(node, `演算子 '${operator}' は、型 '${(0, typeFormatter_js_1.typeToString)(leftType)}' と '${(0, typeFormatter_js_1.typeToString)(rightType)}' には適用できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
        }
        // 定数畳み込み
        let constantValue = undefined;
        const leftConst = leftResult.constantValue;
        const rightConst = rightResult.constantValue;
        if (typeof leftConst === 'number' && typeof rightConst === 'number') {
            switch (operator) {
                case '+':
                    constantValue = leftConst + rightConst;
                    break;
                case '-':
                    constantValue = leftConst - rightConst;
                    break;
                case '*':
                    constantValue = leftConst * rightConst;
                    break;
                case '/':
                    if (rightConst !== 0)
                        constantValue = leftConst / rightConst;
                    break;
                case '%':
                    if (rightConst !== 0)
                        constantValue = leftConst % rightConst;
                    break;
                case '==':
                    constantValue = (leftConst === rightConst) ? 1 : 0;
                    break;
                case '!=':
                    constantValue = (leftConst !== rightConst) ? 1 : 0;
                    break;
                case '<':
                    constantValue = (leftConst < rightConst) ? 1 : 0;
                    break;
                case '>':
                    constantValue = (leftConst > rightConst) ? 1 : 0;
                    break;
                case '<=':
                    constantValue = (leftConst <= rightConst) ? 1 : 0;
                    break;
                case '>=':
                    constantValue = (leftConst >= rightConst) ? 1 : 0;
                    break;
                case '&&':
                    constantValue = (leftConst !== 0 && rightConst !== 0) ? 1 : 0;
                    break;
                case '||':
                    constantValue = (leftConst !== 0 || rightConst !== 0) ? 1 : 0;
                    break;
            }
        }
        return { type: resultType, constantValue };
    }
    visitUnaryOperation(node) {
        const operandResult = this.visit(node.operand);
        if (!operandResult) {
            return { type: (0, types_js_1.p_type)('any') };
        }
        if (operandResult.type.kind === 'primitive' && operandResult.type.name === 'parameter') {
            return { type: (0, types_js_1.p_type)('parameter') };
        }
        this.checkUsageAsValue(node.operand, operandResult.type);
        let resultType = operandResult.type;
        let constantValue = undefined;
        switch (node.operator) {
            case '++':
            case '--':
            case '-':
                const isNumeric = operandResult.type.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(operandResult.type.name, 'number');
                const isPolyVar = operandResult.type.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(operandResult.type.name, 'pp');
                const isPolynomial = (0, typeSystem_js_1.isPolynomialType)(operandResult.type);
                if (!(isNumeric || isPolyVar || isPolynomial)) {
                    this.addDiagnostic(node.operand, `演算子 '${node.operator}' は数値または多項式にのみ適用できます。`, diagnostics_js_1.DiagnosticSeverity.Error);
                    if (node.operator === '-' && typeof operandResult.constantValue === 'number') {
                        constantValue = -operandResult.constantValue;
                    }
                    resultType = operandResult.type;
                    break;
                }
                break;
            case '!':
                if (node.isPostfix) {
                    if (operandResult.type.kind === 'primitive') {
                        if (operandResult.type.name === 'integer') {
                            resultType = (0, types_js_1.p_type)('integer');
                        }
                        else if ((0, typeSystem_js_1.isSubtypeOf)(operandResult.type.name, 'pp')) {
                            resultType = (0, types_js_1.p_type)('form');
                        }
                        else {
                            resultType = (0, types_js_1.p_type)('form');
                        }
                    }
                    else {
                        resultType = (0, types_js_1.p_type)('form');
                    }
                }
                else {
                    resultType = (0, types_js_1.p_type)('integer');
                }
                break;
            case '`':
                resultType = (0, types_js_1.p_type)('quote');
                break;
            default:
                resultType = operandResult.type;
                break;
        }
        return { type: resultType, constantValue: constantValue };
    }
    visitTernaryOperation(node) {
        const conditionResult = this.visit(node.condition);
        const consequenceResult = this.visit(node.consequence) || { type: (0, types_js_1.p_type)('any') };
        const alternativeResult = this.visit(node.alternative) || { type: (0, types_js_1.p_type)('any') };
        this.checkUsageAsValue(node.consequence, consequenceResult.type);
        this.checkUsageAsValue(node.alternative, alternativeResult.type);
        const resultType = (0, typeSystem_js_1.getCommonSupertype)([consequenceResult.type, alternativeResult.type]);
        let constantValue = undefined;
        if (conditionResult?.constantValue !== undefined) {
            if (conditionResult.constantValue) {
                constantValue = consequenceResult.constantValue;
            }
            else {
                constantValue = alternativeResult.constantValue;
            }
        }
        else {
            if (consequenceResult.constantValue !== undefined && consequenceResult.constantValue === alternativeResult.constantValue) {
                constantValue = conditionResult?.constantValue;
            }
        }
        return { type: resultType, constantValue };
    }
    visitPowerOperation(node) {
        const baseResult = this.visit(node.base);
        const exponentResult = this.visit(node.exponent);
        if (!baseResult || !exponentResult) {
            return { type: (0, types_js_1.p_type)('any') };
        }
        const baseType = baseResult.type;
        const exponentType = exponentResult.type;
        this.checkUsageAsValue(node.base, baseType);
        this.checkUsageAsValue(node.exponent, exponentType);
        let resultType = (0, types_js_1.p_type)('any');
        let constantValue = undefined;
        // 定数畳み込み
        const baseConst = baseResult.constantValue;
        const expConst = exponentResult.constantValue;
        if (typeof baseConst === 'number' && typeof expConst === 'number') {
            constantValue = Math.pow(baseConst, expConst);
        }
        const exponentValue = this.getIntegerLiteralValue(node.exponent);
        const baseNode = node.base;
        const isBaseI = (baseNode.kind === 'NumberLiteral' && baseNode.rawText === '@i');
        if (isBaseI) {
            if (exponentValue !== null) {
                if (exponentValue === 0) {
                    return { type: (0, types_js_1.p_type)('integer'), constantValue: 1 };
                }
                const isEven = exponentValue % 2 === 0;
                if (isEven) {
                    constantValue = (exponentValue / 2) % 2 === 1 ? -1 : 1;
                    return { type: (0, types_js_1.p_type)('integer'), constantValue: constantValue };
                }
                else {
                    return { type: (0, types_js_1.p_type)('complex') };
                }
            }
            if (exponentType.kind === 'primitive' && exponentType.name === 'integer') {
                return { type: (0, types_js_1.p_type)('complex') };
            }
            return { type: (0, types_js_1.p_type)('form') };
        }
        if (exponentValue === 0) {
            return { type: (0, types_js_1.p_type)('integer'), constantValue: 1 };
        }
        const isBaseNumeric = baseType.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(baseType.name, 'number');
        const isBaseStdPoly = baseType.kind === 'standard_polynomial';
        const isBaseParameter = baseType.kind === 'primitive' && baseType.name === 'parameter';
        const isBasePolyVar = baseType.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(baseType.name, 'pp');
        if (!isBaseNumeric && !isBaseStdPoly && !isBaseParameter && !isBasePolyVar) {
            this.addDiagnostic(node.base, `演算子 '^' の底は、数値または多項式で得ある必要がありますが、 型 '${(0, typeFormatter_js_1.typeToString)(baseType)}' が指定されました。`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('any') };
        }
        if (isBaseParameter && node.base.kind === 'Indeterminate') {
            const symbol = this.symbolTable.currentScope.lookup(node.base.name);
            if (symbol && symbol.type.kind === 'primitive' && symbol.type.name === 'parameter') {
                symbol.type = (0, types_js_1.p_type)('integer');
            }
        }
        if (exponentValue !== null) {
            if (exponentValue > 0) {
                resultType = isBaseParameter ? (0, types_js_1.p_type)('number') : baseType;
            }
            else {
                if (baseType.kind === 'primitive' && baseType.name === 'integer') {
                    resultType = (0, types_js_1.p_type)('rational');
                }
                if (baseType.kind === 'standard_polynomial') {
                    resultType = (0, types_js_1.rat_type)(baseType.coefficientType);
                }
                if (isBasePolyVar) {
                    resultType = (0, types_js_1.stdpoly_type)((0, types_js_1.p_type)('integer'));
                }
                resultType = isBaseParameter ? (0, types_js_1.p_type)('number') : baseType;
            }
        }
        else if (exponentType.kind === 'primitive' && exponentType.name === 'integer') {
            const possibleTypes = [baseType, (0, types_js_1.p_type)('integer')];
            if (baseType.kind === 'primitive' && baseType.name === 'integer') {
                possibleTypes.push((0, types_js_1.p_type)('rational'));
            }
            else if (baseType.kind === 'standard_polynomial') {
                possibleTypes.push((0, types_js_1.rat_type)(baseType.coefficientType));
            }
            else if (isBasePolyVar) {
                resultType = (0, types_js_1.rat_type)((0, types_js_1.p_type)('integer'));
            }
            else {
                possibleTypes.push(baseType);
            }
            resultType = (0, typeSystem_js_1.getCommonSupertype)(possibleTypes);
        }
        else {
            resultType = (0, types_js_1.p_type)('form');
        }
        return { type: resultType, constantValue };
    }
    visitIndexAccess(node) {
        // dead code 内では厳密な検証をスキップする
        if (!this.isReachable) {
            this.visit(node.base);
            node.indices.forEach(i => this.visit(i));
            return { type: (0, types_js_1.p_type)('any'), baseNode: node.base, accessPath: [], accessedType: (0, types_js_1.p_type)('any'), indices: node.indices };
        }
        const baseResult = this.visit(node.base);
        let currentType = (0, types_js_1.p_type)('any');
        let currentConstantValue = undefined;
        let baseNode = node.base;
        let accessPath = [];
        if (baseResult && 'baseNode' in baseResult && 'accessPath' in baseResult) {
            const nestedIndexAccessResult = baseResult;
            baseNode = nestedIndexAccessResult.baseNode;
            accessPath = nestedIndexAccessResult.accessPath;
            currentType = nestedIndexAccessResult.accessedType;
            currentConstantValue = nestedIndexAccessResult.accessedConstantValue;
        }
        else if (baseResult) {
            currentType = baseResult.type;
            currentConstantValue = baseResult.constantValue;
        }
        accessPath.push(node);
        // if (baseNode.kind === 'IndexAccess') {
        //     // インデックスアクセスのインデックスアクセスで変数の型が不明な場合、行列とする。
        //     const innerBaseNode = (baseNode as ast.IndexAccessNode).base;
        //     if (innerBaseNode.kind === 'Indeterminate') {
        //         const symbol = this.symbolTable.currentScope.lookup(innerBaseNode.name);
        //         if (symbol && (symbol.type.kind === 'primitive' && symbol.type.name === 'parameter')) {
        //             symbol.type = m_type(p_type('any'));
        //         }
        //     }
        // } 
        // インデックスアクセスの変数の型が不明な場合、行列かベクトルか、リストと見なす。
        if (baseResult.type.kind === 'primitive' && baseResult.type.name === 'parameter') {
            const newType = (0, types_js_1.u_type)([(0, types_js_1.m_type)((0, types_js_1.p_type)('any')), (0, types_js_1.v_type)((0, types_js_1.p_type)('any')), (0, types_js_1.l_type)((0, types_js_1.p_type)('any'))]);
            if (node.base.kind === 'Indeterminate') {
                const symbol = this.symbolTable.currentScope.lookup(node.base.name);
                if (symbol && (symbol.type.kind === 'primitive' && symbol.type.name === 'parameter')) {
                    symbol.type = newType;
                }
            }
            currentType = newType;
        }
        let currentResult = { type: currentType, constantValue: baseResult.constantValue };
        for (const indexNode of node.indices) {
            const indexResult = this.visit(indexNode) || { type: (0, types_js_1.p_type)('any') };
            const indexType = indexResult.type;
            const isParameter = indexType.kind === 'primitive' && indexType.name === 'parameter';
            const isInteger = indexType.kind === 'primitive' && (0, typeSystem_js_1.isSubtypeOf)(indexType.name, 'integer');
            if (!isInteger && !isParameter) {
                this.addDiagnostic(indexNode, `インデックスは整数でなければなりません。`, diagnostics_js_1.DiagnosticSeverity.Error);
            }
            const currentType = currentResult.type;
            let nextType = (0, types_js_1.p_type)('any');
            let nextConstantValue = undefined;
            if (currentType.kind === 'primitive' && currentType.name === 'any') {
                currentResult = { type: (0, types_js_1.p_type)('any'), constantValue: undefined };
                continue;
            }
            switch (currentType.kind) {
                case 'matrix':
                    nextType = { kind: 'vector', elementType: currentType.elementType };
                    break;
                case 'vector':
                case 'list':
                    nextType = currentType.elementType;
                    break;
                case 'tuple': {
                    const indexValue = (typeof indexResult.constantValue === 'number' && Number.isInteger(indexResult.constantValue)) ? indexResult.constantValue : null;
                    if (indexValue !== null) {
                        if (indexValue >= 0 && indexValue < currentType.elements.length) {
                            nextType = currentType.elements[indexValue].type;
                            if (Array.isArray(currentResult.constantValue)) {
                                const elementConst = currentResult.constantValue[indexValue];
                                if (elementConst !== undefined && elementConst !== null) {
                                    nextConstantValue = elementConst;
                                }
                            }
                        }
                        else {
                            this.addDiagnostic(indexNode, `リストのインデックス '${indexValue}' が範囲外です。`, diagnostics_js_1.DiagnosticSeverity.Error);
                            nextType = (0, types_js_1.p_type)('any');
                        }
                    }
                    else {
                        const elementTypes = currentType.elements.map(e => e.type);
                        nextType = (0, typeSystem_js_1.getCommonSupertype)(elementTypes);
                    }
                    break;
                }
                case 'union': {
                    const possibleResultTypes = [];
                    // Filter out non-indexable types from the union before processing
                    const indexableMemberTypes = currentType.types.filter(memberType => memberType.kind === 'matrix' || memberType.kind === 'vector' || memberType.kind === 'list' || memberType.kind === 'tuple');
                    if (indexableMemberTypes.length === 0) {
                        this.addDiagnostic(node.base, `型 '${(0, typeFormatter_js_1.typeToString)(currentType)}' のどの要素に対してもインデックスアクセスはできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        return { type: (0, types_js_1.p_type)('any'), baseNode: baseNode, accessPath: accessPath, accessedType: currentResult.type, indices: node.indices };
                    }
                    for (const memberType of indexableMemberTypes) {
                        switch (memberType.kind) {
                            case 'matrix':
                                possibleResultTypes.push({ kind: 'vector', elementType: memberType.elementType });
                                break;
                            case 'vector':
                            case 'list':
                                possibleResultTypes.push(memberType.elementType);
                                break;
                            case 'tuple':
                                const indexValue = (typeof indexResult.constantValue === 'number' && Number.isInteger(indexResult.constantValue)) ? indexResult.constantValue : null;
                                if (indexValue !== null) {
                                    if (indexValue >= 0 && indexValue < memberType.elements.length) {
                                        possibleResultTypes.push(memberType.elements[indexValue].type);
                                    }
                                }
                                else {
                                    const elementTypes = memberType.elements.map(e => e.type);
                                    possibleResultTypes.push((0, typeSystem_js_1.getCommonSupertype)(elementTypes));
                                }
                                break;
                        }
                    }
                    nextType = (0, typeSystem_js_1.getCommonSupertype)(possibleResultTypes);
                    break;
                }
                default:
                    this.addDiagnostic(node.base, `型 '${(0, typeFormatter_js_1.typeToString)(currentType)}' に対してインデックスアクセスはできません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                    return { type: (0, types_js_1.p_type)('any'), baseNode: baseNode, accessPath: accessPath, accessedType: currentResult.type, indices: node.indices };
            }
            currentResult = { type: nextType, constantValue: nextConstantValue };
        }
        return { type: currentResult.type, constantValue: currentResult.constantValue, baseNode: baseNode, accessPath: accessPath, accessedType: currentResult.type, accessedConstantValue: currentResult.constantValue, indices: node.indices };
    }
    visitMemberAccess(node) {
        let currentResult = this.visit(node.base);
        if (!currentResult) {
            return { type: (0, types_js_1.p_type)('any') };
        }
        for (const memberIndeterminate of node.members) {
            const currentType = currentResult.type;
            const memberName = memberIndeterminate.name;
            if (currentType.kind !== 'struct') {
                this.addDiagnostic(memberIndeterminate, `'${(0, typeFormatter_js_1.typeToString)(currentType)}' 型にメンバー '${memberName}' はありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
            const memberType = currentType.members.get(memberName);
            if (!memberType) {
                this.addDiagnostic(memberIndeterminate, `構造体 '${currentType.name}' にメンバー '${memberName}' はありません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('any') };
            }
            currentResult = { type: memberType, constantValue: undefined };
        }
        return currentResult;
    }
    // --- 文 ---
    visitBlock(node) {
        const previousIsReachable = this.isReachable;
        for (const stmt of node.statements) {
            if (!this.isReachable || this.isProgramTerminated) {
                if (stmt.kind !== 'EmptyStatement') {
                    this.addDiagnostic(stmt, "到達不能なコードです。", diagnostics_js_1.DiagnosticSeverity.Warning, true);
                }
            }
            const result = this.visit(stmt);
            if (stmt.kind === 'EndStatement' || stmt.kind === 'QuitStatement') {
                this.isProgramTerminated = true;
                this.isReachable = false;
            }
            else if (stmt.kind === 'ReturnStatement' || stmt.kind === 'BreakStatement' || stmt.kind === 'ContinueStatement') {
                this.isReachable = false;
            }
        }
        this.isReachable = previousIsReachable;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitForStatement(node) {
        // for 文の初期化式、条件式、更新式を先に解析
        node.initializers.forEach(init => this.visit(init));
        node.conditions.forEach(cond => this.visit(cond));
        node.updaters.forEach(update => this.visit(update));
        const previousInLoop = this.isInLoop;
        this.isInLoop = true;
        try {
            // this.symbolTable.enterScope(node);
            this.visit(node.body);
            // this.symbolTable.exitScope();
        }
        finally {
            this.isInLoop = previousInLoop;
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitIfStatement(node) {
        const conditionResult = this.visit(node.condition);
        // 条件がfalseならthenをスキップ
        if (conditionResult && conditionResult.constantValue === 0) {
            if (node.elseStatement) {
                this.visit(node.elseStatement);
            }
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // 条件がtrueならelseをスキップ
        if (conditionResult && typeof conditionResult.constantValue === 'number' && conditionResult.constantValue !== 0) {
            if (node.thenStatement.kind === 'Block') {
                const BlockNode = node.thenStatement;
                for (const stmt of BlockNode.statements) {
                    if (!this.isReachable || this.isProgramTerminated) {
                        // 警告にしてもいいかも
                    }
                    this.visit(stmt);
                }
            }
            else {
                this.visit(node.thenStatement);
            }
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // --- Capture pre-branch state ---
        const originalTypes = new Map();
        const symbolsToTrack = this.symbolTable.currentScope.symbols;
        symbolsToTrack.forEach((s) => originalTypes.set(s.name, s.type));
        // --- Type Guard ---
        this.refineTypesFromCondition(node.condition);
        // --- Analyze 'then' branch ---
        this.visit(node.thenStatement);
        const thenTypes = new Map();
        symbolsToTrack.forEach((s) => {
            if (!(0, typeSystem_js_1.areTypesDeeplyEqual)(originalTypes.get(s.name), s.type)) {
                thenTypes.set(s.name, s.type);
            }
        });
        // --- Restore state for 'else' branch ---
        symbolsToTrack.forEach((s) => {
            const originalType = originalTypes.get(s.name);
            if (originalType) {
                s.type = originalType;
            }
        });
        // --- Analyze 'else' branch ---
        const elseTypes = new Map();
        if (node.elseStatement) {
            this.visit(node.elseStatement);
            symbolsToTrack.forEach((s) => {
                if (!(0, typeSystem_js_1.areTypesDeeplyEqual)(originalTypes.get(s.name), s.type)) {
                    elseTypes.set(s.name, s.type);
                }
            });
        }
        // --- Restore state before merging ---
        symbolsToTrack.forEach((s) => {
            const originalType = originalTypes.get(s.name);
            if (originalType) {
                s.type = originalType;
            }
        });
        // --- Merge and apply final types ---
        const allModifiedVars = new Set([...thenTypes.keys(), ...elseTypes.keys()]);
        allModifiedVars.forEach(name => {
            const symbol = this.symbolTable.currentScope.lookup(name);
            const originalType = originalTypes.get(name);
            const thenType = thenTypes.get(name);
            const elseType = elseTypes.get(name);
            const typesToMerge = [];
            if (thenType && elseType) {
                typesToMerge.push(thenType, elseType);
            }
            else if (thenType) {
                typesToMerge.push(thenType);
                if (originalType) {
                    typesToMerge.push(thenType);
                }
            }
            else if (elseType) {
                typesToMerge.push(originalType, elseType);
                if (originalType) {
                    typesToMerge.push(originalType);
                }
            }
            const filteredTypes = typesToMerge.filter((t) => t !== undefined);
            if (typesToMerge.length > 0) {
                symbol.type = (0, typeSystem_js_1.getCommonSupertype)(filteredTypes);
            }
            else {
                if (originalType) {
                    symbol.type = originalType;
                }
                else {
                    symbol.type = (0, types_js_1.p_type)('any');
                }
            }
        });
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitWhileStatement(node) {
        if (node.body.kind === 'Block') { // while の条件式に未定義の関数がある場合に本体を先に確認する
            for (const stmt of node.body.statements) {
                if (stmt.kind === 'ExpressionStatement' && stmt.expression.kind === 'AssignmentExpression') {
                    const assignment = stmt.expression;
                    if (assignment.left.kind === 'Indeterminate') {
                        const varName = assignment.left.name;
                        if (!this.symbolTable.currentScope.lookup(varName)) {
                            this.symbolTable.currentScope.define({
                                name: varName,
                                type: (0, types_js_1.p_type)('parameter'),
                                definedAt: assignment.left.loc,
                                node: assignment.left,
                                isUsed: true
                            });
                        }
                    }
                }
            }
        }
        node.conditions.forEach(cond => this.visit(cond));
        const previousInLoop = this.isInLoop;
        this.isInLoop = true;
        try {
            this.visit(node.body);
        }
        finally {
            this.isInLoop = previousInLoop;
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitEndStatement(node) {
        this.isProgramTerminated = true;
        this.isReachable = false;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitQuitStatement(node) {
        this.isProgramTerminated = true;
        this.isReachable = false;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitDebugStatement(node) {
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitDoWhileStatement(node) {
        const previousInLoop = this.isInLoop;
        this.isInLoop = true;
        try {
            this.visit(node.body);
        }
        finally {
            this.isInLoop = previousInLoop;
        }
        node.conditions.forEach(cond => this.visit(cond));
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitBreakStatement(node) {
        if (!this.isInLoop) {
            this.addDiagnostic(node, `'break' 文はループの外では使えません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
        this.isReachable = false;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitContinueStatement(node) {
        if (!this.isInLoop) {
            this.addDiagnostic(node, `'continue' 文はループの外では使えません。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
        this.isReachable = false;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitReturnStatement(node) {
        const returnType = node.value ? this.visit(node.value) : { type: (0, types_js_1.p_type)('undefined') };
        if (node.value && returnType) {
            this.checkUsageAsValue(node.value, returnType.type);
        }
        if (!returnType) {
            const safeReturnType = { type: (0, types_js_1.p_type)('any') };
            this.handleReturn(node, safeReturnType.type);
            this.isReachable = false;
            return safeReturnType;
        }
        this.handleReturn(node, returnType.type);
        this.isReachable = false;
        return returnType;
    }
    visitStructStatement(node) {
        const structName = node.name.name;
        // メンバーの情報収集
        const memberMap = new Map();
        for (const memberID of node.members) {
            memberMap.set(memberID.name, (0, types_js_1.p_type)('any'));
        }
        const instanceType = {
            kind: 'struct',
            name: structName,
            members: memberMap
        };
        const defType = {
            kind: 'structure_definition',
            name: structName,
            instanceType: instanceType
        };
        // 構造体の型をシンボルテーブルに登録
        if (node.loc) {
            this.symbolTable.currentScope.define({
                name: structName,
                type: defType,
                definedAt: node.loc,
                node: node,
                declaredFilePath: this.currentFilePath ?? undefined,
                isUsed: false
            });
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    // モジュール関係
    visitModuleDeclaration(node) {
        const moduleName = node.name.name;
        if (this.symbolTable.currentScope.lookupCurrentScope(moduleName)) {
            this.addDiagnostic(node.name, `シンボル '${moduleName}' はこのスコープで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Error);
        }
        const moduleType = {
            kind: 'module',
            name: moduleName,
            members: new Map() // 将来的に拡張するらしい
        };
        if (node.loc) {
            this.symbolTable.currentScope.define({
                name: moduleName,
                type: moduleType,
                definedAt: node.loc,
                node: node,
                isUsed: false,
                declaredFilePath: this.currentFilePath ?? undefined
            });
        }
        this.symbolTable.enterScope(node); // スコープ開始
        this.currentModuleScope = this.symbolTable.currentScope;
        this.currentModule = moduleType;
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitModuleVariableDeclaration(node) {
        const scopeType = node.scope;
        for (const variableNode of node.variables) {
            const varName = variableNode.name;
            const newSymbol = {
                name: varName,
                type: (0, types_js_1.p_type)('any'),
                definedAt: variableNode.loc,
                node: variableNode,
                isUsed: false,
                declaredFilePath: this.currentFilePath ?? undefined
            };
            switch (scopeType) {
                case 'global': {
                    const globalScope = this.symbolTable.getRootScope();
                    if (globalScope.lookupCurrentScope(varName)) {
                        this.addDiagnostic(variableNode, `大域変数 '${varName}' は既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                    else {
                        globalScope.define(newSymbol);
                    }
                    break;
                }
                case 'local': {
                    this.symbolTable.currentScope.hasLocalDeclaration = true;
                    if (this.symbolTable.currentScope.lookupCurrentScope(varName)) {
                        this.addDiagnostic(variableNode, `局所変数 '${varName}' はこのスコープで定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                    else {
                        this.symbolTable.currentScope.define(newSymbol);
                    }
                    break;
                }
                case 'static': {
                    if (!this.currentModuleScope) {
                        this.addDiagnostic(variableNode, `'static' はモジュール内でのみ宣言できます。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        break;
                    }
                    if (this.currentModuleScope.lookupCurrentScope(varName)) {
                        this.addDiagnostic(variableNode, `変数 '${varName}' はこのモジュールで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                    else {
                        this.currentModuleScope.define(newSymbol);
                    }
                    break;
                }
                case 'extern': {
                    if (!this.currentModuleScope || !this.currentModule) {
                        this.addDiagnostic(variableNode, `'extern' はモジュール内でのみ宣言できます。`, diagnostics_js_1.DiagnosticSeverity.Error);
                        break;
                    }
                    if (this.currentModuleScope.lookupCurrentScope(varName)) {
                        this.addDiagnostic(variableNode, `変数 '${varName}' はこのモジュールで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                    else {
                        this.currentModuleScope.define(newSymbol);
                        this.symbolTable.getRootScope().define(newSymbol);
                        this.currentModule.members.set(varName, newSymbol);
                    }
                    break;
                }
                case 'localf': {
                    if (this.symbolTable.currentScope.lookupCurrentScope(varName)) {
                        this.addDiagnostic(variableNode, `関数 '${varName}' はこのスコープで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
                    }
                    else {
                        const funcType = {
                            kind: 'function',
                            parameters: [],
                            returnType: (0, types_js_1.p_type)('any'),
                            behavior: 'callable_and_symbol'
                        };
                        const newSymbol = { name: varName, type: funcType, definedAt: variableNode.loc, node: variableNode, isUsed: false, declaredFilePath: this.currentFilePath ?? undefined };
                        this.symbolTable.currentScope.define(newSymbol);
                        if (this.currentModule) {
                            this.currentModule.members.set(varName, newSymbol);
                        }
                    }
                    break;
                }
            }
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitEndModule(node) {
        this.currentModuleScope = null;
        this.currentModule = null;
        this.symbolTable.exitScope(); // スコープ終了
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    // プリプロセッサ関係
    visitPreprocessorDefine(node) {
        const name = node.name.name;
        // 一先ずの実装
        if (node.parameters.length > 0) {
            this.addDiagnostic(node, `関数のマクロはまだバリデータでサポートされていません。`, diagnostics_js_1.DiagnosticSeverity.Hint);
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        if (this.symbolTable.currentScope.lookupCurrentScope(name)) {
            this.addDiagnostic(node.name, `'${name}' はスコープで既に定義されています。`, diagnostics_js_1.DiagnosticSeverity.Warning);
        }
        const type = this.visit(node.body).type || (0, types_js_1.p_type)('any');
        if (node.name.loc) {
            this.symbolTable.currentScope.define({
                name: name,
                type: type,
                definedAt: node.name.loc,
                node: node,
                isUsed: false
            });
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitPreprocessorInclude(node) {
        let includeFilePath = null;
        if (node.pathtype === 'local') {
            const currentDirectory = this.currentFilePath ? path.dirname(this.currentFilePath) : null;
            if (!currentDirectory) {
                this.addDiagnostic(node, `#include は、起点となるファイルパスが不明な場合は使用できません。`, diagnostics_js_1.DiagnosticSeverity.Error);
                return { type: (0, types_js_1.p_type)('undefined') };
            }
            includeFilePath = path.resolve(currentDirectory, node.path);
        }
        else {
            for (const dir of this.systemIncludePaths) {
                const testPath = path.resolve(dir, node.path);
                if (fs.existsSync(testPath)) {
                    includeFilePath = testPath;
                    break;
                }
            }
        }
        // ファイルが見つからなかった場合
        if (!includeFilePath) {
            this.addDiagnostic(node, `ファイルが見つかりません。： ${node.path}`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // 循環参照チェック
        const resolvedIncludedPath = path.resolve(includeFilePath);
        if (this.inclusionStack.includes(resolvedIncludedPath)) {
            this.addDiagnostic(node, `循環参照が検出されました。： ${this.inclusionStack.join(' -> ')} -> ${resolvedIncludedPath}`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // ファイルを読む
        let includedCode;
        try {
            includedCode = fs.readFileSync(resolvedIncludedPath, 'utf-8');
        }
        catch (e) {
            this.addDiagnostic(node, `#includeされたファイルが読み込めません： ${resolvedIncludedPath}`, diagnostics_js_1.DiagnosticSeverity.Error);
            return { type: (0, types_js_1.p_type)('undefined') };
        }
        // 読んだコードをASTに変換
        const { ast: includedAst, diagnostics: includeDiagnostics } = (0, parserUtils_js_1.parseAndBuildAST)(includedCode, resolvedIncludedPath);
        // this.diagnostics.push(...includeDiagnostics);
        if (includedAst) {
            const previousFilePath = this.currentFilePath;
            this.currentFilePath = resolvedIncludedPath;
            this.inclusionStack.push(resolvedIncludedPath);
            const previousMode = this.isHeaderMode;
            this.isHeaderMode = true;
            const previousReachable = this.isReachable;
            this.isReachable = true;
            const previousProgramTerminated = this.isProgramTerminated;
            this.isProgramTerminated = false;
            try {
                this.visit(includedAst);
            }
            finally {
                this.isHeaderMode = previousMode;
                this.inclusionStack.pop();
                this.currentFilePath = previousFilePath;
                this.isReachable = previousReachable;
                this.isProgramTerminated = previousProgramTerminated;
            }
        }
        return { type: (0, types_js_1.p_type)('undefined') };
    }
    visitParenExpression(node) {
        return this.visit(node.expression);
    }
    // --- リテラル ---
    visitStringLiteral(node) {
        return { type: (0, types_js_1.p_type)('string'), constantValue: node.value };
    }
    visitNumberLiteral(node) {
        const text = node.rawText ?? String(node.value);
        let typeName = 'integer';
        let constantValue = undefined;
        if (text === '@i') {
            typeName = 'complex';
        }
        if (text === '@p') {
            typeName = 'fcharp';
        }
        if (text === '@s') {
            typeName = 'fchardefp';
        }
        if (text === '@') {
            typeName = 'fchar2';
        }
        if (text.includes('/')) {
            typeName = 'rational';
        }
        if (text.includes('.') || text.toLowerCase().includes('e') || text.toLowerCase().includes('E')) {
            typeName = 'float';
        }
        const numVal = Number(node.value);
        if (!isNaN(numVal)) {
            constantValue = numVal;
        }
        return { type: (0, types_js_1.p_type)(typeName), constantValue: constantValue };
    }
    visitDPolyLiteral(node) {
        let resultType;
        if (node.modulus !== undefined) {
            resultType = (0, types_js_1.dpm_type)((0, types_js_1.p_type)('integer'));
        }
        else {
            resultType = (0, types_js_1.dpoly_type)((0, types_js_1.p_type)('integer'));
        }
        return { type: resultType, constantValue: undefined };
    }
    visitListLiteral(node) {
        const elementResults = node.elements.map(el => this.visit(el) || { type: (0, types_js_1.p_type)('any') });
        const elementTypes = [];
        const constantValue = [];
        let isFullyConstant = true;
        for (const result of elementResults) {
            this.checkUsageAsValue(node, result.type);
            elementTypes.push({ type: result.type });
            if (result.constantValue === undefined || Array.isArray(result.constantValue)) {
                isFullyConstant = false;
            }
            if (isFullyConstant) {
                constantValue.push(result.constantValue);
            }
        }
        const tupleType = { kind: 'tuple', elements: elementTypes };
        const finalConstantValue = isFullyConstant ? constantValue : undefined;
        return { type: tupleType, constantValue: finalConstantValue };
    }
    // エラー検知用
    visitDottedIdentifier(node) {
        const fullName = node.identifiers.map(id => id.name).join('.');
        this.addDiagnostic(node, `識別子 '${fullName}' に '.' を含めることは推奨されません。 'module.func()' でモジュール内の関数を呼びだす時に使用してください。`, diagnostics_js_1.DiagnosticSeverity.Error);
        return { type: (0, types_js_1.p_type)('any') };
    }
}
exports.Validator = Validator;
//# sourceMappingURL=validator.js.map

/***/ }),

/***/ "../pasirser/dist/services/languageService.js":
/*!****************************************************!*\
  !*** ../pasirser/dist/services/languageService.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguageService = void 0;
const parserUtils_1 = __webpack_require__(/*! ../core/parser/parserUtils */ "../pasirser/dist/core/parser/parserUtils.js");
const validator_1 = __webpack_require__(/*! ../semantics/validator */ "../pasirser/dist/semantics/validator.js");
// 機能提供関数と関連する型をインポート
const completionProvider_1 = __webpack_require__(/*! ../features/completionProvider */ "../pasirser/dist/features/completionProvider.js");
const hoverProvider_1 = __webpack_require__(/*! ../features/hoverProvider */ "../pasirser/dist/features/hoverProvider.js");
const definitionProvider_1 = __webpack_require__(/*! ../features/definitionProvider */ "../pasirser/dist/features/definitionProvider.js");
const documentSymbolProvider_1 = __webpack_require__(/*! ../features/documentSymbolProvider */ "../pasirser/dist/features/documentSymbolProvider.js");
const renameProvider_1 = __webpack_require__(/*! ../features/renameProvider */ "../pasirser/dist/features/renameProvider.js");
const semanticTokensProvider_1 = __webpack_require__(/*! ../features/semanticTokensProvider */ "../pasirser/dist/features/semanticTokensProvider.js");
const formatter_1 = __webpack_require__(/*! ../features/formatter */ "../pasirser/dist/features/formatter.js");
/**
 * Asir言語のソースコードに対する解析サービスを一元的に提供するクラス。
 * ドキュメントごとにインスタンス化され、解析結果（AST、シンボルテーブル）を状態として保持する。
 */
class LanguageService {
    constructor(filePath) {
        this.currentAst = null;
        this.currentSymbolTable = null;
        this.currentDiagnostics = [];
        this.semanticValidationEnabled = true; // 意味解析の有効/無効フラグ
        this.currentFilePath = filePath;
    }
    /**
     * 意味解析の有効/無効を設定する。
     * @param enabled 有効にする場合はtrue
     */
    setSemanticValidation(enabled) {
        this.semanticValidationEnabled = enabled;
    }
    /**
     * ドキュメントのコンテンツを更新し、再解析を実行する。
     * @param code 新しいソースコード
     */
    updateDocument(code, systemIncludePaths = [], loadPaths = []) {
        const { ast, diagnostics: parseDiagnostics } = (0, parserUtils_1.parseAndBuildAST)(code, this.currentFilePath || 'untitled');
        const diagnostics = [...parseDiagnostics];
        if (!ast) {
            this.currentAst = null;
            this.currentSymbolTable = null;
            this.currentDiagnostics = diagnostics;
            return;
        }
        // 意味解析が有効な場合のみValidatorを実行
        if (this.semanticValidationEnabled) {
            const validator = new validator_1.Validator(ast, this.currentFilePath, systemIncludePaths, loadPaths);
            const semanticErrors = validator.analyze(ast);
            diagnostics.push(...semanticErrors);
            this.currentSymbolTable = validator.symbolTable;
        }
        else {
            // 意味解析が無効な場合は、シンボルテーブルをクリア
            this.currentSymbolTable = null;
        }
        this.currentAst = ast;
        this.currentDiagnostics = diagnostics;
    }
    /**
     * 現在の診断情報（エラーや警告）を取得する。
     * @returns 診断情報の配列
     */
    getDiagnostics() {
        return this.currentDiagnostics;
    }
    /**
     * 現在のAST（抽象構文木）を取得する。
     */
    getAST() {
        return this.currentAst;
    }
    /**
     * 現在のシンボルテーブルを取得する。
     */
    getSymbolTable() {
        return this.currentSymbolTable;
    }
    /**
     * 指定された位置のコード補完候補を取得する。
     */
    getCompletions(code, position) {
        if (!this.currentAst || !this.currentSymbolTable) {
            return [];
        }
        return (0, completionProvider_1.getCompletions)(code, position, this.currentAst, this.currentSymbolTable);
    }
    /**
     * 指定された位置のホバー情報を取得する。
     */
    getHoverInfo(code, position) {
        if (!this.currentAst || !this.currentSymbolTable) {
            return null;
        }
        return (0, hoverProvider_1.getHoverInfo)(code, position, this.currentAst, this.currentSymbolTable) ?? null;
    }
    /**
     * 指定された位置のシンボルの定義位置を取得する。
     */
    getDefinitionLocation(code, position) {
        if (!this.currentAst || !this.currentSymbolTable) {
            return null;
        }
        return (0, definitionProvider_1.getDefinitionLocation)(code, position, this.currentAst, this.currentSymbolTable, this.currentFilePath) ?? null;
    }
    /**
     * ドキュメント全体のシンボル（アウトライン）を取得する。
     */
    getDocumentSymbols() {
        if (!this.currentAst || !this.currentSymbolTable) {
            return [];
        }
        return (0, documentSymbolProvider_1.getDocumentSymbols)(this.currentAst, this.currentSymbolTable);
    }
    /**
     * シンボル名を変更するためのテキスト編集情報を取得する。
     */
    getRenameEdits(code, position, newName) {
        if (!this.currentAst || !this.currentSymbolTable) {
            return null;
        }
        return (0, renameProvider_1.getRenameEdits)(code, position, newName, this.currentAst, this.currentSymbolTable, this.currentFilePath) ?? null;
    }
    /**
     * セマンティックハイライトのためのトークンを取得する。
     */
    getSemanticTokens() {
        if (!this.currentAst || !this.currentSymbolTable) {
            return [];
        }
        return (0, semanticTokensProvider_1.getSemanticTokens)(this.currentAst, this.currentSymbolTable);
    }
    /**
     * ドキュメントをフォーマットする。
     */
    formatDocument() {
        if (!this.currentAst) {
            // TODO: 構文エラーがある場合でも部分的にフォーマットを試みるか検討
            return null;
        }
        const formatter = new formatter_1.AsirFormatter();
        return formatter.format(this.currentAst);
    }
}
exports.LanguageService = LanguageService;
//# sourceMappingURL=languageService.js.map

/***/ }),

/***/ "../pasirser/dist/utils/diagnostics.js":
/*!*********************************************!*\
  !*** ../pasirser/dist/utils/diagnostics.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticTag = exports.DiagnosticSeverity = void 0;
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    DiagnosticSeverity[DiagnosticSeverity["Error"] = 1] = "Error";
    DiagnosticSeverity[DiagnosticSeverity["Warning"] = 2] = "Warning";
    DiagnosticSeverity[DiagnosticSeverity["Information"] = 3] = "Information";
    DiagnosticSeverity[DiagnosticSeverity["Hint"] = 4] = "Hint";
})(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
var DiagnosticTag;
(function (DiagnosticTag) {
    DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    DiagnosticTag[DiagnosticTag["Deprecated"] = 2] = "Deprecated";
})(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
//# sourceMappingURL=diagnostics.js.map

/***/ }),

/***/ "../pasirser/dist/utils/errors.js":
/*!****************************************!*\
  !*** ../pasirser/dist/utils/errors.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ASTBuilderError = void 0;
exports.getLoc = getLoc;
const antlr4ng_1 = __webpack_require__(/*! antlr4ng */ "../pasirser/node_modules/antlr4ng/dist/index.cjs");
/**
 * ParserRuleContext または TerminalNode から ASTNode の位置情報を取得します。
 * @param arg 位置情報を取得する対象のコンテキストまたはノード
 * @returns ASTNode['loc'] 形式の位置情報オブジェクト
 */
function getLoc(arg) {
    if (!arg)
        return undefined;
    let startToken;
    let stopToken;
    if (arg instanceof antlr4ng_1.ParserRuleContext) {
        startToken = arg.start;
        stopToken = arg.stop;
    }
    else if (arg instanceof antlr4ng_1.TerminalNode) {
        startToken = arg.symbol;
        stopToken = arg.symbol;
    }
    else {
        startToken = arg;
        stopToken = arg;
    }
    if (!startToken || !stopToken) {
        return undefined;
    }
    const stopLine = stopToken.line;
    const stopCol = stopToken.column + (stopToken.text?.length || 0);
    const stopOffset = stopToken.stop + 1;
    return {
        start: {
            line: startToken.line,
            column: startToken.column,
            offset: startToken.start
        },
        end: {
            line: stopLine,
            column: stopCol,
            offset: stopOffset
        }
    };
}
/**
 * AST構築プロセス中に発生したエラーを表すカスタムクラス。
 * エラーメッセージに加えて、コード上の位置情報を保持します。
 */
class ASTBuilderError extends Error {
    /**
     * @param message エラーの主旨を説明するメッセージ。
     * @param ctx エラーが発生した箇所の ParserRuleContext または TerminalNode。
     */
    constructor(message, ctx) {
        const loc = ctx ? getLoc(ctx) : undefined;
        // locが取得できた場合のみ、メッセージに位置情報を追加する
        const locationString = loc
            ? ` (at line ${loc.start.line}, column ${loc.start.column})`
            : ' (at an unknown location)';
        // 親クラス(Error)のコンストラクタを呼び出す
        super(message + locationString);
        // エラー名を設定する。
        this.name = 'ASTBuilderError';
        // JavaScriptの組み込みクラスを拡張するためのおまじない。
        Object.setPrototypeOf(this, ASTBuilderError.prototype);
        // 位置情報をインスタンスプロパティとして保持する。
        this.loc = loc;
    }
}
exports.ASTBuilderError = ASTBuilderError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "../pasirser/node_modules/antlr4ng/dist/index.cjs":
/*!********************************************************!*\
  !*** ../pasirser/node_modules/antlr4ng/dist/index.cjs ***!
  \********************************************************/
/***/ ((module) => {

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ATN: () => ATN,
  ATNConfig: () => ATNConfig,
  ATNConfigSet: () => ATNConfigSet,
  ATNDeserializer: () => ATNDeserializer,
  ATNSerializer: () => ATNSerializer,
  ATNSimulator: () => ATNSimulator,
  ATNState: () => ATNState,
  AbstractParseTreeVisitor: () => AbstractParseTreeVisitor,
  AbstractPredicateTransition: () => AbstractPredicateTransition,
  ActionTransition: () => ActionTransition,
  ArrayPredictionContext: () => ArrayPredictionContext,
  AtomTransition: () => AtomTransition,
  BailErrorStrategy: () => BailErrorStrategy,
  BaseErrorListener: () => BaseErrorListener,
  BasicBlockStartState: () => BasicBlockStartState,
  BasicState: () => BasicState,
  BitSet: () => BitSet,
  BlockEndState: () => BlockEndState,
  BlockStartState: () => BlockStartState,
  BufferedTokenStream: () => BufferedTokenStream,
  CannotInvokeStartRuleError: () => CannotInvokeStartRuleError,
  CharStream: () => CharStream,
  CharStreamImpl: () => CharStreamImpl,
  Chunk: () => Chunk,
  CodePointTransitions: () => CodePointTransitions,
  CommonToken: () => CommonToken,
  CommonTokenFactory: () => CommonTokenFactory,
  CommonTokenStream: () => CommonTokenStream,
  ConsoleErrorListener: () => ConsoleErrorListener,
  DFA: () => DFA,
  DFASerializer: () => DFASerializer,
  DFAState: () => DFAState,
  DecisionInfo: () => DecisionInfo,
  DecisionState: () => DecisionState,
  DefaultErrorStrategy: () => DefaultErrorStrategy,
  DiagnosticErrorListener: () => DiagnosticErrorListener,
  DoubleDict: () => DoubleDict,
  EmptyPredictionContext: () => EmptyPredictionContext,
  EpsilonTransition: () => EpsilonTransition,
  ErrorNode: () => ErrorNode,
  FailedPredicateException: () => FailedPredicateException,
  HashMap: () => HashMap,
  HashSet: () => HashSet,
  InputMismatchException: () => InputMismatchException,
  IntStream: () => IntStream,
  InterpreterDataReader: () => InterpreterDataReader,
  InterpreterRuleContext: () => InterpreterRuleContext,
  Interval: () => Interval,
  IntervalSet: () => IntervalSet,
  LL1Analyzer: () => LL1Analyzer,
  Lexer: () => Lexer,
  LexerATNConfig: () => LexerATNConfig,
  LexerATNSimulator: () => LexerATNSimulator,
  LexerActionExecutor: () => LexerActionExecutor,
  LexerActionType: () => LexerActionType,
  LexerChannelAction: () => LexerChannelAction,
  LexerCustomAction: () => LexerCustomAction,
  LexerDFASerializer: () => LexerDFASerializer,
  LexerIndexedCustomAction: () => LexerIndexedCustomAction,
  LexerInterpreter: () => LexerInterpreter,
  LexerModeAction: () => LexerModeAction,
  LexerMoreAction: () => LexerMoreAction,
  LexerNoViableAltException: () => LexerNoViableAltException,
  LexerPopModeAction: () => LexerPopModeAction,
  LexerPushModeAction: () => LexerPushModeAction,
  LexerSkipAction: () => LexerSkipAction,
  LexerTypeAction: () => LexerTypeAction,
  ListTokenSource: () => ListTokenSource,
  LoopEndState: () => LoopEndState,
  MurmurHash: () => MurmurHash,
  NoViableAltException: () => NoViableAltException,
  NotSetTransition: () => NotSetTransition,
  OrderedATNConfigSet: () => OrderedATNConfigSet,
  OrderedHashMap: () => OrderedHashMap,
  OrderedHashSet: () => OrderedHashSet,
  ParseCancellationException: () => ParseCancellationException,
  ParseInfo: () => ParseInfo,
  ParseTreeMatch: () => ParseTreeMatch,
  ParseTreePattern: () => ParseTreePattern,
  ParseTreePatternMatcher: () => ParseTreePatternMatcher,
  ParseTreeWalker: () => ParseTreeWalker,
  Parser: () => Parser,
  ParserATNSimulator: () => ParserATNSimulator,
  ParserInterpreter: () => ParserInterpreter,
  ParserRuleContext: () => ParserRuleContext,
  PlusBlockStartState: () => PlusBlockStartState,
  PlusLoopbackState: () => PlusLoopbackState,
  PrecedencePredicateTransition: () => PrecedencePredicateTransition,
  PredPrediction: () => PredPrediction,
  PredicateTransition: () => PredicateTransition,
  PredictionContext: () => PredictionContext,
  PredictionContextCache: () => PredictionContextCache,
  PredictionMode: () => PredictionMode,
  ProfilingATNSimulator: () => ProfilingATNSimulator,
  ProxyErrorListener: () => ProxyErrorListener,
  RangeTransition: () => RangeTransition,
  RecognitionException: () => RecognitionException,
  Recognizer: () => Recognizer,
  RuleStartState: () => RuleStartState,
  RuleStopState: () => RuleStopState,
  RuleTagToken: () => RuleTagToken,
  RuleTransition: () => RuleTransition,
  RuntimeMetaData: () => RuntimeMetaData,
  SemanticContext: () => SemanticContext,
  SetTransition: () => SetTransition,
  SingletonPredictionContext: () => SingletonPredictionContext,
  StarBlockStartState: () => StarBlockStartState,
  StarLoopEntryState: () => StarLoopEntryState,
  StarLoopbackState: () => StarLoopbackState,
  StartRuleDoesNotConsumeFullPatternError: () => StartRuleDoesNotConsumeFullPatternError,
  TagChunk: () => TagChunk,
  TerminalNode: () => TerminalNode,
  TextChunk: () => TextChunk,
  Token: () => Token,
  TokenStreamRewriter: () => TokenStreamRewriter,
  TokenTagToken: () => TokenTagToken,
  TokensStartState: () => TokensStartState,
  TraceListener: () => TraceListener,
  Transition: () => Transition,
  Trees: () => Trees,
  UnbufferedTokenStream: () => UnbufferedTokenStream,
  Vocabulary: () => Vocabulary,
  WildcardTransition: () => WildcardTransition,
  XPath: () => XPath,
  XPathElement: () => XPathElement,
  XPathLexer: () => XPathLexer,
  XPathLexerErrorListener: () => XPathLexerErrorListener,
  XPathRuleAnywhereElement: () => XPathRuleAnywhereElement,
  XPathRuleElement: () => XPathRuleElement,
  XPathTokenAnywhereElement: () => XPathTokenAnywhereElement,
  XPathTokenElement: () => XPathTokenElement,
  XPathWildcardAnywhereElement: () => XPathWildcardAnywhereElement,
  XPathWildcardElement: () => XPathWildcardElement,
  arrayToString: () => arrayToString,
  combineCommonParents: () => combineCommonParents,
  createSingletonPredictionContext: () => createSingletonPredictionContext,
  equalArrays: () => equalArrays,
  equalNumberArrays: () => equalNumberArrays,
  escapeWhitespace: () => escapeWhitespace,
  getCachedPredictionContext: () => getCachedPredictionContext,
  isComparable: () => isComparable,
  isToken: () => isToken,
  isWritableToken: () => isWritableToken,
  merge: () => merge,
  mergeRoot: () => mergeRoot,
  mergeSingletons: () => mergeSingletons,
  predictionContextFromRuleContext: () => predictionContextFromRuleContext
});
module.exports = __toCommonJS(src_exports);

// src/IntStream.ts
var IntStream;
((IntStream2) => {
  IntStream2.EOF = -1;
  IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
})(IntStream || (IntStream = {}));

// src/Token.ts
var Token;
((Token2) => {
  Token2.INVALID_TYPE = 0;
  Token2.EPSILON = -2;
  Token2.MIN_USER_TOKEN_TYPE = 1;
  Token2.EOF = IntStream.EOF;
  Token2.DEFAULT_CHANNEL = 0;
  Token2.HIDDEN_CHANNEL = 1;
  Token2.MIN_USER_CHANNEL_VALUE = 2;
})(Token || (Token = {}));
var isToken = /* @__PURE__ */ __name((candidate) => {
  const token = candidate;
  return token.tokenSource !== void 0 && token.channel !== void 0;
}, "isToken");

// src/misc/BitSet.ts
var BitSet = class {
  static {
    __name(this, "BitSet");
  }
  data;
  /**
   * Creates a new bit set. All bits are initially `false`.
   *
   * @param data Optional initial data.
   */
  constructor(data) {
    if (data) {
      this.data = new Uint32Array(data.map((value) => {
        return value >>> 0;
      }));
    } else {
      this.data = new Uint32Array(1);
    }
  }
  /**
   * @returns an iterator over all set bits.
   */
  [Symbol.iterator]() {
    const length = this.data.length;
    let currentIndex = 0;
    let currentWord = this.data[currentIndex];
    const words = this.data;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next: /* @__PURE__ */ __name(() => {
        while (currentIndex < length) {
          if (currentWord !== 0) {
            const t = currentWord & -currentWord;
            const value = (currentIndex << 5) + this.bitCount(t - 1);
            currentWord ^= t;
            return { done: false, value };
          } else {
            currentIndex++;
            if (currentIndex < length) {
              currentWord = words[currentIndex];
            }
          }
        }
        return { done: true, value: void 0 };
      }, "next")
    };
  }
  /**
   * Sets a single bit or all of the bits in this `BitSet` to `false`.
   *
   * @param index the index of the bit to be cleared, or undefined to clear all bits.
   */
  clear(index) {
    if (index === void 0) {
      this.data = new Uint32Array();
    } else {
      this.resize(index);
      this.data[index >>> 5] &= ~(1 << index);
    }
  }
  /**
   * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
   * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
   * set argument has the value `true`.
   *
   * @param set the bit set to be ORed with.
   */
  or(set) {
    const minCount = Math.min(this.data.length, set.data.length);
    for (let k = 0; k < minCount; ++k) {
      this.data[k] |= set.data[k];
    }
    if (this.data.length < set.data.length) {
      this.resize((set.data.length << 5) - 1);
      const c = set.data.length;
      for (let k = minCount; k < c; ++k) {
        this.data[k] = set.data[k];
      }
    }
  }
  /**
   * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`
   * is currently set in this `BitSet`; otherwise, the result is `false`.
   *
   * @param index the bit index
   *
   * @returns the value of the bit with the specified index.
   */
  get(index) {
    if (index < 0) {
      throw new RangeError("index cannot be negative");
    }
    const slot = index >>> 5;
    if (slot >= this.data.length) {
      return false;
    }
    return (this.data[slot] & 1 << index % 32) !== 0;
  }
  /**
   * @returns the number of set bits.
   */
  get length() {
    let result = 0;
    const c = this.data.length;
    const w = this.data;
    for (let i = 0; i < c; i++) {
      result += this.bitCount(w[i]);
    }
    return result;
  }
  /**
   * @returns an array with indices of set bits.
   */
  values() {
    const result = new Array(this.length);
    let pos = 0;
    const length = this.data.length;
    for (let k = 0; k < length; ++k) {
      let w = this.data[k];
      while (w !== 0) {
        const t = w & -w;
        result[pos++] = (k << 5) + this.bitCount(t - 1);
        w ^= t;
      }
    }
    return result;
  }
  /**
   * @returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
   * If no such bit exists then undefined is returned.
   *
   * @param fromIndex the index to start checking from (inclusive)
   */
  nextSetBit(fromIndex) {
    if (fromIndex < 0) {
      throw new RangeError("index cannot be negative");
    }
    for (const index of this) {
      if (index >= fromIndex) {
        return index;
      }
    }
    return void 0;
  }
  /**
   * Sets the bit at the specified index to `true`.
   *
   * @param index a bit index
   */
  set(index) {
    if (index < 0) {
      throw new RangeError("index cannot be negative");
    }
    this.resize(index);
    this.data[index >>> 5] |= 1 << index % 32;
  }
  /**
   * @returns a string representation of this bit set.
   */
  toString() {
    return "{" + this.values().join(", ") + "}";
  }
  resize(index) {
    const count = index + 32 >>> 5;
    if (count <= this.data.length) {
      return;
    }
    const data = new Uint32Array(count);
    data.set(this.data);
    data.fill(0, this.data.length);
    this.data = data;
  }
  bitCount(v) {
    v = v - (v >> 1 & 1431655765);
    v = (v & 858993459) + (v >> 2 & 858993459);
    v = v + (v >> 4) & 252645135;
    v = v + (v >> 8);
    v = v + (v >> 16);
    return v & 63;
  }
};

// src/utils/MurmurHash.ts
var c1 = 3432918353;
var c2 = 461845907;
var r1 = 15;
var r2 = 13;
var m = 5;
var n = 3864292196;
var MurmurHash = class _MurmurHash {
  static {
    __name(this, "MurmurHash");
  }
  static defaultSeed = 701;
  constructor() {
  }
  /**
   * Initialize the hash using the specified {@code seed}.
   *
   * @param seed the seed
   *
   * @returns the intermediate hash value
   */
  static initialize(seed = _MurmurHash.defaultSeed) {
    return seed;
  }
  static updateFromComparable(hash, value) {
    return this.update(hash, value?.hashCode() ?? 0);
  }
  /**
   * Update the intermediate hash value for the next input {@code value}.
   *
   * @param hash The intermediate hash value.
   * @param value the value to add to the current hash.
   *
   * @returns the updated intermediate hash value
   */
  static update(hash, value) {
    value = Math.imul(value, c1);
    value = value << r1 | value >>> 32 - r1;
    value = Math.imul(value, c2);
    hash = hash ^ value;
    hash = hash << r2 | hash >>> 32 - r2;
    hash = Math.imul(hash, m) + n;
    return hash;
  }
  /**
   * Apply the final computation steps to the intermediate value {@code hash}
   * to form the final result of the MurmurHash 3 hash function.
   *
   * @param hash The intermediate hash value.
   * @param entryCount The number of values added to the hash.
   *
   * @returns the final hash result
   */
  static finish(hash, entryCount) {
    hash ^= entryCount * 4;
    hash ^= hash >>> 16;
    hash = Math.imul(hash, 2246822507);
    hash ^= hash >>> 13;
    hash = Math.imul(hash, 3266489909);
    hash ^= hash >>> 16;
    return hash;
  }
  /**
   * An all-in-one convenience method to compute a hash for a single value.
   *
   * @param value The value to hash.
   * @param seed The seed for the hash value.
   *
   * @returns The computed hash.
   */
  static hashCode(value, seed) {
    return _MurmurHash.finish(_MurmurHash.update(seed ?? _MurmurHash.defaultSeed, value), 1);
  }
};

// src/misc/ObjectEqualityComparator.ts
var ObjectEqualityComparator = class _ObjectEqualityComparator {
  static {
    __name(this, "ObjectEqualityComparator");
  }
  static instance = new _ObjectEqualityComparator();
  hashCode(obj) {
    if (obj == null) {
      return 0;
    }
    return obj.hashCode();
  }
  equals(a, b) {
    if (a == null) {
      return b == null;
    }
    return a.equals(b);
  }
};

// src/misc/DefaultEqualityComparator.ts
var DefaultEqualityComparator = class _DefaultEqualityComparator {
  static {
    __name(this, "DefaultEqualityComparator");
  }
  static instance = new _DefaultEqualityComparator();
  hashCode(obj) {
    if (obj == null) {
      return 0;
    }
    return ObjectEqualityComparator.instance.hashCode(obj);
  }
  equals(a, b) {
    if (a == null) {
      return b == null;
    }
    if (typeof a === "string" || typeof a === "number") {
      return a === b;
    }
    return ObjectEqualityComparator.instance.equals(a, b);
  }
};

// src/misc/HashSet.ts
var HashSet = class _HashSet {
  static {
    __name(this, "HashSet");
  }
  static defaultLoadFactor = 0.75;
  static initialCapacity = 16;
  // must be power of 2
  comparator;
  buckets;
  threshold;
  /** How many elements in set */
  itemCount = 0;
  constructor(comparatorOrSet, initialCapacity = _HashSet.initialCapacity) {
    if (comparatorOrSet instanceof _HashSet) {
      this.comparator = comparatorOrSet.comparator;
      this.buckets = comparatorOrSet.buckets.slice(0);
      for (let i = 0; i < this.buckets.length; i++) {
        const bucket = this.buckets[i];
        if (bucket) {
          this.buckets[i] = bucket.slice(0);
        }
      }
      this.itemCount = comparatorOrSet.itemCount;
      this.threshold = comparatorOrSet.threshold;
    } else {
      this.comparator = comparatorOrSet ?? DefaultEqualityComparator.instance;
      this.buckets = this.createBuckets(initialCapacity);
      this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
    }
  }
  /**
   * Add `o` to set if not there; return existing value if already
   * there. This method performs the same operation as {@link #add} aside from
   * the return value.
   *
   * @param o the object to add to the set.
   *
   * @returns An existing element that equals to `o` if already in set, otherwise `o`.
   */
  getOrAdd(o) {
    if (this.itemCount > this.threshold) {
      this.expand();
    }
    const b = this.getBucket(o);
    let bucket = this.buckets[b];
    if (!bucket) {
      bucket = [o];
      this.buckets[b] = bucket;
      ++this.itemCount;
      return o;
    }
    for (const existing of bucket) {
      if (this.comparator.equals(existing, o)) {
        return existing;
      }
    }
    bucket.push(o);
    ++this.itemCount;
    return o;
  }
  get(o) {
    if (o == null) {
      return o;
    }
    const b = this.getBucket(o);
    const bucket = this.buckets[b];
    if (!bucket) {
      return void 0;
    }
    for (const e of bucket) {
      if (this.comparator.equals(e, o)) {
        return e;
      }
    }
    return void 0;
  }
  /**
   * Removes the specified element from this set if it is present.
   *
   * @param o object to be removed from this set, if present.
   *
   * @returns `true` if the set contained the specified element.
   */
  remove(o) {
    if (o == null) {
      return false;
    }
    const b = this.getBucket(o);
    const bucket = this.buckets[b];
    if (!bucket) {
      return false;
    }
    for (let i = 0; i < bucket.length; i++) {
      const existing = bucket[i];
      if (this.comparator.equals(existing, o)) {
        bucket.splice(i, 1);
        --this.itemCount;
        return true;
      }
    }
    return false;
  }
  hashCode() {
    let hash = MurmurHash.initialize();
    for (const bucket of this.buckets) {
      if (bucket == null) {
        continue;
      }
      for (const o of bucket) {
        if (o == null) {
          break;
        }
        hash = MurmurHash.update(hash, this.comparator.hashCode(o));
      }
    }
    hash = MurmurHash.finish(hash, this.size);
    return hash;
  }
  equals(o) {
    if (o === this) {
      return true;
    }
    if (!(o instanceof _HashSet)) {
      return false;
    }
    if (o.size !== this.size) {
      return false;
    }
    return this.containsAll(o);
  }
  add(t) {
    const existing = this.getOrAdd(t);
    return existing === t;
  }
  contains(o) {
    return this.containsFast(o);
  }
  containsFast(obj) {
    if (obj == null) {
      return false;
    }
    return this.get(obj) !== void 0;
  }
  *[Symbol.iterator]() {
    yield* this.toArray();
  }
  toArray() {
    const a = new Array(this.size);
    let i = 0;
    for (const bucket of this.buckets) {
      if (bucket == null) {
        continue;
      }
      for (const o of bucket) {
        if (o == null) {
          break;
        }
        a[i++] = o;
      }
    }
    return a;
  }
  containsAll(collection) {
    if (collection instanceof _HashSet) {
      for (const bucket of collection.buckets) {
        if (bucket == null) {
          continue;
        }
        for (const o of bucket) {
          if (o == null) {
            break;
          }
          if (!this.containsFast(o)) {
            return false;
          }
        }
      }
    } else {
      for (const o of collection) {
        if (!this.containsFast(o)) {
          return false;
        }
      }
    }
    return true;
  }
  addAll(c) {
    let changed = false;
    for (const o of c) {
      const existing = this.getOrAdd(o);
      if (existing !== o) {
        changed = true;
      }
    }
    return changed;
  }
  clear() {
    this.buckets = this.createBuckets(_HashSet.initialCapacity);
    this.itemCount = 0;
    this.threshold = Math.floor(_HashSet.initialCapacity * _HashSet.defaultLoadFactor);
  }
  toString() {
    if (this.size === 0) {
      return "{}";
    }
    let buf = "{";
    let first = true;
    for (const bucket of this.buckets) {
      if (bucket == null) {
        continue;
      }
      for (const o of bucket) {
        if (o == null) {
          break;
        }
        if (first) {
          first = false;
        } else {
          buf += ", ";
        }
        buf += o.toString();
      }
    }
    buf += "}";
    return buf;
  }
  toTableString() {
    let buf = "";
    for (const bucket of this.buckets) {
      if (bucket == null) {
        buf += "null\n";
        continue;
      }
      buf += "[";
      let first = true;
      for (const o of bucket) {
        if (first) {
          first = false;
        } else {
          buf += " ";
        }
        if (o == null) {
          buf += "_";
        } else {
          buf += o.toString();
        }
      }
      buf += "]\n";
    }
    return buf;
  }
  getBucket(o) {
    const hash = this.comparator.hashCode(o);
    const b = hash & this.buckets.length - 1;
    return b;
  }
  expand() {
    const old = this.buckets;
    const newCapacity = this.buckets.length * 2;
    const newTable = this.createBuckets(newCapacity);
    this.buckets = newTable;
    this.threshold = Math.floor(newCapacity * _HashSet.defaultLoadFactor);
    for (const bucket of old) {
      if (!bucket) {
        continue;
      }
      for (const o of bucket) {
        const b = this.getBucket(o);
        let newBucket = this.buckets[b];
        if (!newBucket) {
          newBucket = [];
          this.buckets[b] = newBucket;
        }
        newBucket.push(o);
      }
    }
  }
  get size() {
    return this.itemCount;
  }
  get isEmpty() {
    return this.itemCount === 0;
  }
  /**
   * Return an array of `T[]` with length `capacity`.
   *
   * @param capacity the length of the array to return
   * @returns the newly constructed array
   */
  createBuckets(capacity) {
    return new Array(capacity);
  }
};

// src/misc/Interval.ts
var Interval = class _Interval {
  static {
    __name(this, "Interval");
  }
  static INVALID_INTERVAL = new _Interval(-1, -2);
  static INTERVAL_POOL_MAX_VALUE = 1e3;
  static cache = [];
  start;
  stop;
  cachedHashCode;
  constructor(start, stop) {
    this.start = start;
    this.stop = stop;
    this.cachedHashCode = Math.imul(651 + start, 31) + stop;
  }
  /**
   * Creates a new interval from the given values.
   *
   * Interval objects are used readonly so share all with the
   * same single value a==b up to some max size. Use an array as a perfect hash.
   * Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
   * Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
   * have a..a (set with 1 element).
   *
   * @param a The start of the interval.
   * @param b The end of the interval (inclusive).
   *
   * @returns A cached or new interval.
   */
  static of(a, b) {
    if (a !== b || a < 0 || a > _Interval.INTERVAL_POOL_MAX_VALUE) {
      return new _Interval(a, b);
    }
    if (!_Interval.cache[a]) {
      _Interval.cache[a] = new _Interval(a, a);
    }
    return _Interval.cache[a];
  }
  equals(o) {
    return this.start === o.start && this.stop === o.stop;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  /** Does this start completely before other? Disjoint */
  startsBeforeDisjoint(other) {
    return this.start < other.start && this.stop < other.start;
  }
  /** Does this start at or before other? Nondisjoint */
  startsBeforeNonDisjoint(other) {
    return this.start <= other.start && this.stop >= other.start;
  }
  /** Does this.start start after other.stop? May or may not be disjoint */
  startsAfter(other) {
    return this.start > other.start;
  }
  /** Does this start completely after other? Disjoint */
  startsAfterDisjoint(other) {
    return this.start > other.stop;
  }
  /** Does this start after other? NonDisjoint */
  startsAfterNonDisjoint(other) {
    return this.start > other.start && this.start <= other.stop;
  }
  /** Are both ranges disjoint? I.e., no overlap? */
  disjoint(other) {
    return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
  }
  /** Are two intervals adjacent such as 0..41 and 42..42? */
  adjacent(other) {
    return this.start === other.stop + 1 || this.stop === other.start - 1;
  }
  properlyContains(other) {
    return other.start >= this.start && other.stop <= this.stop;
  }
  /** Return the interval computed from combining this and other */
  union(other) {
    return _Interval.of(Math.min(this.start, other.start), Math.max(this.stop, other.stop));
  }
  /** Return the interval in common between this and o */
  intersection(other) {
    return _Interval.of(Math.max(this.start, other.start), Math.min(this.stop, other.stop));
  }
  /**
   * Return the interval with elements from this not in other;
   *  other must not be totally enclosed (properly contained)
   *  within this, which would result in two disjoint intervals
   *  instead of the single one returned by this method.
   */
  differenceNotProperlyContained(other) {
    let diff = null;
    if (other.startsBeforeNonDisjoint(this)) {
      diff = _Interval.of(Math.max(this.start, other.stop + 1), this.stop);
    } else if (other.startsAfterNonDisjoint(this)) {
      diff = _Interval.of(this.start, other.start - 1);
    }
    return diff;
  }
  toString() {
    return `${this.start}..${this.stop}`;
  }
  get length() {
    if (this.stop < this.start) {
      return 0;
    }
    return this.stop - this.start + 1;
  }
};

// src/Vocabulary.ts
var Vocabulary = class _Vocabulary {
  static {
    __name(this, "Vocabulary");
  }
  static EMPTY_NAMES = [];
  /**
   * Gets an empty {@link Vocabulary} instance.
   *
   *
   * No literal or symbol names are assigned to token types, so
   * {@link #getDisplayName(int)} returns the numeric value for all tokens
   * except {@link Token#EOF}.
   */
  static EMPTY_VOCABULARY = new _Vocabulary(_Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES, _Vocabulary.EMPTY_NAMES);
  maxTokenType;
  literalNames;
  symbolicNames;
  displayNames;
  /**
   * Constructs a new instance of {@link Vocabulary} from the specified
   * literal, symbolic, and display token names.
   *
   * @param literalNames The literal names assigned to tokens, or `null`
   * if no literal names are assigned.
   * @param symbolicNames The symbolic names assigned to tokens, or
   * `null` if no symbolic names are assigned.
   * @param displayNames The display names assigned to tokens, or `null`
   * to use the values in `literalNames` and `symbolicNames` as
   * the source of display names, as described in
   * {@link #getDisplayName(int)}.
   */
  constructor(literalNames, symbolicNames, displayNames) {
    this.literalNames = literalNames ?? _Vocabulary.EMPTY_NAMES;
    this.symbolicNames = symbolicNames ?? _Vocabulary.EMPTY_NAMES;
    this.displayNames = displayNames ?? _Vocabulary.EMPTY_NAMES;
    this.maxTokenType = Math.max(this.displayNames.length, Math.max(
      this.literalNames.length,
      this.symbolicNames.length
    )) - 1;
  }
  /**
   * Returns a {@link Vocabulary} instance from the specified set of token
   * names. This method acts as a compatibility layer for the single
   * `tokenNames` array generated by previous releases of ANTLR.
   *
   * The resulting vocabulary instance returns `null` for
   * {@link getLiteralName getLiteralName(int)} and {@link getSymbolicName getSymbolicName(int)}, and the
   * value from `tokenNames` for the display names.
   *
   * @param tokenNames The token names, or `null` if no token names are
   * available.
   * @returns A {@link Vocabulary} instance which uses `tokenNames` for
   * the display names of tokens.
   */
  static fromTokenNames(tokenNames) {
    if (tokenNames == null || tokenNames.length === 0) {
      return _Vocabulary.EMPTY_VOCABULARY;
    }
    const literalNames = [...tokenNames];
    const symbolicNames = [...tokenNames];
    for (let i = 0; i < tokenNames.length; i++) {
      const tokenName = tokenNames[i];
      if (tokenName == null) {
        continue;
      }
      if (tokenName.length > 0) {
        const firstChar = tokenName.codePointAt(0);
        if (firstChar === 39) {
          symbolicNames[i] = null;
          continue;
        } else if (firstChar >= 65 && firstChar <= 90) {
          literalNames[i] = null;
          continue;
        }
      }
      literalNames[i] = null;
      symbolicNames[i] = null;
    }
    return new _Vocabulary(literalNames, symbolicNames, tokenNames);
  }
  getMaxTokenType() {
    return this.maxTokenType;
  }
  getLiteralName(tokenType) {
    if (tokenType >= 0 && tokenType < this.literalNames.length) {
      return this.literalNames[tokenType];
    }
    return null;
  }
  getSymbolicName(tokenType) {
    if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
      return this.symbolicNames[tokenType];
    }
    if (tokenType === Token.EOF) {
      return "EOF";
    }
    return null;
  }
  getDisplayName(tokenType) {
    if (tokenType >= 0 && tokenType < this.displayNames.length) {
      const displayName = this.displayNames[tokenType];
      if (displayName != null) {
        return displayName;
      }
    }
    const literalName = this.getLiteralName(tokenType);
    if (literalName != null) {
      return literalName;
    }
    const symbolicName = this.getSymbolicName(tokenType);
    if (symbolicName != null) {
      return symbolicName;
    }
    return `${tokenType}`;
  }
  getLiteralNames() {
    return this.literalNames;
  }
  getSymbolicNames() {
    return this.symbolicNames;
  }
  getDisplayNames() {
    return this.displayNames;
  }
};

// src/misc/IntervalSet.ts
var IntervalSet = class _IntervalSet {
  static {
    __name(this, "IntervalSet");
  }
  /** The list of sorted, disjoint intervals. */
  intervals = [];
  cachedHashCode;
  constructor(set) {
    if (set) {
      if (Array.isArray(set)) {
        for (const el of set) {
          this.addOne(el);
        }
      } else {
        this.addSet(set);
      }
    }
  }
  /** Create a set with all ints within range [a..b] (inclusive) */
  static of(a, b) {
    const s = new _IntervalSet();
    s.addRange(a, b);
    return s;
  }
  /** Combine all sets in the array and return the union of them */
  static or(sets) {
    const result = new _IntervalSet();
    for (const set of sets) {
      result.addSet(set);
    }
    return result;
  }
  [Symbol.iterator]() {
    return this.intervals[Symbol.iterator]();
  }
  get(index) {
    return this.intervals[index];
  }
  /**
   * Returns the minimum value contained in the set if not isNil().
   *
   * @returns the minimum value contained in the set.
   */
  get minElement() {
    if (this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    }
    return this.intervals[0].start;
  }
  /**
   * Returns the maximum value contained in the set if not isNil().
   *
   * @returns the maximum value contained in the set.
   */
  get maxElement() {
    if (this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    }
    return this.intervals[this.intervals.length - 1].stop;
  }
  clear() {
    this.cachedHashCode = void 0;
    this.intervals = [];
  }
  /**
   * Add a single element to the set.  An isolated element is stored
   *  as a range el..el.
   */
  addOne(v) {
    this.addInterval(new Interval(v, v));
  }
  /**
   * Add interval; i.e., add all integers from a to b to set.
   *  If b < a, do nothing.
   *  Keep list in sorted order (by left range value).
   *  If overlap, combine ranges. For example,
   *  If this is {1..5, 10..20}, adding 6..7 yields
   *  {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}.
   */
  addRange(l, h) {
    this.addInterval(new Interval(l, h));
  }
  addInterval(addition) {
    this.cachedHashCode = void 0;
    if (this.intervals.length === 0) {
      this.intervals.push(addition);
    } else {
      for (let pos = 0; pos < this.intervals.length; pos++) {
        const existing = this.intervals[pos];
        if (addition.equals(existing)) {
          return;
        }
        if (addition.adjacent(existing) || !addition.disjoint(existing)) {
          const bigger = addition.union(existing);
          this.intervals[pos] = bigger;
          for (let sub = pos + 1; sub < this.intervals.length; ) {
            const next = this.intervals[sub];
            if (!bigger.adjacent(next) && bigger.disjoint(next)) {
              break;
            }
            this.intervals.splice(sub, 1);
            this.intervals[pos] = bigger.union(next);
          }
          return;
        }
        if (addition.startsBeforeDisjoint(existing)) {
          this.intervals.splice(pos, 0, addition);
          return;
        }
      }
      this.intervals.push(addition);
    }
  }
  addSet(other) {
    other.intervals.forEach((toAdd) => {
      return this.addInterval(toAdd);
    }, this);
    return this;
  }
  complementWithVocabulary(vocabulary) {
    const result = new _IntervalSet();
    if (!vocabulary) {
      return result;
    }
    if (vocabulary.length === 0) {
      return result;
    }
    result.addSet(vocabulary);
    return result.subtract(this);
  }
  complement(minElement, maxElement) {
    const result = new _IntervalSet();
    result.addInterval(new Interval(minElement, maxElement));
    return result.subtract(this);
  }
  /** combine all sets in the array returned the or'd value */
  or(sets) {
    const result = new _IntervalSet();
    result.addSet(this);
    sets.forEach((set) => {
      return result.addSet(set);
    });
    return result;
  }
  and(other) {
    if (other.length === 0) {
      return new _IntervalSet();
    }
    const myIntervals = this.intervals;
    const theirIntervals = other.intervals;
    let intersection;
    const mySize = myIntervals.length;
    const theirSize = theirIntervals.length;
    let i = 0;
    let j = 0;
    while (i < mySize && j < theirSize) {
      const mine = myIntervals[i];
      const theirs = theirIntervals[j];
      if (mine.startsBeforeDisjoint(theirs)) {
        i++;
      } else if (theirs.startsBeforeDisjoint(mine)) {
        j++;
      } else if (mine.properlyContains(theirs)) {
        if (!intersection) {
          intersection = new _IntervalSet();
        }
        intersection.addInterval(mine.intersection(theirs));
        j++;
      } else if (theirs.properlyContains(mine)) {
        if (!intersection) {
          intersection = new _IntervalSet();
        }
        intersection.addInterval(mine.intersection(theirs));
        i++;
      } else if (!mine.disjoint(theirs)) {
        if (!intersection) {
          intersection = new _IntervalSet();
        }
        intersection.addInterval(mine.intersection(theirs));
        if (mine.startsAfterNonDisjoint(theirs)) {
          j++;
        } else if (theirs.startsAfterNonDisjoint(mine)) {
          i++;
        }
      }
    }
    if (!intersection) {
      return new _IntervalSet();
    }
    return intersection;
  }
  /**
   * Compute the set difference between two interval sets. The specific
   * operation is `left - right`. If either of the input sets is
   * `null`, it is treated as though it was an empty set.
   */
  subtract(other) {
    if (this.length === 0) {
      return new _IntervalSet();
    }
    const result = new _IntervalSet(this);
    if (other.length === 0) {
      return result;
    }
    let resultI = 0;
    let rightI = 0;
    while (resultI < result.intervals.length && rightI < other.intervals.length) {
      const resultInterval = result.intervals[resultI];
      const rightInterval = other.intervals[rightI];
      if (rightInterval.stop < resultInterval.start) {
        rightI++;
        continue;
      }
      if (rightInterval.start > resultInterval.stop) {
        resultI++;
        continue;
      }
      let beforeCurrent;
      let afterCurrent;
      if (rightInterval.start > resultInterval.start) {
        beforeCurrent = new Interval(resultInterval.start, rightInterval.start - 1);
      }
      if (rightInterval.stop < resultInterval.stop) {
        afterCurrent = new Interval(rightInterval.stop + 1, resultInterval.stop);
      }
      if (beforeCurrent) {
        if (afterCurrent) {
          result.intervals[resultI] = beforeCurrent;
          result.intervals.splice(resultI + 1, 0, afterCurrent);
          resultI++;
          rightI++;
        } else {
          result.intervals[resultI] = beforeCurrent;
          resultI++;
        }
      } else {
        if (afterCurrent) {
          result.intervals[resultI] = afterCurrent;
          rightI++;
        } else {
          result.intervals.splice(resultI, 1);
        }
      }
    }
    return result;
  }
  contains(el) {
    const n2 = this.intervals.length;
    let l = 0;
    let r = n2 - 1;
    while (l <= r) {
      const m2 = Math.floor((l + r) / 2);
      const interval = this.intervals[m2];
      if (interval.stop < el) {
        l = m2 + 1;
      } else if (interval.start > el) {
        r = m2 - 1;
      } else {
        return true;
      }
    }
    return false;
  }
  removeRange(toRemove) {
    this.cachedHashCode = void 0;
    if (toRemove.start === toRemove.stop) {
      this.removeOne(toRemove.start);
    } else if (this.intervals !== null) {
      let pos = 0;
      for (const existing of this.intervals) {
        if (toRemove.stop <= existing.start) {
          return;
        } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
          const x = new Interval(toRemove.stop, existing.stop);
          this.intervals.splice(pos, 0, x);
          return;
        } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
          this.intervals.splice(pos, 1);
          pos = pos - 1;
        } else if (toRemove.start < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
        } else if (toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
        }
        pos += 1;
      }
    }
  }
  removeOne(value) {
    this.cachedHashCode = void 0;
    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];
      if (value < existing.start) {
        return;
      } else if (value === existing.start && value === existing.stop) {
        this.intervals.splice(i, 1);
        return;
      } else if (value === existing.start) {
        this.intervals[i] = new Interval(existing.start + 1, existing.stop);
        return;
      } else if (value === existing.stop) {
        this.intervals[i] = new Interval(existing.start, existing.stop - 1);
        return;
      } else if (value < existing.stop) {
        const replace = new Interval(existing.start, value - 1);
        this.intervals[i] = new Interval(value + 1, existing.stop);
        this.intervals.splice(i, 0, replace);
        return;
      }
    }
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      for (const interval of this.intervals) {
        hash = MurmurHash.update(hash, interval.start);
        hash = MurmurHash.update(hash, interval.stop);
      }
      this.cachedHashCode = MurmurHash.finish(hash, this.intervals.length * 2);
    }
    return this.cachedHashCode;
  }
  /**
   * Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over
   * both lists to make sure they are the same. Interval.equals() is used by the List.equals() method to check
   * the ranges.
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    if (this.intervals.length !== other.intervals.length) {
      return false;
    }
    for (let i = 0; i < this.intervals.length; i++) {
      if (!this.intervals[i].equals(other.intervals[i])) {
        return false;
      }
    }
    return true;
  }
  toString(elementsAreChar) {
    if (this.intervals.length === 0) {
      return "{}";
    }
    let result = "";
    if (this.length > 1) {
      result += "{";
    }
    for (let i = 0; i < this.intervals.length; ++i) {
      const interval = this.intervals[i];
      const start = interval.start;
      const stop = interval.stop;
      if (start === stop) {
        if (start === Token.EOF) {
          result += "<EOF>";
        } else if (elementsAreChar) {
          result += "'" + String.fromCodePoint(start) + "'";
        } else {
          result += start;
        }
      } else {
        if (elementsAreChar) {
          result += "'" + String.fromCodePoint(start) + "'..'" + String.fromCodePoint(stop) + "'";
        } else {
          result += start + ".." + stop;
        }
      }
      if (i < this.intervals.length - 1) {
        result += ", ";
      }
    }
    if (this.length > 1) {
      result += "}";
    }
    return result;
  }
  toStringWithVocabulary(vocabulary) {
    if (this.intervals.length === 0) {
      return "{}";
    }
    let result = "";
    if (this.length > 1) {
      result += "{";
    }
    for (let i = 0; i < this.intervals.length; ++i) {
      const interval = this.intervals[i];
      const start = interval.start;
      const stop = interval.stop;
      if (start === stop) {
        if (start === Token.EOF) {
          result += "<EOF>";
        } else {
          result += this.elementName(vocabulary, start);
        }
      } else {
        for (let i2 = start; i2 <= stop; ++i2) {
          if (i2 > start) {
            result += ", ";
          }
          result += this.elementName(vocabulary, i2);
        }
      }
      if (i < this.intervals.length - 1) {
        result += ", ";
      }
    }
    if (this.length > 1) {
      result += "}";
    }
    return result;
  }
  toStringWithRuleNames(ruleNames) {
    if (this.intervals.length === 0) {
      return "{}";
    }
    let result = "";
    if (this.length > 1) {
      result += "{";
    }
    const vocabulary = Vocabulary.fromTokenNames(ruleNames);
    for (let i = 0; i < this.intervals.length; ++i) {
      const interval = this.intervals[i];
      const start = interval.start;
      const stop = interval.stop;
      if (start === stop) {
        if (start === Token.EOF) {
          result += "<EOF>";
        } else {
          result += this.elementName(vocabulary, start);
        }
      } else {
        for (let i2 = start; i2 <= stop; ++i2) {
          if (i2 > start) {
            result += ", ";
          }
          result += this.elementName(vocabulary, i2);
        }
      }
      if (i < this.intervals.length - 1) {
        result += ", ";
      }
    }
    if (this.length > 1) {
      result += "}";
    }
    return result;
  }
  toArray() {
    const data = [];
    for (const interval of this.intervals) {
      for (let j = interval.start; j <= interval.stop; j++) {
        data.push(j);
      }
    }
    return data;
  }
  /** @returns the number of elements in this set. */
  get length() {
    let result = 0;
    for (const interval of this.intervals) {
      result += interval.length;
    }
    return result;
  }
  elementName(vocabulary, token) {
    if (token === Token.EOF) {
      return "<EOF>";
    }
    if (token === Token.EPSILON) {
      return "<EPSILON>";
    }
    return vocabulary.getDisplayName(token);
  }
};

// src/utils/helpers.ts
var isComparable = /* @__PURE__ */ __name((candidate) => {
  return typeof candidate.equals === "function";
}, "isComparable");
var valueToString = /* @__PURE__ */ __name((v) => {
  return v === null ? "null" : v;
}, "valueToString");
var arrayToString = /* @__PURE__ */ __name((value) => {
  return Array.isArray(value) ? "[" + value.map(valueToString).join(", ") + "]" : "null";
}, "arrayToString");
var equalArrays = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    const left = a[i];
    const right = b[i];
    if (left === right) {
      continue;
    }
    if (!left || !left.equals(right)) {
      return false;
    }
  }
  return true;
}, "equalArrays");
var equalNumberArrays = /* @__PURE__ */ __name((a, b) => {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}, "equalNumberArrays");
var escapeWhitespace = /* @__PURE__ */ __name((s, escapeSpaces = false) => {
  s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
  if (escapeSpaces) {
    s = s.replace(/ /g, "\xB7");
  }
  return s;
}, "escapeWhitespace");

// src/atn/SemanticContext.ts
var SemanticContext = class _SemanticContext {
  static {
    __name(this, "SemanticContext");
  }
  cachedHashCode;
  static andContext(a, b) {
    if (a === null || a === _SemanticContext.NONE) {
      return b;
    }
    if (b === null || b === _SemanticContext.NONE) {
      return a;
    }
    const result = new AND(a, b);
    if (result.operands.length === 1) {
      return result.operands[0];
    }
    return result;
  }
  static orContext(a, b) {
    if (a === null) {
      return b;
    }
    if (b === null) {
      return a;
    }
    if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
      return _SemanticContext.NONE;
    }
    const result = new OR(a, b);
    if (result.operands.length === 1) {
      return result.operands[0];
    } else {
      return result;
    }
  }
  static filterPrecedencePredicates(set) {
    const result = [];
    for (const context of set) {
      if (context instanceof _SemanticContext.PrecedencePredicate) {
        result.push(context);
      }
    }
    return result;
  }
  /**
   * Evaluate the precedence predicates for the context and reduce the result.
   *
   * @param _parser The parser instance.
   * @param _parserCallStack The current parser context object.
   * @returns The simplified semantic context after precedence predicates are
   * evaluated, which will be one of the following values.
   * - {@link NONE}: if the predicate simplifies to `true` after
   * precedence predicates are evaluated.
   * - `null`: if the predicate simplifies to `false` after
   * precedence predicates are evaluated.
   * - `this`: if the semantic context is not changed as a result of
   * precedence predicate evaluation.
   * - A non-`null` {@link SemanticContext}: the new simplified
   * semantic context after precedence predicates are evaluated.
   */
  evalPrecedence(_parser, _parserCallStack) {
    return this;
  }
};
var AND = class _AND extends SemanticContext {
  static {
    __name(this, "AND");
  }
  operands;
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false
   */
  constructor(a, b) {
    super();
    const operands = new HashSet();
    if (a instanceof _AND) {
      a.operands.forEach((o) => {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof _AND) {
      b.operands.forEach((o) => {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      let reduced = null;
      precedencePredicates.forEach((p) => {
        if (reduced === null || p.precedence < reduced.precedence) {
          reduced = p;
        }
      });
      if (reduced) {
        operands.add(reduced);
      }
    }
    this.operands = operands.toArray();
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _AND)) {
      return false;
    }
    return equalArrays(this.operands, other.operands);
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      for (const operand of this.operands) {
        hash = MurmurHash.updateFromComparable(hash, operand);
      }
      hash = MurmurHash.update(hash, 3813686060);
      this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
    }
    return this.cachedHashCode;
  }
  /**
   * {@inheritDoc}
   *
   *
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.
   */
  evaluate(parser, parserCallStack) {
    for (const operand of this.operands) {
      if (!operand.evaluate(parser, parserCallStack)) {
        return false;
      }
    }
    return true;
  }
  evalPrecedence(parser, parserCallStack) {
    let differs = false;
    const operands = [];
    for (const context of this.operands) {
      const evaluated = context.evalPrecedence(parser, parserCallStack);
      differs ||= evaluated !== context;
      if (evaluated === null) {
        return null;
      } else if (evaluated !== SemanticContext.NONE) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return SemanticContext.NONE;
    }
    let result = null;
    operands.forEach((o) => {
      result = result === null ? o : SemanticContext.andContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.operands.map((o) => {
      return o.toString();
    });
    return (s.length > 3 ? s.slice(3) : s).join("&&");
  }
};
var OR = class _OR extends SemanticContext {
  static {
    __name(this, "OR");
  }
  operands;
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true
   */
  constructor(a, b) {
    super();
    const operands = new HashSet();
    if (a instanceof _OR) {
      a.operands.forEach((o) => {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }
    if (b instanceof _OR) {
      b.operands.forEach((o) => {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }
    const precedencePredicates = SemanticContext.filterPrecedencePredicates(operands);
    if (precedencePredicates.length > 0) {
      const s = precedencePredicates.sort((a2, b2) => {
        return a2.compareTo(b2);
      });
      const reduced = s[s.length - 1];
      operands.add(reduced);
    }
    this.operands = operands.toArray();
  }
  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof _OR)) {
      return false;
    } else {
      return equalArrays(this.operands, other.operands);
    }
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      for (const operand of this.operands) {
        hash = MurmurHash.updateFromComparable(hash, operand);
      }
      hash = MurmurHash.update(hash, 3383313031);
      this.cachedHashCode = MurmurHash.finish(hash, this.operands.length + 1);
    }
    return this.cachedHashCode;
  }
  /**
   * The evaluation of predicates by this context is short-circuiting, but unordered.
   */
  evaluate(parser, parserCallStack) {
    for (const operand of this.operands) {
      if (operand.evaluate(parser, parserCallStack)) {
        return true;
      }
    }
    return false;
  }
  evalPrecedence(parser, parserCallStack) {
    let differs = false;
    const operands = [];
    for (const context of this.operands) {
      const evaluated = context.evalPrecedence(parser, parserCallStack);
      differs ||= evaluated !== context;
      if (evaluated === SemanticContext.NONE) {
        return SemanticContext.NONE;
      } else if (evaluated !== null) {
        operands.push(evaluated);
      }
    }
    if (!differs) {
      return this;
    }
    if (operands.length === 0) {
      return null;
    }
    let result = null;
    operands.forEach((o) => {
      result = result === null ? o : SemanticContext.orContext(result, o);
    });
    return result;
  }
  toString() {
    const s = this.operands.map((o) => {
      return o.toString();
    });
    return (s.length > 3 ? s.slice(3) : s).join("||");
  }
};
((SemanticContext2) => {
  class Predicate extends SemanticContext2 {
    static {
      __name(this, "Predicate");
    }
    ruleIndex;
    predIndex;
    isCtxDependent;
    // e.g., $i ref in pred
    constructor(ruleIndex, predIndex, isCtxDependent) {
      super();
      this.ruleIndex = ruleIndex ?? -1;
      this.predIndex = predIndex ?? -1;
      this.isCtxDependent = isCtxDependent ?? false;
    }
    evaluate(parser, outerContext) {
      const localctx = this.isCtxDependent ? outerContext : null;
      return parser.sempred(localctx, this.ruleIndex, this.predIndex);
    }
    hashCode() {
      if (this.cachedHashCode === void 0) {
        let hashCode = MurmurHash.initialize();
        hashCode = MurmurHash.update(hashCode, this.ruleIndex);
        hashCode = MurmurHash.update(hashCode, this.predIndex);
        hashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
        hashCode = MurmurHash.finish(hashCode, 3);
        this.cachedHashCode = hashCode;
      }
      return this.cachedHashCode;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
    }
    toString() {
      return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
  }
  SemanticContext2.Predicate = Predicate;
  class PrecedencePredicate extends SemanticContext2 {
    static {
      __name(this, "PrecedencePredicate");
    }
    precedence;
    constructor(precedence) {
      super();
      this.precedence = precedence ?? 0;
    }
    evaluate(parser, outerContext) {
      return parser.precpred(outerContext, this.precedence);
    }
    evalPrecedence(parser, outerContext) {
      if (parser.precpred(outerContext ?? null, this.precedence)) {
        return SemanticContext2.NONE;
      }
      return null;
    }
    compareTo(other) {
      return this.precedence - other.precedence;
    }
    hashCode() {
      return 31 + this.precedence;
    }
    equals(other) {
      if (this === other) {
        return true;
      }
      return this.precedence === other.precedence;
    }
    toString() {
      return "{" + this.precedence + ">=prec}?";
    }
  }
  SemanticContext2.PrecedencePredicate = PrecedencePredicate;
  SemanticContext2.NONE = new Predicate();
})(SemanticContext || (SemanticContext = {}));

// src/atn/ATNConfig.ts
var ATNConfig = class _ATNConfig {
  static {
    __name(this, "ATNConfig");
  }
  /** The ATN state associated with this configuration */
  state;
  /** What alt (or lexer rule) is predicted by this configuration */
  alt;
  /**
   * We cannot execute predicates dependent upon local context unless
   * we know for sure we are in the correct context. Because there is
   * no way to do this efficiently, we simply cannot evaluate
   * dependent predicates unless we are in the rule that initially
   * invokes the ATN simulator.
   *
   * closure() tracks the depth of how far we dip into the outer context:
   * depth > 0.
   */
  reachesIntoOuterContext = false;
  // Not used in hash code.
  precedenceFilterSuppressed = false;
  // Not used in hash code.
  get semanticContext() {
    return this.#semanticContext;
  }
  cachedHashCode;
  // Shared with LexerATNConfig.
  /**
   * The syntactic context is a graph-structured stack node whose
   * path(s) to the root is the rule invocation(s)
   * chain used to arrive at the state.  The semantic context is
   * the tree of semantic predicates encountered before reaching
   * an ATN state
   */
  #context = null;
  #semanticContext;
  /** Never create config classes directly. Use the factory methods below. */
  constructor(c, state, context, semanticContext) {
    this.state = state;
    this.alt = c.alt;
    this.context = context;
    this.#semanticContext = semanticContext ?? SemanticContext.NONE;
    this.reachesIntoOuterContext = c.reachesIntoOuterContext;
    if (c.precedenceFilterSuppressed !== void 0) {
      this.precedenceFilterSuppressed = c.precedenceFilterSuppressed;
    }
  }
  static duplicate(old, semanticContext) {
    return new _ATNConfig(old, old.state, old.context, semanticContext ?? old.semanticContext);
  }
  static createWithContext(state, alt, context, semanticContext) {
    return new _ATNConfig({ alt }, state, context, semanticContext);
  }
  static createWithConfig(state, config, context) {
    return new _ATNConfig(config, state, context ?? config.context, config.semanticContext);
  }
  static createWithSemanticContext(state, c, semanticContext) {
    return new _ATNConfig(c, state ?? c.state, c.context, semanticContext);
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hashCode = MurmurHash.initialize(7);
      hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
      hashCode = MurmurHash.update(hashCode, this.alt);
      hashCode = MurmurHash.updateFromComparable(hashCode, this.#context);
      hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
      hashCode = MurmurHash.finish(hashCode, 4);
      this.cachedHashCode = hashCode;
    }
    return this.cachedHashCode;
  }
  /**
   * The stack of invoking states leading to the rule/states associated
   * with this config.  We track only those contexts pushed during
   * execution of the ATN simulator.
   */
  get context() {
    return this.#context;
  }
  set context(context) {
    this.#context = context;
    this.cachedHashCode = void 0;
  }
  /**
   * An ATN configuration is equal to another if both have
   * the same state, they predict the same alternative, and
   * syntactic/semantic contexts are the same.
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
  }
  toString(_recog, showAlt = true) {
    let alt = "";
    if (showAlt) {
      alt = "," + this.alt;
    }
    return "(" + this.state + alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }
};

// src/atn/ATNState.ts
var ATNState = class _ATNState {
  static {
    __name(this, "ATNState");
  }
  static INVALID_STATE_NUMBER = -1;
  static INVALID_TYPE = 0;
  static BASIC = 1;
  static RULE_START = 2;
  static BLOCK_START = 3;
  static PLUS_BLOCK_START = 4;
  static STAR_BLOCK_START = 5;
  static TOKEN_START = 6;
  static RULE_STOP = 7;
  static BLOCK_END = 8;
  static STAR_LOOP_BACK = 9;
  static STAR_LOOP_ENTRY = 10;
  static PLUS_LOOP_BACK = 11;
  static LOOP_END = 12;
  static stateType = _ATNState.INVALID_STATE_NUMBER;
  stateNumber = 0;
  ruleIndex = 0;
  // at runtime, we don't have Rule objects
  epsilonOnlyTransitions = false;
  /** Used to cache lookahead during parsing, not used during construction */
  nextTokenWithinRule;
  /** Track the transitions emanating from this ATN state. */
  transitions = [];
  hashCode() {
    return this.stateNumber;
  }
  equals(other) {
    return this.stateNumber === other.stateNumber;
  }
  toString() {
    return `${this.stateNumber}`;
  }
  addTransitionAtIndex(index, transition) {
    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = transition.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }
    this.transitions.splice(index, 0, transition);
  }
  addTransition(transition) {
    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = transition.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== transition.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }
    this.transitions.push(transition);
  }
  setTransition(i, e) {
    this.transitions.splice(i, 1, e);
  }
  removeTransition(index) {
    const t = this.transitions.splice(index, 1);
    return t[0];
  }
};

// src/atn/PredictionContext.ts
var PredictionContext = class _PredictionContext {
  static {
    __name(this, "PredictionContext");
  }
  /**
   * Represents `$` in an array in full context mode, when `$`
   * doesn't mean wildcard: `$ + x = [$,x]`. Here,
   * `$` = {@link EMPTY_RETURN_STATE}.
   */
  static EMPTY_RETURN_STATE = 2147483647;
  static traceATNSimulator = false;
  cachedHashCode;
  constructor(cachedHashCode) {
    this.cachedHashCode = cachedHashCode;
  }
  static calculateEmptyHashCode() {
    let hash = MurmurHash.initialize(31);
    hash = MurmurHash.finish(hash, 0);
    return hash;
  }
  static calculateHashCodeSingle(parent, returnState) {
    let hash = MurmurHash.initialize(31);
    hash = MurmurHash.updateFromComparable(hash, parent);
    hash = MurmurHash.update(hash, returnState);
    hash = MurmurHash.finish(hash, 2);
    return hash;
  }
  static calculateHashCodeList(parents, returnStates) {
    let hash = MurmurHash.initialize(31);
    for (const parent of parents) {
      hash = MurmurHash.updateFromComparable(hash, parent);
    }
    for (const returnState of returnStates) {
      hash = MurmurHash.update(hash, returnState);
    }
    hash = MurmurHash.finish(hash, 2 * parents.length);
    return hash;
  }
  isEmpty() {
    return false;
  }
  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === _PredictionContext.EMPTY_RETURN_STATE;
  }
  hashCode() {
    return this.cachedHashCode;
  }
  toString(_recog) {
    return "";
  }
};

// src/atn/SingletonPredictionContext.ts
var SingletonPredictionContext = class _SingletonPredictionContext extends PredictionContext {
  static {
    __name(this, "SingletonPredictionContext");
  }
  parent;
  returnState;
  constructor(parent, returnState) {
    super(
      parent ? PredictionContext.calculateHashCodeSingle(parent, returnState) : PredictionContext.calculateEmptyHashCode()
    );
    this.parent = parent ?? null;
    this.returnState = returnState;
  }
  getParent(_index) {
    return this.parent;
  }
  getReturnState(_index) {
    return this.returnState;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _SingletonPredictionContext)) {
      return false;
    }
    if (this.hashCode() !== other.hashCode()) {
      return false;
    }
    if (this.returnState !== other.returnState) {
      return false;
    }
    if (this.parent == null) {
      return other.parent == null;
    }
    return this.parent.equals(other.parent);
  }
  toString() {
    const up = this.parent === null ? "" : this.parent.toString();
    if (up.length === 0) {
      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
        return "$";
      }
      return "" + this.returnState;
    } else {
      return "" + this.returnState + " " + up;
    }
  }
  get length() {
    return 1;
  }
};

// src/atn/EmptyPredictionContext.ts
var EmptyPredictionContext = class _EmptyPredictionContext extends SingletonPredictionContext {
  static {
    __name(this, "EmptyPredictionContext");
  }
  /**
   * Represents `$` in local context prediction, which means wildcard.
   * `*+x = *`.
   */
  static instance = new _EmptyPredictionContext();
  constructor() {
    super(void 0, PredictionContext.EMPTY_RETURN_STATE);
  }
  isEmpty() {
    return true;
  }
  getParent() {
    return null;
  }
  getReturnState() {
    return this.returnState;
  }
  equals(other) {
    return this === other;
  }
  toString() {
    return "$";
  }
};

// src/atn/Transition.ts
var Transition = class {
  static {
    __name(this, "Transition");
  }
  static INVALID = 0;
  static EPSILON = 1;
  static RANGE = 2;
  static RULE = 3;
  static PREDICATE = 4;
  // e.g., {isType(input.LT(1))}
  static ATOM = 5;
  static ACTION = 6;
  static SET = 7;
  // ~(A|B) or ~atom, wildcard, which convert to next
  static NOT_SET = 8;
  static WILDCARD = 9;
  static PRECEDENCE = 10;
  /** The target of this transition. */
  target;
  constructor(target) {
    this.target = target;
  }
  /**
   * Determines if the transition is an "epsilon" transition.
   *
   * The default implementation returns `false`.
   *
   * @returns `true` if traversing this transition in the ATN does not
   * consume an input symbol; otherwise, `false` if traversing this
   * transition consumes (matches) an input symbol.
   */
  get isEpsilon() {
    return false;
  }
  get label() {
    return null;
  }
  toString() {
    return "";
  }
};

// src/atn/SetTransition.ts
var SetTransition = class extends Transition {
  static {
    __name(this, "SetTransition");
  }
  set;
  constructor(target, set) {
    super(target);
    if (set) {
      this.set = set;
    } else {
      this.set = IntervalSet.of(Token.INVALID_TYPE, Token.INVALID_TYPE);
    }
  }
  get transitionType() {
    return Transition.SET;
  }
  get label() {
    return this.set;
  }
  matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
    return this.set.contains(symbol);
  }
  toString() {
    return this.set.toString();
  }
};

// src/atn/NotSetTransition.ts
var NotSetTransition = class extends SetTransition {
  static {
    __name(this, "NotSetTransition");
  }
  get transitionType() {
    return Transition.NOT_SET;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
  }
  toString() {
    return "~" + super.toString();
  }
};

// src/misc/MapKeyEqualityOperator.ts
var MapKeyEqualityComparator = class {
  static {
    __name(this, "MapKeyEqualityComparator");
  }
  keyComparator;
  constructor(keyComparator) {
    this.keyComparator = keyComparator;
  }
  hashCode(obj) {
    return this.keyComparator.hashCode(obj.key);
  }
  equals(a, b) {
    return this.keyComparator.equals(a.key, b.key);
  }
};

// src/misc/HashMap.ts
var HashMap = class _HashMap {
  static {
    __name(this, "HashMap");
  }
  backingStore;
  constructor(keyComparer) {
    if (keyComparer instanceof _HashMap) {
      this.backingStore = new HashSet(keyComparer.backingStore);
    } else {
      keyComparer = keyComparer ?? DefaultEqualityComparator.instance;
      this.backingStore = new HashSet(new MapKeyEqualityComparator(keyComparer));
    }
  }
  clear() {
    this.backingStore.clear();
  }
  containsKey(key) {
    return this.backingStore.contains({ key });
  }
  get(key) {
    const bucket = this.backingStore.get({ key });
    if (!bucket) {
      return void 0;
    }
    return bucket.value;
  }
  get isEmpty() {
    return this.backingStore.isEmpty;
  }
  /**
   * Sets the value for a key in the map. If the key is not present in the map, it is added.
   * If the key is present, the value is updated and the old value is returned.
   *
   * @param key The key to set.
   * @param value The value to set.
   *
   * @returns The old value for the key, if present.
   */
  set(key, value) {
    const element = this.backingStore.get({ key, value });
    let result;
    if (!element) {
      this.backingStore.add({ key, value });
    } else {
      result = element.value;
      element.value = value;
    }
    return result;
  }
  /**
   * Sets the value for a key in the map if the key is not already present. Otherwise the value is not changed and
   * the old value is returned.
   *
   * @param key The key to set.
   * @param value The value to set.
   *
   * @returns The current value for the key, if present.
   */
  setIfAbsent(key, value) {
    const element = this.backingStore.get({ key, value });
    let result;
    if (!element) {
      this.backingStore.add({ key, value });
    } else {
      result = element.value;
    }
    return result;
  }
  keys() {
    return this.backingStore.toArray().map((bucket) => {
      return bucket.key;
    });
  }
  values() {
    return this.backingStore.toArray().map((bucket) => {
      return bucket.value;
    });
  }
  get size() {
    return this.backingStore.size;
  }
  hashCode() {
    return this.backingStore.hashCode();
  }
  equals(o) {
    return this.backingStore.equals(o.backingStore);
  }
};

// src/tree/TerminalNode.ts
var TerminalNode = class {
  static {
    __name(this, "TerminalNode");
  }
  parent = null;
  symbol;
  constructor(symbol) {
    this.symbol = symbol;
  }
  getChild(_i) {
    return null;
  }
  getSymbol() {
    return this.symbol;
  }
  getPayload() {
    return this.symbol;
  }
  getSourceInterval() {
    if (this.symbol === null) {
      return Interval.INVALID_INTERVAL;
    }
    const tokenIndex = this.symbol.tokenIndex;
    return new Interval(tokenIndex, tokenIndex);
  }
  getChildCount() {
    return 0;
  }
  accept(visitor) {
    return visitor.visitTerminal(this);
  }
  getText() {
    return this.symbol?.text ?? "";
  }
  toString() {
    if (this.symbol?.type === Token.EOF) {
      return "<EOF>";
    } else {
      return this.symbol?.text ?? "";
    }
  }
  toStringTree() {
    return this.toString();
  }
};

// src/tree/ErrorNode.ts
var ErrorNode = class extends TerminalNode {
  static {
    __name(this, "ErrorNode");
  }
  accept(visitor) {
    return visitor.visitErrorNode(this);
  }
};

// src/CommonToken.ts
var CommonToken = class _CommonToken {
  static {
    __name(this, "CommonToken");
  }
  /**
   * An empty tuple which is used as the default value of
   * {@link source} for tokens that do not have a source.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static EMPTY_SOURCE = [null, null];
  /**
   * These properties share a field to reduce the memory footprint of
   * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from
   * the same source and input stream share a reference to the same
   * {@link Pair} containing these values.
   */
  source;
  tokenIndex;
  start;
  stop;
  /**
   * This is the backing field for {@link #getType} and {@link #setType}.
   */
  type;
  /**
   * The (one-based) line number on which the 1st character of this token was.
   */
  line;
  /**
   * The zero-based index of the first character position in its line.
   */
  column;
  /**
   * The token's channel.
   */
  channel;
  /**
   * This is the backing field for {@link getText} when the token text is
   * explicitly set in the constructor or via {@link setText}.
   */
  #text;
  constructor(details) {
    this.type = details.type;
    this.source = details.source;
    this.tokenIndex = details.tokenIndex ?? -1;
    this.line = details.line ?? 0;
    this.column = details.column ?? -1;
    this.channel = details.channel ?? Token.DEFAULT_CHANNEL;
    this.start = details.start ?? 0;
    this.stop = details.stop ?? 0;
    this.#text = details.text;
    if (details.line === void 0 && details.source[0] !== null) {
      this.line = details.source[0].line;
    }
    if (details.column === void 0 && details.source[0] !== null) {
      this.column = details.source[0].column;
    }
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * If `token` is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link #text} field and
   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
   * be assigned the result of calling {@link getText}, and {@link source}
   * will be constructed from the result of {@link Token.getTokenSource} and
   * {@link Token#getInputStream}.
   *
   * @param token The token to copy.
   */
  static fromToken(token) {
    const source = [token.tokenSource, token.inputStream];
    return new _CommonToken({
      type: token.type,
      line: token.line,
      tokenIndex: token.tokenIndex,
      column: token.column,
      channel: token.channel,
      start: token.start,
      stop: token.stop,
      text: token.text,
      source
    });
  }
  /**
   * Constructs a new {@link CommonToken} with the specified token type and text.
   *
   * @param type The token type.
   * @param text The text of the token.
   */
  static fromType(type, text) {
    return new _CommonToken({ type, text, source: _CommonToken.EMPTY_SOURCE });
  }
  static fromSource(source, type, channel, start, stop) {
    return new _CommonToken({ type, channel, start, stop, source });
  }
  get tokenSource() {
    return this.source[0];
  }
  get inputStream() {
    return this.source[1];
  }
  set inputStream(input) {
    this.source[1] = input;
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * If `oldToken` is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link text} field and
   * the {@link Pair} stored in {@link source}. Otherwise, {@link text} will
   * be assigned the result of calling {@link getText}, and {@link source}
   * will be constructed from the result of {@link Token.getTokenSource} and
   * {@link Token.getInputStream}.
   */
  clone() {
    const t = new _CommonToken({
      source: this.source,
      type: this.type,
      channel: this.channel,
      start: this.start,
      stop: this.stop,
      tokenIndex: this.tokenIndex,
      line: this.line,
      column: this.column,
      text: this.#text
    });
    return t;
  }
  toString(recognizer) {
    let channelStr = "";
    if (this.channel > 0) {
      channelStr = ",channel=" + this.channel;
    }
    let text = this.text;
    if (text) {
      text = text.replace(/\n/g, "\\n");
      text = text.replace(/\r/g, "\\r");
      text = text.replace(/\t/g, "\\t");
    } else {
      text = "<no text>";
    }
    let typeString = String(this.type);
    if (recognizer) {
      typeString = recognizer.vocabulary.getDisplayName(this.type) ?? "<unknown>";
    }
    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + text + "',<" + typeString + ">" + channelStr + "," + this.line + ":" + this.column + "]";
  }
  get text() {
    if (this.#text !== void 0) {
      return this.#text;
    }
    const input = this.inputStream;
    if (!input) {
      return void 0;
    }
    const n2 = input.size;
    if (this.start < n2 && this.stop < n2) {
      return input.getTextFromRange(this.start, this.stop);
    }
    return "<EOF>";
  }
  set text(text) {
    this.#text = text;
  }
  // WritableToken implementation
  setText(text) {
    this.#text = text;
  }
  setType(ttype) {
    this.type = ttype;
  }
  setLine(line) {
    this.line = line;
  }
  setCharPositionInLine(pos) {
    this.column = pos;
  }
  setChannel(channel) {
    this.channel = channel;
  }
  setTokenIndex(index) {
    this.tokenIndex = index;
  }
};

// src/tree/Trees.ts
var Trees = class _Trees {
  static {
    __name(this, "Trees");
  }
  /**
   * Print out a whole tree in LISP form. {@link getNodeText} is used on the
   * node payloads to get the text for the nodes.  Detect
   * parse trees and extract data appropriately.
   */
  static toStringTree(tree, ruleNames, recog) {
    ruleNames = ruleNames ?? null;
    if (recog) {
      ruleNames = recog.ruleNames;
    }
    let s = _Trees.getNodeText(tree, ruleNames);
    s = escapeWhitespace(s, false);
    const c = tree.getChildCount();
    if (c === 0) {
      return s;
    }
    let res = "(" + s + " ";
    if (c > 0) {
      s = _Trees.toStringTree(tree.getChild(0), ruleNames);
      res = res.concat(s);
    }
    for (let i = 1; i < c; i++) {
      s = _Trees.toStringTree(tree.getChild(i), ruleNames);
      res = res.concat(" " + s);
    }
    res = res.concat(")");
    return res;
  }
  static getNodeText(t, ruleNames, recog) {
    ruleNames = ruleNames ?? null;
    if (recog) {
      ruleNames = recog.ruleNames;
    }
    if (ruleNames !== null) {
      if (t instanceof ParserRuleContext) {
        const context = t.ruleContext;
        const altNumber = context.getAltNumber();
        if (altNumber !== 0) {
          return ruleNames[t.ruleIndex] + ":" + altNumber;
        }
        return ruleNames[t.ruleIndex];
      } else if (t instanceof ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode) {
        return t.symbol.text;
      }
    }
    const payload = t.getPayload();
    if (isToken(payload)) {
      return payload.text;
    }
    return String(t.getPayload());
  }
  /**
   * Return ordered list of all children of this node
   */
  static getChildren(t) {
    const list = [];
    for (let i = 0; i < t.getChildCount(); i++) {
      list.push(t.getChild(i));
    }
    return list;
  }
  /**
   * Return a list of all ancestors of this node.  The first node of
   * list is the root and the last is the parent of this node.
   */
  static getAncestors(t) {
    if (t.parent === null) {
      return [];
    }
    let ancestors = [];
    let p = t.parent;
    while (p !== null) {
      ancestors = [p].concat(ancestors);
      p = p.parent;
    }
    return ancestors;
  }
  /**
   * Return true if t is u's parent or a node on path to root from u.
   */
  static isAncestorOf(t, u) {
    if (t === null || u === null || t.parent === null) {
      return false;
    }
    let p = u.parent;
    while (p !== null) {
      if (t === p) {
        return true;
      }
      p = p.parent;
    }
    return false;
  }
  static findAllTokenNodes(t, ttype) {
    return _Trees.findAllNodes(t, ttype, true);
  }
  static findAllRuleNodes(t, ruleIndex) {
    return _Trees.findAllNodes(t, ruleIndex, false);
  }
  static findAllNodes(t, index, findTokens) {
    const nodes = [];
    _Trees.doFindAllNodes(t, index, findTokens, nodes);
    return nodes;
  }
  static descendants(t) {
    let nodes = [t];
    for (let i = 0; i < t.getChildCount(); i++) {
      nodes = nodes.concat(_Trees.descendants(t.getChild(i)));
    }
    return nodes;
  }
  /**
   * Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
   * inclusively using post order traversal. Recursive depth-first-search.
   */
  static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
    const n2 = t.getChildCount();
    for (let i = 0; i < n2; i++) {
      const child = t.getChild(i);
      const r = this.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
      if (r !== null) {
        return r;
      }
    }
    if (t instanceof ParserRuleContext) {
      if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
      (t.stop === null || stopTokenIndex <= t.stop.tokenIndex)) {
        return t;
      }
    }
    return null;
  }
  /**
   * Replace any subtree siblings of root that are completely to left
   * or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
   * node. The source interval for t is not altered to suit smaller range!
   *
   * WARNING: destructive to t.
   */
  static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
    if (t === null) {
      return;
    }
    for (let i = 0; i < t.getChildCount(); i++) {
      const child = t.getChild(i);
      const range = child.getSourceInterval();
      if (t instanceof ParserRuleContext && (range.stop < startIndex || range.start > stopIndex)) {
        if (this.isAncestorOf(child, root)) {
          const abbrev = CommonToken.fromType(Token.INVALID_TYPE, "...");
          t.children[i] = new TerminalNode(abbrev);
        }
      }
    }
  }
  static doFindAllNodes(t, index, findTokens, nodes) {
    if (findTokens && t instanceof TerminalNode) {
      if (t.symbol?.type === index) {
        nodes.push(t);
      }
    } else if (!findTokens && t instanceof ParserRuleContext) {
      if (t.ruleIndex === index) {
        nodes.push(t);
      }
    }
    for (let i = 0; i < t.getChildCount(); i++) {
      _Trees.doFindAllNodes(t.getChild(i), index, findTokens, nodes);
    }
  }
};

// src/ParserRuleContext.ts
var ParserRuleContext = class _ParserRuleContext {
  static {
    __name(this, "ParserRuleContext");
  }
  static empty = new _ParserRuleContext(null);
  start = null;
  stop = null;
  children = [];
  /**
   * What state invoked the rule associated with this context?
   *  The "return address" is the followState of invokingState
   *  If parent is null, this should be -1 this context object represents
   *  the start rule.
   */
  invokingState;
  parent;
  /**
   * A rule context is a record of a single rule invocation. It knows
   * which context invoked it, if any. If there is no parent context, then
   * naturally the invoking state is not valid.  The parent link
   * provides a chain upwards from the current rule invocation to the root
   * of the invocation tree, forming a stack. We actually carry no
   * information about the rule associated with this context (except
   * when parsing). We keep only the state number of the invoking state from
   * the ATN submachine that invoked this. Contrast this with the s
   * pointer inside ParserRuleContext that tracks the current state
   * being "executed" for the current rule.
   *
   * The parent contexts are useful for computing lookahead sets and
   * getting error information.
   *
   * These objects are used during parsing and prediction.
   * For the special case of parsers, we use the subclass
   * ParserRuleContext.
   */
  constructor(parent, invokingStateNumber = -1) {
    this.parent = parent;
    this.invokingState = invokingStateNumber;
  }
  /** Copy a context */
  copyFrom(ctx) {
    this.parent = ctx.parent;
    this.invokingState = ctx.invokingState;
    this.children.slice(0, this.children.length);
    this.start = ctx.start;
    this.stop = ctx.stop;
    if (ctx.children) {
      ctx.children.forEach((child) => {
        if (child instanceof ErrorNode) {
          this.children.push(child);
          child.parent = this;
        }
      });
    }
  }
  // Double dispatch methods for listeners
  enterRule(_listener) {
  }
  exitRule(_listener) {
  }
  addChild(child) {
    this.children.push(child);
    return child;
  }
  /**
   * Used by enterOuterAlt to toss out a RuleContext previously added as
   * we entered a rule. If we have label, we will need to remove
   * generic ruleContext object.
   */
  removeLastChild() {
    this.children.pop();
  }
  addTokenNode(token) {
    const node = new TerminalNode(token);
    this.children.push(node);
    node.parent = this;
    return node;
  }
  addErrorNode(errorNode) {
    errorNode.parent = this;
    this.children.push(errorNode);
    return errorNode;
  }
  getChild(i, type) {
    if (i < 0 || i >= this.children.length) {
      return null;
    }
    if (!type) {
      return this.children[i];
    }
    for (const child of this.children) {
      if (child instanceof type) {
        if (i === 0) {
          return child;
        } else {
          i -= 1;
        }
      }
    }
    return null;
  }
  getToken(ttype, i) {
    if (i < 0 || i >= this.children.length) {
      return null;
    }
    for (const child of this.children) {
      if ("symbol" in child) {
        if (child.symbol?.type === ttype) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
    }
    return null;
  }
  getTokens(ttype) {
    const tokens = [];
    for (const child of this.children) {
      if ("symbol" in child) {
        if (child.symbol?.type === ttype) {
          tokens.push(child);
        }
      }
    }
    return tokens;
  }
  // XXX: base the child type selection on the rule index, not the class.
  getRuleContext(index, ctxType) {
    return this.getChild(index, ctxType);
  }
  // XXX: base the child type selection on the rule index, not the class.
  getRuleContexts(ctxType) {
    const contexts = [];
    for (const child of this.children) {
      if (child instanceof ctxType) {
        contexts.push(child);
      }
    }
    return contexts;
  }
  getChildCount() {
    return this.children.length;
  }
  getSourceInterval() {
    if (this.start === null) {
      return Interval.INVALID_INTERVAL;
    }
    if (this.stop === null || this.stop.tokenIndex < this.start.tokenIndex) {
      return new Interval(this.start.tokenIndex, this.start.tokenIndex - 1);
    }
    return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
  }
  depth() {
    let n2 = 0;
    let p = this;
    while (p !== null) {
      p = p.parent;
      n2 += 1;
    }
    return n2;
  }
  /**
   * A context is empty if there is no invoking state; meaning nobody call
   * current context.
   */
  isEmpty() {
    return this.invokingState === -1;
  }
  get ruleContext() {
    return this;
  }
  get ruleIndex() {
    return -1;
  }
  getPayload() {
    return this;
  }
  getText() {
    if (this.children.length === 0) {
      return "";
    }
    return this.children.map((child) => {
      return child.getText();
    }).join("");
  }
  /**
   * For rule associated with this parse tree internal node, return
   * the outer alternative number used to match the input. Default
   * implementation does not compute nor store this alt num. Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   * to set it.
   */
  getAltNumber() {
    return ATN.INVALID_ALT_NUMBER;
  }
  /**
   * Set the outer alternative number for this context node. Default
   * implementation does nothing to avoid backing field overhead for
   * trees that don't need it.  Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   */
  setAltNumber(_altNumber) {
  }
  accept(visitor) {
    return visitor.visitChildren(this);
  }
  toStringTree(...args) {
    if (args.length < 2) {
      return Trees.toStringTree(this, null, args[0]);
    }
    return Trees.toStringTree(this, args[0], args[1]);
  }
  toString(ruleNames, stop) {
    ruleNames = ruleNames ?? null;
    stop = stop ?? null;
    let p = this;
    let s = "[";
    while (p !== null && p !== stop) {
      if (ruleNames === null) {
        if (!p.isEmpty()) {
          s += p.invokingState;
        }
      } else {
        const ri = p.ruleIndex;
        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
        s += ruleName;
      }
      if (p.parent !== null && (ruleNames !== null || !p.parent.isEmpty())) {
        s += " ";
      }
      p = p.parent;
    }
    s += "]";
    return s;
  }
};

// src/atn/ArrayPredictionContext.ts
var ArrayPredictionContext = class _ArrayPredictionContext extends PredictionContext {
  static {
    __name(this, "ArrayPredictionContext");
  }
  parents = [];
  returnStates = [];
  constructor(parents, returnStates) {
    super(PredictionContext.calculateHashCodeList(parents, returnStates));
    this.parents = parents;
    this.returnStates = returnStates;
    return this;
  }
  isEmpty() {
    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
  }
  get length() {
    return this.returnStates.length;
  }
  getParent(index) {
    return this.parents[index];
  }
  getReturnState(index) {
    return this.returnStates[index];
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _ArrayPredictionContext) || this.hashCode() !== other.hashCode()) {
      return false;
    }
    return equalNumberArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
  }
  toString() {
    if (this.isEmpty()) {
      return "[]";
    }
    const entries = [];
    for (let i = 0; i < this.returnStates.length; i++) {
      if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
        entries.push("$");
        continue;
      }
      entries.push(this.returnStates[i].toString());
      if (this.parents[i]) {
        entries.push(this.parents[i].toString());
      } else {
        entries.push("null");
      }
    }
    return `[${entries.join(", ")}]`;
  }
};

// src/atn/helpers.ts
var createSingletonPredictionContext = /* @__PURE__ */ __name((parent, returnState) => {
  if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
    return EmptyPredictionContext.instance;
  } else {
    return new SingletonPredictionContext(parent, returnState);
  }
}, "createSingletonPredictionContext");

// src/atn/PredictionContextUtils.ts
var predictionContextFromRuleContext = /* @__PURE__ */ __name((atn, outerContext) => {
  if (!outerContext) {
    outerContext = ParserRuleContext.empty;
  }
  if (!outerContext.parent || outerContext === ParserRuleContext.empty) {
    return EmptyPredictionContext.instance;
  }
  const parent = predictionContextFromRuleContext(atn, outerContext.parent);
  const state = atn.states[outerContext.invokingState];
  const transition = state.transitions[0];
  return createSingletonPredictionContext(parent, transition.followState.stateNumber);
}, "predictionContextFromRuleContext");
var getCachedPredictionContext = /* @__PURE__ */ __name((context, contextCache, visited) => {
  if (context.isEmpty()) {
    return context;
  }
  let existing = visited.get(context);
  if (existing) {
    return existing;
  }
  existing = contextCache.get(context);
  if (existing) {
    visited.set(context, existing);
    return existing;
  }
  let changed = false;
  let parents = [];
  for (let i = 0; i < parents.length; i++) {
    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
    if (changed || parent !== context.getParent(i)) {
      if (!changed) {
        parents = [];
        for (let j = 0; j < context.length; j++) {
          parents[j] = context.getParent(j);
        }
        changed = true;
      }
      parents[i] = parent;
    }
  }
  if (!changed) {
    contextCache.add(context);
    visited.set(context, context);
    return context;
  }
  let updated;
  if (parents.length === 0) {
    updated = EmptyPredictionContext.instance;
  } else if (parents.length === 1) {
    updated = createSingletonPredictionContext(parents[0] ?? void 0, context.getReturnState(0));
  } else {
    updated = new ArrayPredictionContext(parents, context.returnStates);
  }
  contextCache.add(updated);
  visited.set(updated, updated);
  visited.set(context, updated);
  return updated;
}, "getCachedPredictionContext");
var merge = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
  if (a === b || a.equals(b)) {
    return a;
  }
  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
    return mergeSingletons(a, b, rootIsWildcard, mergeCache);
  }
  if (rootIsWildcard) {
    if (a instanceof EmptyPredictionContext) {
      return a;
    }
    if (b instanceof EmptyPredictionContext) {
      return b;
    }
  }
  if (a instanceof SingletonPredictionContext) {
    a = new ArrayPredictionContext([a.parent], [a.returnState]);
  }
  if (b instanceof SingletonPredictionContext) {
    b = new ArrayPredictionContext([b.parent], [b.returnState]);
  }
  return mergeArrays(a, b, rootIsWildcard, mergeCache);
}, "merge");
var mergeArrays = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
  if (mergeCache) {
    let previous = mergeCache.get(a, b);
    if (previous) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous) {
      return previous;
    }
  }
  let i = 0;
  let j = 0;
  let k = 0;
  let mergedReturnStates = new Array(a.returnStates.length + b.returnStates.length).fill(0);
  let mergedParents = new Array(a.returnStates.length + b.returnStates.length).fill(null);
  while (i < a.returnStates.length && j < b.returnStates.length) {
    const aParent = a.parents[i];
    const bParent = b.parents[j];
    if (a.returnStates[i] === b.returnStates[j]) {
      const payload = a.returnStates[i];
      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && aParent === null && bParent === null;
      const axAx = aParent !== null && bParent !== null && aParent === bParent;
      if (bothDollars || axAx) {
        mergedParents[k] = aParent;
        mergedReturnStates[k] = payload;
      } else {
        mergedParents[k] = merge(aParent, bParent, rootIsWildcard, mergeCache);
        mergedReturnStates[k] = payload;
      }
      i += 1;
      j += 1;
    } else if (a.returnStates[i] < b.returnStates[j]) {
      mergedParents[k] = aParent;
      mergedReturnStates[k] = a.returnStates[i];
      i += 1;
    } else {
      mergedParents[k] = bParent;
      mergedReturnStates[k] = b.returnStates[j];
      j += 1;
    }
    k += 1;
  }
  if (i < a.returnStates.length) {
    for (let p = i; p < a.returnStates.length; p++) {
      mergedParents[k] = a.parents[p];
      mergedReturnStates[k] = a.returnStates[p];
      k += 1;
    }
  } else {
    for (let p = j; p < b.returnStates.length; p++) {
      mergedParents[k] = b.parents[p];
      mergedReturnStates[k] = b.returnStates[p];
      k += 1;
    }
  }
  if (k < mergedParents.length) {
    if (k === 1) {
      const aNew = createSingletonPredictionContext(mergedParents[0] ?? void 0, mergedReturnStates[0]);
      if (mergeCache !== null) {
        mergeCache.set(a, b, aNew);
      }
      return aNew;
    }
    mergedParents = mergedParents.slice(0, k);
    mergedReturnStates = mergedReturnStates.slice(0, k);
  }
  const merged = new ArrayPredictionContext(mergedParents, mergedReturnStates);
  if (merged.equals(a)) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, a);
    }
    if (PredictionContext.traceATNSimulator) {
      console.log("mergeArrays a=" + a + ",b=" + b + " -> a");
    }
    return a;
  }
  if (merged.equals(b)) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, b);
    }
    return b;
  }
  combineCommonParents(mergedParents);
  if (mergeCache !== null) {
    mergeCache.set(a, b, merged);
  }
  if (PredictionContext.traceATNSimulator) {
    console.log("mergeArrays a=" + a + ",b=" + b + " -> " + merged);
  }
  return merged;
}, "mergeArrays");
var combineCommonParents = /* @__PURE__ */ __name((parents) => {
  const uniqueParents = new HashMap(ObjectEqualityComparator.instance);
  for (const parent of parents) {
    if (parent) {
      if (!uniqueParents.containsKey(parent)) {
        uniqueParents.set(parent, parent);
      }
    }
  }
  for (let q = 0; q < parents.length; q++) {
    if (parents[q]) {
      parents[q] = uniqueParents.get(parents[q]) ?? null;
    }
  }
}, "combineCommonParents");
var mergeSingletons = /* @__PURE__ */ __name((a, b, rootIsWildcard, mergeCache) => {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);
    if (previous !== null) {
      return previous;
    }
    previous = mergeCache.get(b, a);
    if (previous !== null) {
      return previous;
    }
  }
  const rootMerge = mergeRoot(a, b, rootIsWildcard);
  if (rootMerge !== null) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, rootMerge);
    }
    return rootMerge;
  }
  if (a.returnState === b.returnState) {
    const parent = merge(a.parent, b.parent, rootIsWildcard, mergeCache);
    if (parent === a.parent) {
      return a;
    }
    if (parent === b.parent) {
      return b;
    }
    const spc = createSingletonPredictionContext(parent, a.returnState);
    if (mergeCache !== null) {
      mergeCache.set(a, b, spc);
    }
    return spc;
  } else {
    let singleParent = null;
    if (a === b || a.parent !== null && a.parent.equals(b.parent)) {
      singleParent = a.parent;
    }
    if (singleParent !== null) {
      const payloads2 = [a.returnState, b.returnState];
      if (a.returnState > b.returnState) {
        payloads2[0] = b.returnState;
        payloads2[1] = a.returnState;
      }
      const parents2 = [singleParent, singleParent];
      const apc = new ArrayPredictionContext(parents2, payloads2);
      if (mergeCache !== null) {
        mergeCache.set(a, b, apc);
      }
      return apc;
    }
    const payloads = [a.returnState, b.returnState];
    let parents = [a.parent, b.parent];
    if (a.returnState > b.returnState) {
      payloads[0] = b.returnState;
      payloads[1] = a.returnState;
      parents = [b.parent, a.parent];
    }
    const aNew = new ArrayPredictionContext(parents, payloads);
    if (mergeCache !== null) {
      mergeCache.set(a, b, aNew);
    }
    return aNew;
  }
}, "mergeSingletons");
var mergeRoot = /* @__PURE__ */ __name((a, b, rootIsWildcard) => {
  if (rootIsWildcard) {
    if (a === EmptyPredictionContext.instance || b === EmptyPredictionContext.instance) {
      return EmptyPredictionContext.instance;
    }
  } else {
    if (a === EmptyPredictionContext.instance && b === EmptyPredictionContext.instance) {
      return EmptyPredictionContext.instance;
    }
    if (a === EmptyPredictionContext.instance) {
      const payloads = [
        b.returnState,
        PredictionContext.EMPTY_RETURN_STATE
      ];
      const parents = [b.parent, null];
      return new ArrayPredictionContext(parents, payloads);
    }
    if (b === EmptyPredictionContext.instance) {
      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [a.parent, null];
      return new ArrayPredictionContext(parents, payloads);
    }
  }
  return null;
}, "mergeRoot");

// src/atn/LL1Analyzer.ts
var LL1Analyzer = class _LL1Analyzer {
  constructor(atn) {
    this.atn = atn;
  }
  static {
    __name(this, "LL1Analyzer");
  }
  /**
   * Special value added to the lookahead sets to indicate that we hit
   * a predicate during analysis if `seeThruPreds==false`.
   */
  static hitPredicate = Token.INVALID_TYPE;
  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in `s`. If the closure from transition
   * _i_ leads to a semantic predicate before matching a symbol, the
   * element at index *i* of the result will be `undefined`.
   *
   * @param s the ATN state
   * @returns the expected symbols for each outgoing transition of `s`.
   */
  getDecisionLookahead(s) {
    const count = s.transitions.length;
    const look = new Array(count);
    for (let alt = 0; alt < count; alt++) {
      const set = new IntervalSet();
      const lookBusy = new HashSet();
      this.doLook(
        s.transitions[alt].target,
        void 0,
        EmptyPredictionContext.instance,
        set,
        lookBusy,
        new BitSet(),
        false,
        false
      );
      if (set.length > 0 && !set.contains(_LL1Analyzer.hitPredicate)) {
        look[alt] = set;
      }
    }
    return look;
  }
  /**
   * Compute set of tokens that can follow `s` in the ATN in the
   * specified `ctx`.
   *
   * If `ctx` is `null` and the end of the rule containing
   * `s` is reached, {@link Token//EPSILON} is added to the result set.
   * If `ctx` is not `null` and the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.
   *
   * @param s the ATN state
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx the complete parser context, or `null` if the context
   * should be ignored
   *
   * @returns The set of tokens that can follow `s` in the ATN in the
   * specified `ctx`.
   */
  look(s, stopState, ctx) {
    const r = new IntervalSet();
    const lookContext = ctx ? predictionContextFromRuleContext(this.atn, ctx) : null;
    this.doLook(s, stopState, lookContext, r, new HashSet(), new BitSet(), true, true);
    return r;
  }
  /**
   * Compute set of tokens that can follow `s` in the ATN in the
   * specified `ctx`.
   *
   * If `ctx` is `null` and `stopState` or the end of the
   * rule containing `s` is reached, {@link Token//EPSILON} is added to
   * the result set. If `ctx` is not `null` and `addEOF` is
   * `true` and `stopState` or the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.
   *
   * @param s the ATN state.
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx The outer context, or `null` if the outer context should
   * not be used.
   * @param look The result lookahead set.
   * @param lookBusy A set used for preventing epsilon closures in the ATN
   * from causing a stack overflow. Outside code should pass
   * `new CustomizedSet<ATNConfig>` for this argument.
   * @param calledRuleStack A set used for preventing left recursion in the
   * ATN from causing a stack overflow. Outside code should pass
   * `new BitSet()` for this argument.
   * @param seeThruPreds `true` to true semantic predicates as
   * implicitly `true` and "see through them", otherwise `false`
   * to treat semantic predicates as opaque and add {@link hitPredicate} to the
   * result if one is encountered.
   * @param addEOF Add {@link Token//EOF} to the result if the end of the
   * outermost context is reached. This parameter has no effect if `ctx`
   * is `null`.
   */
  doLook(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    const c = ATNConfig.createWithContext(s, 0, ctx);
    if (lookBusy.get(c)) {
      return;
    }
    lookBusy.add(c);
    if (s === stopState) {
      if (!ctx) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
    }
    if (s.constructor.stateType === ATNState.RULE_STOP) {
      if (!ctx) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
      if (ctx !== EmptyPredictionContext.instance) {
        const removed = calledRuleStack.get(s.ruleIndex);
        try {
          calledRuleStack.clear(s.ruleIndex);
          for (let i = 0; i < ctx.length; i++) {
            const returnState = this.atn.states[ctx.getReturnState(i)];
            this.doLook(
              returnState,
              stopState,
              ctx.getParent(i),
              look,
              lookBusy,
              calledRuleStack,
              seeThruPreds,
              addEOF
            );
          }
        } finally {
          if (removed) {
            calledRuleStack.set(s.ruleIndex);
          }
        }
        return;
      }
    }
    for (const t of s.transitions) {
      switch (t.transitionType) {
        case Transition.RULE: {
          if (calledRuleStack.get(t.target.ruleIndex)) {
            continue;
          }
          const newContext = createSingletonPredictionContext(
            ctx ?? void 0,
            t.followState.stateNumber
          );
          try {
            calledRuleStack.set(t.target.ruleIndex);
            this.doLook(
              t.target,
              stopState,
              newContext,
              look,
              lookBusy,
              calledRuleStack,
              seeThruPreds,
              addEOF
            );
          } finally {
            calledRuleStack.clear(t.target.ruleIndex);
          }
          break;
        }
        case Transition.PREDICATE:
        case Transition.PRECEDENCE: {
          if (seeThruPreds) {
            this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else {
            look.addOne(_LL1Analyzer.hitPredicate);
          }
          break;
        }
        case Transition.WILDCARD: {
          look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          break;
        }
        default: {
          if (t.isEpsilon) {
            this.doLook(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else {
            let set = t.label;
            if (set) {
              if (t instanceof NotSetTransition) {
                set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
              }
              look.addSet(set);
            }
          }
          break;
        }
      }
    }
  }
};

// src/atn/ATN.ts
var ATN = class {
  static {
    __name(this, "ATN");
  }
  static INVALID_ALT_NUMBER = 0;
  /** Represents the type of recognizer an ATN applies to */
  static LEXER = 0;
  static PARSER = 1;
  /**
   * Used for runtime deserialization of ATNs from strings
   * The type of the ATN.
   */
  grammarType;
  /** The maximum value for any symbol recognized by a transition in the ATN. */
  maxTokenType;
  states = [];
  /**
   * Each subrule/rule is a decision point and we must track them so we
   * can go back later and build DFA predictors for them.  This includes
   * all the rules, subrules, optional blocks, ()+, ()* etc...
   */
  decisionToState = [];
  /** Maps from rule index to starting state number. */
  ruleToStartState = [];
  // Initialized by the ATN deserializer.
  /** Maps from rule index to stop state number. */
  ruleToStopState = [];
  // Initialized by the ATN deserializer.
  modeNameToStartState = /* @__PURE__ */ new Map();
  /**
   * For lexer ATNs, this maps the rule index to the resulting token type.
   * For parser ATNs, this maps the rule index to the generated bypass token
   * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
   * deserialization option was specified; otherwise, this is `null`
   */
  ruleToTokenType = [];
  // Initialized by the ATN deserializer.
  /**
   * For lexer ATNs, this is an array of {@link LexerAction} objects which may
   * be referenced by action transitions in the ATN
   */
  lexerActions = [];
  modeToStartState = [];
  analyzer;
  constructor(grammarType, maxTokenType) {
    this.grammarType = grammarType;
    this.maxTokenType = maxTokenType;
    this.analyzer = new LL1Analyzer(this);
  }
  /**
   * Compute the set of valid tokens that can occur starting in state `s`.
   * If `ctx` is null, the set of tokens will not include what can follow
   * the rule surrounding `s`. In other words, the set will be
   * restricted to tokens reachable staying within `s`'s rule.
   */
  nextTokens(atnState, ctx) {
    if (!ctx && atnState.nextTokenWithinRule) {
      return atnState.nextTokenWithinRule;
    }
    const next = this.analyzer.look(atnState, void 0, ctx);
    if (!ctx) {
      atnState.nextTokenWithinRule = next;
    }
    return next;
  }
  addState(state) {
    if (state) {
      state.stateNumber = this.states.length;
    }
    this.states.push(state);
  }
  removeState(state) {
    this.states[state.stateNumber] = null;
  }
  defineDecisionState(s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length - 1;
    return s.decision;
  }
  getDecisionState(decision) {
    if (this.decisionToState.length === 0) {
      return null;
    } else {
      return this.decisionToState[decision];
    }
  }
  getNumberOfDecisions() {
    return this.decisionToState.length;
  }
  /**
   * Computes the set of input symbols which could follow ATN state number
   * `stateNumber` in the specified full `context`. This method
   * considers the complete parser context, but does not evaluate semantic
   * predicates (i.e. all predicates encountered during the calculation are
   * assumed true). If a path in the ATN exists from the starting state to the
   * {@link RuleStopState} of the outermost context without matching any
   * symbols, {@link Token//EOF} is added to the returned set.
   *
   * If `context` is `null`, it is treated as
   * {@link ParserRuleContext//EMPTY}.
   *
   * @param stateNumber the ATN state number
   * @param context the full parse context
   *
   * @returns {IntervalSet} The set of potentially valid input symbols which could follow the
   * specified state in the specified context.
   *
   * @throws IllegalArgumentException if the ATN does not contain a state with
   * number `stateNumber`
   */
  getExpectedTokens(stateNumber, context) {
    if (stateNumber < 0 || stateNumber >= this.states.length) {
      throw new Error("Invalid state number.");
    }
    const s = this.states[stateNumber];
    let following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
      return following;
    }
    let ctx = context;
    const expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = this.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = this.nextTokens(rt.followState);
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      ctx = ctx.parent;
    }
    if (following.contains(Token.EPSILON)) {
      expected.addOne(Token.EOF);
    }
    return expected;
  }
};

// src/atn/ATNConfigSet.ts
var KeyTypeEqualityComparer = class _KeyTypeEqualityComparer {
  static {
    __name(this, "KeyTypeEqualityComparer");
  }
  static instance = new _KeyTypeEqualityComparer();
  hashCode(config) {
    let hashCode = 7;
    hashCode = 31 * hashCode + config.state.stateNumber;
    hashCode = 31 * hashCode + config.alt;
    hashCode = 31 * hashCode + config.semanticContext.hashCode();
    return hashCode;
  }
  equals(a, b) {
    if (a === b) {
      return true;
    }
    return a.state.stateNumber === b.state.stateNumber && a.alt === b.alt && a.semanticContext.equals(b.semanticContext);
  }
};
var ATNConfigSet = class {
  static {
    __name(this, "ATNConfigSet");
  }
  /**
   * The reason that we need this is because we don't want the hash map to use
   * the standard hash code and equals. We need all configurations with the
   * same
   * `(s,i,_,semctx)` to be equal. Unfortunately, this key effectively
   * doubles
   * the number of objects associated with ATNConfigs. The other solution is
   * to
   * use a hash table that lets us specify the equals/hashCode operation.
   * All configs but hashed by (s, i, _, pi) not including context. Wiped out
   * when we go readonly as this set becomes a DFA state
   */
  configLookup = new HashSet(KeyTypeEqualityComparer.instance);
  // Track the elements as they are added to the set; supports get(i).
  configs = [];
  uniqueAlt = 0;
  /**
   * Used in parser and lexer. In lexer, it indicates we hit a pred
   * while computing a closure operation. Don't make a DFA state from this
   */
  hasSemanticContext = false;
  dipsIntoOuterContext = false;
  /**
   * Indicates that this configuration set is part of a full context
   * LL prediction. It will be used to determine how to merge $. With SLL
   * it's a wildcard whereas it is not for LL context merge
   */
  fullCtx = false;
  /**
   * Indicates that the set of configurations is read-only. Do not
   * allow any code to manipulate the set; DFA states will point at
   * the sets and they must not change. This does not protect the other
   * fields; in particular, conflictingAlts is set after
   * we've made this readonly
   */
  readOnly = false;
  conflictingAlts = null;
  /**
   * Tracks the first config that has a rule stop state. Avoids frequent linear search for that, when adding
   * a DFA state in the lexer ATN simulator.
   */
  firstStopState;
  #cachedHashCode = -1;
  constructor(fullCtxOrOldSet) {
    if (fullCtxOrOldSet !== void 0) {
      if (typeof fullCtxOrOldSet === "boolean") {
        this.fullCtx = fullCtxOrOldSet ?? true;
      } else {
        const old = fullCtxOrOldSet;
        this.addAll(old.configs);
        this.uniqueAlt = old.uniqueAlt;
        this.conflictingAlts = old.conflictingAlts;
        this.hasSemanticContext = old.hasSemanticContext;
        this.dipsIntoOuterContext = old.dipsIntoOuterContext;
      }
    }
  }
  [Symbol.iterator]() {
    return this.configs[Symbol.iterator]();
  }
  /**
   * Adding a new config means merging contexts with existing configs for
   * `(s, i, pi, _)`, where `s` is the {@link ATNConfig.state}, `i` is the {@link ATNConfig.alt}, and
   * `pi` is the {@link ATNConfig.semanticContext}. We use `(s,i,pi)` as key.
   *
   * This method updates {@link dipsIntoOuterContext} and
   * {@link hasSemanticContext} when necessary.
   */
  add(config, mergeCache = null) {
    if (this.readOnly) {
      throw new Error("This set is readonly");
    }
    if (!this.firstStopState && config.state.constructor.stateType === ATNState.RULE_STOP) {
      this.firstStopState = config;
    }
    this.hasSemanticContext ||= config.semanticContext !== SemanticContext.NONE;
    this.dipsIntoOuterContext ||= config.reachesIntoOuterContext;
    const existing = this.configLookup.getOrAdd(config);
    if (existing === config) {
      this.#cachedHashCode = -1;
      this.configs.push(config);
      return;
    }
    const rootIsWildcard = !this.fullCtx;
    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
    existing.reachesIntoOuterContext ||= config.reachesIntoOuterContext;
    existing.precedenceFilterSuppressed ||= config.precedenceFilterSuppressed;
    existing.context = merged;
  }
  /** Return a List holding list of configs */
  get elements() {
    return this.configs;
  }
  /**
   * Gets the complete set of represented alternatives for the configuration set.
   *
   * @returns the set of represented alternatives in this configuration set
   */
  getAlts() {
    const alts = new BitSet();
    for (const config of this.configs) {
      alts.set(config.alt);
    }
    return alts;
  }
  getPredicates() {
    const preds = [];
    for (const config of this.configs) {
      if (config.semanticContext !== SemanticContext.NONE) {
        preds.push(config.semanticContext);
      }
    }
    return preds;
  }
  getStates() {
    const states = new HashSet();
    for (const config of this.configs) {
      states.add(config.state);
    }
    return states;
  }
  optimizeConfigs(interpreter) {
    if (this.readOnly) {
      throw new Error("This set is readonly");
    }
    if (this.configLookup.size === 0) {
      return;
    }
    for (const config of this.configs) {
      config.context = interpreter.getCachedContext(config.context);
    }
  }
  addAll(coll) {
    for (const config of coll) {
      this.add(config);
    }
    return false;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext && equalArrays(this.configs, other.configs)) {
      return true;
    }
    return false;
  }
  hashCode() {
    if (this.#cachedHashCode === -1) {
      this.#cachedHashCode = this.computeHashCode();
    }
    return this.#cachedHashCode;
  }
  get length() {
    return this.configs.length;
  }
  isEmpty() {
    return this.configs.length === 0;
  }
  contains(item) {
    if (this.configLookup === null) {
      throw new Error("This method is not implemented for readonly sets.");
    }
    return this.configLookup.contains(item);
  }
  containsFast(item) {
    if (this.configLookup === null) {
      throw new Error("This method is not implemented for readonly sets.");
    }
    return this.configLookup.contains(item);
  }
  clear() {
    if (this.readOnly) {
      throw new Error("This set is readonly");
    }
    this.configs = [];
    this.#cachedHashCode = -1;
    this.configLookup = new HashSet(KeyTypeEqualityComparer.instance);
  }
  setReadonly(readOnly) {
    this.readOnly = readOnly;
    if (readOnly) {
      this.configLookup = null;
    }
  }
  toString() {
    return arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }
  computeHashCode() {
    let hash = MurmurHash.initialize();
    this.configs.forEach((config) => {
      hash = MurmurHash.update(hash, config.hashCode());
    });
    hash = MurmurHash.finish(hash, this.configs.length);
    return hash;
  }
};

// src/atn/BasicState.ts
var BasicState = class extends ATNState {
  static {
    __name(this, "BasicState");
  }
  static stateType = ATNState.BASIC;
};

// src/atn/DecisionState.ts
var DecisionState = class extends ATNState {
  static {
    __name(this, "DecisionState");
  }
  decision = -1;
  nonGreedy = false;
};

// src/atn/BlockStartState.ts
var BlockStartState = class extends DecisionState {
  static {
    __name(this, "BlockStartState");
  }
  endState;
};

// src/atn/BlockEndState.ts
var BlockEndState = class extends ATNState {
  static {
    __name(this, "BlockEndState");
  }
  static stateType = ATNState.BLOCK_END;
  startState;
};

// src/atn/LoopEndState.ts
var LoopEndState = class extends ATNState {
  static {
    __name(this, "LoopEndState");
  }
  static stateType = ATNState.LOOP_END;
  loopBackState;
};

// src/atn/RuleStartState.ts
var RuleStartState = class extends ATNState {
  static {
    __name(this, "RuleStartState");
  }
  static stateType = ATNState.RULE_START;
  stopState;
  isLeftRecursiveRule = false;
};

// src/atn/RuleStopState.ts
var RuleStopState = class extends ATNState {
  static {
    __name(this, "RuleStopState");
  }
  static stateType = ATNState.RULE_STOP;
};

// src/atn/TokensStartState.ts
var TokensStartState = class extends DecisionState {
  static {
    __name(this, "TokensStartState");
  }
  static stateType = ATNState.TOKEN_START;
};

// src/atn/PlusLoopbackState.ts
var PlusLoopbackState = class extends DecisionState {
  static {
    __name(this, "PlusLoopbackState");
  }
  static stateType = ATNState.PLUS_LOOP_BACK;
};

// src/atn/StarLoopbackState.ts
var StarLoopbackState = class extends ATNState {
  static {
    __name(this, "StarLoopbackState");
  }
  static stateType = ATNState.STAR_LOOP_BACK;
};

// src/atn/StarLoopEntryState.ts
var StarLoopEntryState = class extends DecisionState {
  static {
    __name(this, "StarLoopEntryState");
  }
  static stateType = ATNState.STAR_LOOP_ENTRY;
  // This is always set during ATN deserialization
  loopBackState;
  /**
   * Indicates whether this state can benefit from a precedence DFA during SLL
   * decision making.
   *
   * This is a computed property that is calculated during ATN deserialization
   * and stored for use in {@link ParserATNSimulator} and
   * {@link ParserInterpreter}.
   *
   * @see `DFA.isPrecedenceDfa`
   */
  precedenceRuleDecision = false;
};

// src/atn/PlusBlockStartState.ts
var PlusBlockStartState = class extends BlockStartState {
  static {
    __name(this, "PlusBlockStartState");
  }
  static stateType = ATNState.PLUS_BLOCK_START;
  loopBackState;
};

// src/atn/StarBlockStartState.ts
var StarBlockStartState = class extends BlockStartState {
  static {
    __name(this, "StarBlockStartState");
  }
  static stateType = ATNState.STAR_BLOCK_START;
};

// src/atn/BasicBlockStartState.ts
var BasicBlockStartState = class extends BlockStartState {
  static {
    __name(this, "BasicBlockStartState");
  }
  static stateType = ATNState.BLOCK_START;
};

// src/atn/AtomTransition.ts
var AtomTransition = class extends Transition {
  static {
    __name(this, "AtomTransition");
  }
  /** The token type or character value; or, signifies special label. */
  labelValue;
  #label;
  constructor(target, label) {
    super(target);
    this.labelValue = label;
    this.#label = IntervalSet.of(label, label);
  }
  get label() {
    return this.#label;
  }
  get transitionType() {
    return Transition.ATOM;
  }
  matches(symbol) {
    return this.labelValue === symbol;
  }
  toString() {
    return this.labelValue.toString();
  }
};

// src/atn/RuleTransition.ts
var RuleTransition = class extends Transition {
  static {
    __name(this, "RuleTransition");
  }
  ruleIndex;
  precedence;
  followState;
  constructor(ruleStart, ruleIndex, precedence, followState) {
    super(ruleStart);
    this.ruleIndex = ruleIndex;
    this.precedence = precedence;
    this.followState = followState;
  }
  get isEpsilon() {
    return true;
  }
  get transitionType() {
    return Transition.RULE;
  }
  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
    return false;
  }
};

// src/atn/RangeTransition.ts
var RangeTransition = class extends Transition {
  static {
    __name(this, "RangeTransition");
  }
  start;
  stop;
  #label = new IntervalSet();
  constructor(target, start, stop) {
    super(target);
    this.start = start;
    this.stop = stop;
    this.#label.addRange(start, stop);
  }
  get label() {
    return this.#label;
  }
  get transitionType() {
    return Transition.RANGE;
  }
  matches(symbol, _minVocabSymbol, _maxVocabSymbol) {
    return symbol >= this.start && symbol <= this.stop;
  }
  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }
};

// src/atn/ActionTransition.ts
var ActionTransition = class extends Transition {
  static {
    __name(this, "ActionTransition");
  }
  ruleIndex;
  actionIndex;
  isCtxDependent;
  constructor(target, ruleIndex, actionIndex, isCtxDependent) {
    super(target);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex ?? -1;
    this.isCtxDependent = isCtxDependent ?? false;
  }
  get isEpsilon() {
    return true;
  }
  get transitionType() {
    return Transition.ACTION;
  }
  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
    return false;
  }
  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }
};

// src/atn/EpsilonTransition.ts
var EpsilonTransition = class extends Transition {
  static {
    __name(this, "EpsilonTransition");
  }
  #outermostPrecedenceReturn;
  constructor(target, outermostPrecedenceReturn = -1) {
    super(target);
    this.#outermostPrecedenceReturn = outermostPrecedenceReturn;
  }
  /**
   * @returns the rule index of a precedence rule for which this transition is
   * returning from, where the precedence value is 0; otherwise, -1.
   *
   * @see ATNConfig.isPrecedenceFilterSuppressed()
   * @see ParserATNSimulator.applyPrecedenceFilter(ATNConfigSet)
   * @since 4.4.1
   */
  get outermostPrecedenceReturn() {
    return this.#outermostPrecedenceReturn;
  }
  get isEpsilon() {
    return true;
  }
  get transitionType() {
    return Transition.EPSILON;
  }
  matches() {
    return false;
  }
  toString() {
    return "epsilon";
  }
};

// src/atn/WildcardTransition.ts
var WildcardTransition = class extends Transition {
  static {
    __name(this, "WildcardTransition");
  }
  get transitionType() {
    return Transition.WILDCARD;
  }
  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
  }
  toString() {
    return ".";
  }
};

// src/atn/AbstractPredicateTransition.ts
var AbstractPredicateTransition = class extends Transition {
  static {
    __name(this, "AbstractPredicateTransition");
  }
  constructor(target) {
    super(target);
  }
};

// src/atn/PredicateTransition.ts
var PredicateTransition = class extends AbstractPredicateTransition {
  static {
    __name(this, "PredicateTransition");
  }
  ruleIndex;
  predIndex;
  isCtxDependent;
  // e.g., $i ref in pred
  constructor(target, ruleIndex, predIndex, isCtxDependent) {
    super(target);
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent;
  }
  get isEpsilon() {
    return true;
  }
  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
    return false;
  }
  get transitionType() {
    return Transition.PREDICATE;
  }
  getPredicate() {
    return new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }
  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }
};

// src/atn/PrecedencePredicateTransition.ts
var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
  static {
    __name(this, "PrecedencePredicateTransition");
  }
  precedence;
  constructor(target, precedence) {
    super(target);
    this.precedence = precedence;
  }
  get isEpsilon() {
    return true;
  }
  matches(_symbol, _minVocabSymbol, _maxVocabSymbol) {
    return false;
  }
  getPredicate() {
    return new SemanticContext.PrecedencePredicate(this.precedence);
  }
  get transitionType() {
    return Transition.PRECEDENCE;
  }
  toString() {
    return this.precedence + " >= _p";
  }
};

// src/atn/LexerActionType.ts
var LexerActionType = {
  /** The type of a {@link LexerChannelAction} action. */
  CHANNEL: 0,
  /** The type of a {@link LexerCustomAction} action */
  CUSTOM: 1,
  /** The type of a {@link LexerModeAction} action. */
  MODE: 2,
  /** The type of a {@link LexerMoreAction} action. */
  MORE: 3,
  /** The type of a {@link LexerPopModeAction} action. */
  POP_MODE: 4,
  /** The type of a {@link LexerPushModeAction} action. */
  PUSH_MODE: 5,
  /** The type of a {@link LexerSkipAction} action. */
  SKIP: 6,
  /** The type of a {@link LexerTypeAction} action. */
  TYPE: 7
};

// src/atn/LexerSkipAction.ts
var LexerSkipAction = class _LexerSkipAction {
  static {
    __name(this, "LexerSkipAction");
  }
  /** Provides a singleton instance of this parameter-less lexer action. */
  static instance = new _LexerSkipAction();
  actionType;
  isPositionDependent = false;
  constructor() {
    this.actionType = LexerActionType.SKIP;
  }
  equals(obj) {
    return obj === this;
  }
  hashCode() {
    return LexerActionType.SKIP;
  }
  execute(lexer) {
    lexer.skip();
  }
  toString() {
    return "skip";
  }
};

// src/atn/LexerChannelAction.ts
var LexerChannelAction = class _LexerChannelAction {
  static {
    __name(this, "LexerChannelAction");
  }
  channel;
  actionType;
  isPositionDependent = false;
  cachedHashCode;
  constructor(channel) {
    this.actionType = LexerActionType.CHANNEL;
    this.channel = channel;
  }
  /**
   * This action is implemented by calling {@link Lexer.setChannel} with the
   * value provided by {@link getChannel}.
   */
  execute(lexer) {
    lexer.channel = this.channel;
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.actionType);
      hash = MurmurHash.update(hash, this.channel);
      this.cachedHashCode = MurmurHash.finish(hash, 2);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerChannelAction)) {
      return false;
    }
    return this.channel === other.channel;
  }
  toString() {
    return "channel(" + this.channel + ")";
  }
};

// src/atn/LexerCustomAction.ts
var LexerCustomAction = class _LexerCustomAction {
  static {
    __name(this, "LexerCustomAction");
  }
  ruleIndex;
  actionIndex;
  actionType;
  isPositionDependent = true;
  cachedHashCode;
  /**
   * Constructs a custom lexer action with the specified rule and action indexes.
   *
   * @param ruleIndex The rule index to use for calls to {@link Recognizer.action}.
   * @param actionIndex The action index to use for calls to {@link Recognizer.action}.
   */
  constructor(ruleIndex, actionIndex) {
    this.actionType = LexerActionType.CUSTOM;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
  }
  /**
   * Custom actions are implemented by calling {@link Lexer.action} with the
   * appropriate rule and action indexes.
   */
  execute(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.actionType);
      hash = MurmurHash.update(hash, this.ruleIndex);
      hash = MurmurHash.update(hash, this.actionIndex);
      this.cachedHashCode = MurmurHash.finish(hash, 3);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerCustomAction)) {
      return false;
    }
    return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
  }
};

// src/atn/LexerMoreAction.ts
var LexerMoreAction = class _LexerMoreAction {
  static {
    __name(this, "LexerMoreAction");
  }
  static instance = new _LexerMoreAction();
  actionType;
  isPositionDependent = false;
  constructor() {
    this.actionType = LexerActionType.MORE;
  }
  equals(obj) {
    return obj === this;
  }
  hashCode() {
    return LexerActionType.MORE;
  }
  /**
   * This action is implemented by calling {@link Lexer.popMode}.
   */
  execute(lexer) {
    lexer.more();
  }
  toString() {
    return "more";
  }
};

// src/atn/LexerTypeAction.ts
var LexerTypeAction = class _LexerTypeAction {
  static {
    __name(this, "LexerTypeAction");
  }
  type;
  actionType;
  isPositionDependent = false;
  cachedHashCode;
  constructor(type) {
    this.actionType = LexerActionType.TYPE;
    this.type = type;
  }
  execute(lexer) {
    lexer.type = this.type;
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.actionType);
      hash = MurmurHash.update(hash, this.type);
      this.cachedHashCode = MurmurHash.finish(hash, 2);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerTypeAction)) {
      return false;
    }
    return this.type === other.type;
  }
  toString() {
    return "type(" + this.type + ")";
  }
};

// src/atn/LexerPushModeAction.ts
var LexerPushModeAction = class _LexerPushModeAction {
  static {
    __name(this, "LexerPushModeAction");
  }
  mode;
  actionType;
  isPositionDependent = false;
  cachedHashCode;
  constructor(mode) {
    this.actionType = LexerActionType.PUSH_MODE;
    this.mode = mode;
  }
  /**
   * This action is implemented by calling {@link Lexer.pushMode} with the
   * value provided by {@link getMode}.
   */
  execute(lexer) {
    lexer.pushMode(this.mode);
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.actionType);
      hash = MurmurHash.update(hash, this.mode);
      this.cachedHashCode = MurmurHash.finish(hash, 2);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerPushModeAction)) {
      return false;
    }
    return this.mode === other.mode;
  }
  toString() {
    return "pushMode(" + this.mode + ")";
  }
};

// src/atn/LexerPopModeAction.ts
var LexerPopModeAction = class _LexerPopModeAction {
  static {
    __name(this, "LexerPopModeAction");
  }
  static instance = new _LexerPopModeAction();
  actionType;
  isPositionDependent = false;
  constructor() {
    this.actionType = LexerActionType.POP_MODE;
  }
  equals(obj) {
    return obj === this;
  }
  hashCode() {
    return LexerActionType.POP_MODE;
  }
  /**
   * This action is implemented by calling {@link Lexer//popMode}.
   */
  execute(lexer) {
    lexer.popMode();
  }
  toString() {
    return "popMode";
  }
};

// src/atn/LexerModeAction.ts
var LexerModeAction = class _LexerModeAction {
  static {
    __name(this, "LexerModeAction");
  }
  mode;
  actionType;
  isPositionDependent = false;
  cachedHashCode;
  constructor(mode) {
    this.actionType = LexerActionType.MODE;
    this.mode = mode;
  }
  /**
   * This action is implemented by calling {@link Lexer.mode} with the
   * value provided by {@link getMode}.
   */
  execute(lexer) {
    lexer.mode = this.mode;
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.actionType);
      hash = MurmurHash.update(hash, this.mode);
      this.cachedHashCode = MurmurHash.finish(hash, 2);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerModeAction)) {
      return false;
    }
    return this.mode === other.mode;
  }
  toString() {
    return "mode(" + this.mode + ")";
  }
};

// src/atn/ATNDeserializer.ts
var ATNDeserializer = class _ATNDeserializer {
  static {
    __name(this, "ATNDeserializer");
  }
  static SERIALIZED_VERSION = 4;
  static stateTypeMapper = /* @__PURE__ */ new Map([
    [ATNState.INVALID_TYPE, void 0],
    [ATNState.BASIC, BasicState],
    [ATNState.RULE_START, RuleStartState],
    [ATNState.BLOCK_START, BasicBlockStartState],
    [ATNState.PLUS_BLOCK_START, PlusBlockStartState],
    [ATNState.STAR_BLOCK_START, StarBlockStartState],
    [ATNState.TOKEN_START, TokensStartState],
    [ATNState.RULE_STOP, RuleStopState],
    [ATNState.BLOCK_END, BlockEndState],
    [ATNState.STAR_LOOP_BACK, StarLoopbackState],
    [ATNState.STAR_LOOP_ENTRY, StarLoopEntryState],
    [ATNState.PLUS_LOOP_BACK, PlusLoopbackState],
    [ATNState.LOOP_END, LoopEndState]
  ]);
  static lexerActionFactoryMapper = /* @__PURE__ */ new Map([
    [LexerActionType.CHANNEL, (data1) => {
      return new LexerChannelAction(data1);
    }],
    [LexerActionType.CUSTOM, (data1, data2) => {
      return new LexerCustomAction(data1, data2);
    }],
    [LexerActionType.MODE, (data1) => {
      return new LexerModeAction(data1);
    }],
    [LexerActionType.MORE, () => {
      return LexerMoreAction.instance;
    }],
    [LexerActionType.POP_MODE, () => {
      return LexerPopModeAction.instance;
    }],
    [LexerActionType.PUSH_MODE, (data1) => {
      return new LexerPushModeAction(data1);
    }],
    [LexerActionType.SKIP, () => {
      return LexerSkipAction.instance;
    }],
    [LexerActionType.TYPE, (data1) => {
      return new LexerTypeAction(data1);
    }]
  ]);
  data = [];
  pos = 0;
  deserializationOptions;
  actionFactories;
  constructor(options) {
    if (!options) {
      options = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: false };
    }
    this.deserializationOptions = options;
  }
  deserialize(data) {
    this.data = data;
    this.checkVersion();
    const atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    const sets = [];
    this.readSets(atn, sets);
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATN.PARSER) {
      this.generateRuleBypassTransitions(atn);
      this.verifyATN(atn);
    }
    return atn;
  }
  checkVersion() {
    const version = this.data[this.pos++];
    if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
      throw new Error("Could not deserialize ATN with version " + version + " (expected " + _ATNDeserializer.SERIALIZED_VERSION + ").");
    }
  }
  readATN() {
    const grammarType = this.data[this.pos++];
    const maxTokenType = this.data[this.pos++];
    return new ATN(grammarType, maxTokenType);
  }
  readStates(atn) {
    let j;
    let stateNumber;
    const loopBackStateNumbers = [];
    const endStateNumbers = [];
    const stateCount = this.data[this.pos++];
    for (let i = 0; i < stateCount; i++) {
      const stateType = this.data[this.pos++];
      if (stateType === ATNState.INVALID_TYPE) {
        atn.addState(null);
        continue;
      }
      const ruleIndex = this.data[this.pos++];
      const s = this.stateFactory(stateType, ruleIndex);
      if (stateType === ATNState.LOOP_END) {
        const loopBackStateNumber = this.data[this.pos++];
        loopBackStateNumbers.push([s, loopBackStateNumber]);
      } else if (s instanceof BlockStartState) {
        const endStateNumber = this.data[this.pos++];
        endStateNumbers.push([s, endStateNumber]);
      }
      atn.addState(s);
    }
    for (j = 0; j < loopBackStateNumbers.length; j++) {
      const pair = loopBackStateNumbers[j];
      pair[0].loopBackState = atn.states[pair[1]] ?? void 0;
    }
    for (j = 0; j < endStateNumbers.length; j++) {
      const pair = endStateNumbers[j];
      pair[0].endState = atn.states[pair[1]];
    }
    const numNonGreedyStates = this.data[this.pos++];
    for (j = 0; j < numNonGreedyStates; j++) {
      stateNumber = this.data[this.pos++];
      atn.states[stateNumber].nonGreedy = true;
    }
    const numPrecedenceStates = this.data[this.pos++];
    for (j = 0; j < numPrecedenceStates; j++) {
      stateNumber = this.data[this.pos++];
      atn.states[stateNumber].isLeftRecursiveRule = true;
    }
  }
  readRules(atn) {
    let i;
    const ruleCount = this.data[this.pos++];
    if (atn.grammarType === ATN.LEXER) {
      atn.ruleToTokenType = new Array(ruleCount);
      atn.ruleToTokenType.fill(0);
    }
    atn.ruleToStartState = new Array(ruleCount);
    atn.ruleToStartState.fill(null);
    for (i = 0; i < ruleCount; i++) {
      const s = this.data[this.pos++];
      atn.ruleToStartState[i] = atn.states[s];
      if (atn.grammarType === ATN.LEXER) {
        const tokenType = this.data[this.pos++];
        atn.ruleToTokenType[i] = tokenType;
      }
    }
    atn.ruleToStopState = new Array(ruleCount);
    atn.ruleToStopState.fill(null);
    for (i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];
      if (!(state instanceof RuleStopState)) {
        continue;
      }
      atn.ruleToStopState[state.ruleIndex] = state;
      atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
  }
  readModes(atn) {
    const modeCount = this.data[this.pos++];
    for (let i = 0; i < modeCount; i++) {
      const s = this.data[this.pos++];
      atn.modeToStartState.push(atn.states[s]);
    }
  }
  readSets(atn, sets) {
    const m2 = this.data[this.pos++];
    for (let i = 0; i < m2; i++) {
      const intervalSet = new IntervalSet();
      sets.push(intervalSet);
      const n2 = this.data[this.pos++];
      const containsEof = this.data[this.pos++];
      if (containsEof !== 0) {
        intervalSet.addOne(-1);
      }
      for (let j = 0; j < n2; j++) {
        const i1 = this.data[this.pos++];
        const i2 = this.data[this.pos++];
        intervalSet.addRange(i1, i2);
      }
    }
  }
  readEdges(atn, sets) {
    let i;
    let j;
    let state;
    let trans;
    let target;
    const edgeCount = this.data[this.pos++];
    for (i = 0; i < edgeCount; i++) {
      const src = this.data[this.pos++];
      const trg = this.data[this.pos++];
      const ttype = this.data[this.pos++];
      const arg1 = this.data[this.pos++];
      const arg2 = this.data[this.pos++];
      const arg3 = this.data[this.pos++];
      trans = this.edgeFactory(atn, ttype, trg, arg1, arg2, arg3, sets);
      const srcState = atn.states[src];
      srcState.addTransition(trans);
    }
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      for (j = 0; j < state.transitions.length; j++) {
        const t = state.transitions[j];
        if (!(t instanceof RuleTransition)) {
          continue;
        }
        let outermostPrecedenceReturn = -1;
        if (atn.ruleToStartState[t.target.ruleIndex].isLeftRecursiveRule) {
          if (t.precedence === 0) {
            outermostPrecedenceReturn = t.target.ruleIndex;
          }
        }
        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
        atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
      }
    }
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      if (state instanceof BlockStartState) {
        if (!state.endState) {
          throw new Error("IllegalState");
        }
        if (state.endState.startState) {
          throw new Error("IllegalState");
        }
        state.endState.startState = state;
      }
      if (state instanceof PlusLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof PlusBlockStartState) {
            target.loopBackState = state;
          }
        }
      } else if (state instanceof StarLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;
          if (target instanceof StarLoopEntryState) {
            target.loopBackState = state;
          }
        }
      }
    }
  }
  readDecisions(atn) {
    const decisionCount = this.data[this.pos++];
    for (let i = 0; i < decisionCount; i++) {
      const s = this.data[this.pos++];
      const decState = atn.states[s];
      atn.decisionToState.push(decState);
      decState.decision = i;
    }
  }
  readLexerActions(atn) {
    if (atn.grammarType === ATN.LEXER) {
      const count = this.data[this.pos++];
      atn.lexerActions = [];
      for (let i = 0; i < count; i++) {
        const actionType = this.data[this.pos++];
        const data1 = this.data[this.pos++];
        const data2 = this.data[this.pos++];
        atn.lexerActions.push(this.lexerActionFactory(actionType, data1, data2));
      }
    }
  }
  generateRuleBypassTransitions(atn) {
    let i;
    const count = atn.ruleToStartState.length;
    for (i = 0; i < count; i++) {
      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for (i = 0; i < count; i++) {
      this.generateRuleBypassTransition(atn, i);
    }
  }
  generateRuleBypassTransition(atn, idx) {
    let i;
    let state;
    const bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);
    const bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);
    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);
    bypassStop.startState = bypassStart;
    let excludeTransition = null;
    let endState = null;
    if (atn.ruleToStartState[idx].isLeftRecursiveRule) {
      endState = null;
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        if (this.stateIsEndStateFor(state, idx)) {
          endState = state;
          excludeTransition = state.loopBackState.transitions[0];
          break;
        }
      }
      if (excludeTransition === null) {
        throw new Error("Couldn't identify final state of the precedence rule prefix section.");
      }
    } else {
      endState = atn.ruleToStopState[idx];
    }
    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];
      for (const transition of state.transitions) {
        if (transition === excludeTransition) {
          continue;
        }
        if (transition.target === endState) {
          transition.target = bypassStop;
        }
      }
    }
    const ruleToStartState = atn.ruleToStartState[idx];
    while (ruleToStartState.transitions.length > 0) {
      const transition = ruleToStartState.removeTransition(ruleToStartState.transitions.length - 1);
      bypassStart.addTransition(transition);
    }
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    if (endState) {
      bypassStop.addTransition(new EpsilonTransition(endState));
    }
    const matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
  }
  stateIsEndStateFor(state, idx) {
    if (state.ruleIndex !== idx) {
      return null;
    }
    if (!(state instanceof StarLoopEntryState)) {
      return null;
    }
    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!(maybeLoopEndState instanceof LoopEndState)) {
      return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
      return state;
    } else {
      return null;
    }
  }
  /**
   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
   * the {@link StarLoopEntryState} field to the correct value.
   *
   * @param atn The ATN.
   */
  markPrecedenceDecisions(atn) {
    for (const state of atn.states) {
      if (!(state instanceof StarLoopEntryState)) {
        continue;
      }
      if (atn.ruleToStartState[state.ruleIndex].isLeftRecursiveRule) {
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (maybeLoopEndState instanceof LoopEndState) {
          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
            state.precedenceRuleDecision = true;
          }
        }
      }
    }
  }
  verifyATN(atn) {
    if (!this.deserializationOptions.verifyATN) {
      return;
    }
    for (const state of atn.states) {
      if (state === null) {
        continue;
      }
      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
      if (state instanceof PlusBlockStartState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof StarLoopEntryState) {
        this.checkCondition(state.loopBackState !== null);
        this.checkCondition(state.transitions.length === 2);
        if (state.transitions[0].target instanceof StarBlockStartState) {
          this.checkCondition(state.transitions[1].target instanceof LoopEndState);
          this.checkCondition(!state.nonGreedy);
        } else if (state.transitions[0].target instanceof LoopEndState) {
          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
          this.checkCondition(state.nonGreedy);
        } else {
          throw new Error("IllegalState");
        }
      } else if (state instanceof StarLoopbackState) {
        this.checkCondition(state.transitions.length === 1);
        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
      } else if (state instanceof LoopEndState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof RuleStartState) {
        this.checkCondition(state.stopState !== null);
      } else if (state instanceof BlockStartState) {
        this.checkCondition(state.endState !== null);
      } else if (state instanceof BlockEndState) {
        this.checkCondition(state.startState !== null);
      } else if (state instanceof DecisionState) {
        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
      } else {
        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
      }
    }
  }
  checkCondition(condition, message) {
    if (!condition) {
      if (message === void 0 || message === null) {
        message = "IllegalState";
      }
      throw message;
    }
  }
  edgeFactory(atn, type, trg, arg1, arg2, arg3, sets) {
    const target = atn.states[trg];
    switch (type) {
      case Transition.EPSILON:
        return new EpsilonTransition(target);
      case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
      case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
      case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
      case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
      case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
      case Transition.SET:
        return new SetTransition(target, sets[arg1]);
      case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
      case Transition.WILDCARD:
        return new WildcardTransition(target);
      default:
        throw new Error("The specified transition type: " + type + " is not valid.");
    }
  }
  stateFactory(type, ruleIndex) {
    const ctor = _ATNDeserializer.stateTypeMapper.get(type);
    if (!ctor) {
      throw new Error("The specified state type " + type + " is not valid.");
    }
    const s = new ctor();
    s.ruleIndex = ruleIndex;
    return s;
  }
  lexerActionFactory(type, data1, data2) {
    const factory = _ATNDeserializer.lexerActionFactoryMapper.get(type);
    if (!factory) {
      throw new Error("The specified lexer action type " + type + " is not valid.");
    }
    return factory(data1, data2);
  }
};

// src/misc/OrderedHashMap.ts
var OrderedHashMap = class _OrderedHashMap extends HashMap {
  static {
    __name(this, "OrderedHashMap");
  }
  #keys = [];
  clear() {
    super.clear();
    this.#keys = [];
  }
  get(key) {
    return super.get(key);
  }
  set(key, value) {
    const result = super.set(key, value);
    if (result === void 0) {
      this.#keys.push(key);
    }
    return result;
  }
  setIfAbsent(key, value) {
    const result = super.setIfAbsent(key, value);
    if (result === void 0) {
      this.#keys.push(key);
    }
    return result;
  }
  /**
   * @returns an iterable of the values in the map, in the order they were inserted.
   */
  values() {
    return {
      [Symbol.iterator]: () => {
        let index = 0;
        return {
          next: /* @__PURE__ */ __name(() => {
            if (index < this.#keys.length) {
              return {
                done: false,
                value: super.get(this.#keys[index++])
              };
            }
            return {
              done: true,
              value: void 0
            };
          }, "next")
        };
      }
    };
  }
  /**
   * @returns an iterable of the keys in the map, in the order they were inserted.
   */
  keys() {
    return this.#keys[Symbol.iterator]();
  }
  equals(o) {
    if (!(o instanceof _OrderedHashMap)) {
      return false;
    }
    return super.equals(o);
  }
};

// src/atn/ATNSerializer.ts
var ATNSerializer = class _ATNSerializer {
  static {
    __name(this, "ATNSerializer");
  }
  atn;
  data = [];
  // Note that we use a LinkedHashMap as a set to maintain insertion order while deduplicating entries with the
  // same key.
  sets = new OrderedHashMap(ObjectEqualityComparator.instance);
  nonGreedyStates = [];
  precedenceStates = [];
  constructor(atn) {
    this.atn = atn;
  }
  static getSerialized(atn) {
    return new _ATNSerializer(atn).serialize();
  }
  static serializeSets(data, sets) {
    data.push(sets.length);
    for (const set of sets) {
      const containsEof = set.contains(Token.EOF);
      const intervals = [...set];
      if (containsEof && intervals[0].stop === Token.EOF) {
        data.push(intervals.length - 1);
      } else {
        data.push(intervals.length);
      }
      data.push(containsEof ? 1 : 0);
      for (const interval of intervals) {
        if (interval.start === Token.EOF) {
          if (interval.stop === Token.EOF) {
            continue;
          } else {
            data.push(0);
          }
        } else {
          data.push(interval.start);
        }
        data.push(interval.stop);
      }
    }
  }
  /**
   * Serialize state descriptors, edge descriptors, and decision -> state map
   *  into list of ints.  Likely out of date, but keeping as it could be helpful:
   *
   *      SERIALIZED_VERSION
   *      UUID (2 longs)
   * 		grammar-type, (ANTLRParser.LEXER, ...)
   *  	max token type,
   *  	num states,
   *  	state-0-type ruleIndex, state-1-type ruleIndex, ... state-i-type ruleIndex optional-arg ...
   *  	num rules,
   *  	rule-1-start-state rule-1-args, rule-2-start-state  rule-2-args, ...
   *  	(args are token type,actionIndex in lexer else 0,0)
   *      num modes,
   *      mode-0-start-state, mode-1-start-state, ... (parser has 0 modes)
   *      num unicode-bmp-sets
   *      bmp-set-0-interval-count intervals, bmp-set-1-interval-count intervals, ...
   *      num unicode-smp-sets
   *      smp-set-0-interval-count intervals, smp-set-1-interval-count intervals, ...
   *	num total edges,
   *      src, trg, edge-type, edge arg1, optional edge arg2 (present always), ...
   *      num decisions,
   *      decision-0-start-state, decision-1-start-state, ...
   *
   *  Convenient to pack into unsigned shorts to make as Java string.
   */
  serialize() {
    this.addPreamble();
    const edgeCount = this.addEdges();
    this.addNonGreedyStates();
    this.addPrecedenceStates();
    this.addRuleStatesAndLexerTokenTypes();
    this.addModeStartStates();
    const setIndices = this.addSets();
    this.addEdges(edgeCount, setIndices);
    this.addDecisionStartStates();
    this.addLexerActions();
    return this.data;
  }
  addPreamble() {
    this.data.push(ATNDeserializer.SERIALIZED_VERSION);
    this.data.push(this.atn.grammarType);
    this.data.push(this.atn.maxTokenType);
  }
  addLexerActions() {
    if (this.atn.grammarType === ATN.LEXER) {
      this.data.push(this.atn.lexerActions.length);
      for (const action of this.atn.lexerActions) {
        this.data.push(action.actionType);
        switch (action.actionType) {
          case LexerActionType.CHANNEL: {
            const channel = action.channel;
            this.data.push(channel);
            this.data.push(0);
            break;
          }
          case LexerActionType.CUSTOM: {
            const ruleIndex = action.ruleIndex;
            const actionIndex = action.actionIndex;
            this.data.push(ruleIndex);
            this.data.push(actionIndex);
            break;
          }
          case LexerActionType.MODE: {
            const mode = action.mode;
            this.data.push(mode);
            this.data.push(0);
            break;
          }
          case LexerActionType.MORE: {
            this.data.push(0);
            this.data.push(0);
            break;
          }
          case LexerActionType.POP_MODE: {
            this.data.push(0);
            this.data.push(0);
            break;
          }
          case LexerActionType.PUSH_MODE: {
            const mode = action.mode;
            this.data.push(mode);
            this.data.push(0);
            break;
          }
          case LexerActionType.SKIP: {
            this.data.push(0);
            this.data.push(0);
            break;
          }
          case LexerActionType.TYPE: {
            const type = action.type;
            this.data.push(type);
            this.data.push(0);
            break;
          }
          default: {
            throw new Error(`The specified lexer action type ${action.actionType} is not valid.`);
          }
        }
      }
    }
  }
  addDecisionStartStates() {
    this.data.push(this.atn.decisionToState.length);
    for (const decStartState of this.atn.decisionToState) {
      this.data.push(decStartState.stateNumber);
    }
  }
  addEdges(...args) {
    switch (args.length) {
      case 0: {
        let edgeCount = 0;
        this.data.push(this.atn.states.length);
        for (const s of this.atn.states) {
          if (s === null) {
            this.data.push(ATNState.INVALID_TYPE);
            continue;
          }
          const stateType = s.constructor.stateType;
          if (s instanceof DecisionState && s.nonGreedy) {
            this.nonGreedyStates.push(s.stateNumber);
          }
          if (s instanceof RuleStartState && s.isLeftRecursiveRule) {
            this.precedenceStates.push(s.stateNumber);
          }
          this.data.push(stateType);
          this.data.push(s.ruleIndex);
          if (s.constructor.stateType === ATNState.LOOP_END) {
            this.data.push(s.loopBackState.stateNumber);
          } else {
            if (s instanceof BlockStartState) {
              this.data.push(s.endState.stateNumber);
            }
          }
          if (s.constructor.stateType !== ATNState.RULE_STOP) {
            edgeCount += s.transitions.length;
          }
          for (const t of s.transitions) {
            const edgeType = t.transitionType;
            if (edgeType === Transition.SET || edgeType === Transition.NOT_SET) {
              const st = t;
              this.sets.set(st.set, true);
            }
          }
        }
        return edgeCount;
      }
      case 2: {
        const [edgeCount, setIndices] = args;
        this.data.push(edgeCount);
        for (const s of this.atn.states) {
          if (s === null) {
            continue;
          }
          if (s.constructor.stateType === ATNState.RULE_STOP) {
            continue;
          }
          for (const t of s.transitions) {
            if (this.atn.states[t.target.stateNumber] === null) {
              throw new Error("Cannot serialize a transition to a removed state.");
            }
            const src = s.stateNumber;
            let trg = t.target.stateNumber;
            const edgeType = t.transitionType;
            let arg1 = 0;
            let arg2 = 0;
            let arg3 = 0;
            switch (edgeType) {
              case Transition.RULE: {
                trg = t.followState.stateNumber;
                arg1 = t.target.stateNumber;
                arg2 = t.ruleIndex;
                arg3 = t.precedence;
                break;
              }
              case Transition.PRECEDENCE: {
                const ppt = t;
                arg1 = ppt.precedence;
                break;
              }
              case Transition.PREDICATE: {
                const pt = t;
                arg1 = pt.ruleIndex;
                arg2 = pt.predIndex;
                arg3 = pt.isCtxDependent ? 1 : 0;
                break;
              }
              case Transition.RANGE: {
                arg1 = t.start;
                arg2 = t.stop;
                if (arg1 === Token.EOF) {
                  arg1 = 0;
                  arg3 = 1;
                }
                break;
              }
              case Transition.ATOM: {
                arg1 = t.labelValue;
                if (arg1 === Token.EOF) {
                  arg1 = 0;
                  arg3 = 1;
                }
                break;
              }
              case Transition.ACTION: {
                const at = t;
                arg1 = at.ruleIndex;
                arg2 = at.actionIndex;
                arg3 = at.isCtxDependent ? 1 : 0;
                break;
              }
              case Transition.SET: {
                arg1 = setIndices.get(t.set);
                break;
              }
              case Transition.NOT_SET: {
                arg1 = setIndices.get(t.set);
                break;
              }
              case Transition.WILDCARD: {
                break;
              }
              default:
            }
            this.data.push(src);
            this.data.push(trg);
            this.data.push(edgeType);
            this.data.push(arg1);
            this.data.push(arg2);
            this.data.push(arg3);
          }
        }
        break;
      }
      default: {
        throw new Error("Invalid number of arguments");
      }
    }
  }
  addSets() {
    _ATNSerializer.serializeSets(this.data, [...this.sets.keys()]);
    const setIndices = new HashMap();
    let setIndex = 0;
    for (const s of this.sets.keys()) {
      setIndices.set(s, setIndex++);
    }
    return setIndices;
  }
  addModeStartStates() {
    const modeCount = this.atn.modeToStartState.length;
    this.data.push(modeCount);
    if (modeCount > 0) {
      for (const modeStartState of this.atn.modeToStartState) {
        this.data.push(modeStartState.stateNumber);
      }
    }
  }
  addRuleStatesAndLexerTokenTypes() {
    const ruleCount = this.atn.ruleToStartState.length;
    this.data.push(ruleCount);
    for (let r = 0; r < ruleCount; r++) {
      const ruleStartState = this.atn.ruleToStartState[r];
      this.data.push(ruleStartState.stateNumber);
      if (this.atn.grammarType === ATN.LEXER) {
        this.data.push(this.atn.ruleToTokenType[r]);
      }
    }
  }
  addPrecedenceStates() {
    this.data.push(this.precedenceStates.length);
    for (const state of this.precedenceStates) {
      this.data.push(state);
    }
  }
  addNonGreedyStates() {
    this.data.push(this.nonGreedyStates.length);
    for (const state of this.nonGreedyStates) {
      this.data.push(state);
    }
  }
};

// src/dfa/DFAState.ts
var DFAState = class _DFAState {
  static {
    __name(this, "DFAState");
  }
  stateNumber = -1;
  configs;
  /**
   * `edges[symbol]` points to target of symbol. Shift up by 1 so (-1) {@link Token.EOF} maps to `edges[0]`.
   */
  edges = [];
  isAcceptState = false;
  /**
   * If accept state, what ttype do we match or alt do we predict? This is set to {@link ATN.INVALID_ALT_NUMBER}
   * when {@link predicates} `!= null` or {@link requiresFullContext}.
   */
  prediction = -1;
  lexerActionExecutor = null;
  /**
   * Indicates that this state was created during SLL prediction that discovered a conflict between the configurations
   * in the state. Future {@link ParserATNSimulator.execATN} invocations immediately jumped doing
   * full context prediction if this field is true.
   */
  requiresFullContext = false;
  /**
   * During SLL parsing, this is a list of predicates associated with the ATN configurations of the DFA state.
   * When we have predicates, {@link requiresFullContext} is `false` since full context prediction evaluates
   * predicates on-the-fly. If this is not null, then {@link prediction} is `ATN.INVALID_ALT_NUMBER`.
   *
   * We only use these for non-{@link #requiresFullContext} but conflicting states. That
   * means we know from the context (it's $ or we don't dip into outer
   * context) that it's an ambiguity not a conflict.
   *
   * This list is computed by {@link ParserATNSimulator#predicateDFAState}.
   */
  predicates = null;
  constructor(configs) {
    if (configs) {
      this.configs = configs;
    }
  }
  static fromState(stateNumber) {
    const result = new _DFAState();
    result.stateNumber = stateNumber;
    return result;
  }
  static fromConfigs(configs) {
    return new _DFAState(configs);
  }
  static hashCode(state) {
    return state.configs.hashCode();
  }
  /**
   * Two {@link DFAState} instances are equal if their ATN configuration sets
   * are the same. This method is used to see if a state already exists.
   *
   * Because the number of alternatives and number of ATN configurations are
   * finite, there is a finite number of DFA states that can be processed.
   * This is necessary to show that the algorithm terminates.
   *
   * Cannot test the DFA state numbers here because in
   * {@link ParserATNSimulator#addDFAState} we need to know if any other state
   * exists that has this exact set of ATN configurations. The
   * {@link #stateNumber} is irrelevant.
   *
   * @param a The first {@link DFAState}.
   * @param b The second {@link DFAState}.
   *
   * @returns `true` if the two states are equal, otherwise `false`.
   */
  static equals(a, b) {
    return a.configs.equals(b.configs);
  }
  /**
   * @returns the set of all alts mentioned by all ATN configurations in this DFA state.
   */
  getAltSet() {
    const alts = /* @__PURE__ */ new Set();
    for (const config of this.configs) {
      alts.add(config.alt);
    }
    if (alts.size === 0) {
      return null;
    }
    return alts;
  }
  toString() {
    let buf = "";
    buf += this.stateNumber;
    buf += ":";
    buf += this.configs ? this.configs.toString() : "";
    if (this.isAcceptState) {
      buf += "=>";
      if (this.predicates) {
        buf += arrayToString(this.predicates);
      } else {
        buf += this.prediction;
      }
    }
    return buf.toString();
  }
};

// src/atn/ATNSimulator.ts
var ATNSimulator = class {
  static {
    __name(this, "ATNSimulator");
  }
  /** Must distinguish between missing edge and edge we know leads nowhere */
  static ERROR = DFAState.fromState(2147483647);
  atn;
  /**
   * The context cache maps all PredictionContext objects that are ==
   * to a single cached copy. This cache is shared across all contexts
   * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
   * to use only cached nodes/graphs in addDFAState(). We don't want to
   * fill this during closure() since there are lots of contexts that
   * pop up but are not used ever again. It also greatly slows down closure().
   *
   * This cache makes a huge difference in memory and a little bit in speed.
   * For the Java grammar on java.*, it dropped the memory requirements
   * at the end from 25M to 16M. We don't store any of the full context
   * graphs in the DFA because they are limited to local context only,
   * but apparently there's a lot of repetition there as well. We optimize
   * the config contexts before storing the config set in the DFA states
   * by literally rebuilding them with cached subgraphs only.
   *
   * I tried a cache for use during closure operations, that was
   * whacked after each adaptivePredict(). It cost a little bit
   * more time I think and doesn't save on the overall footprint
   * so it's not worth the complexity.
   */
  sharedContextCache;
  constructor(atn, sharedContextCache) {
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
  }
  getCachedContext(context) {
    if (!this.sharedContextCache) {
      return context;
    }
    const visited = new HashMap(ObjectEqualityComparator.instance);
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
  }
};

// src/atn/CodePointTransitions.ts
var CodePointTransitions = class _CodePointTransitions {
  static {
    __name(this, "CodePointTransitions");
  }
  /** @returns new {@link AtomTransition}     */
  static createWithCodePoint(target, codePoint) {
    return _CodePointTransitions.createWithCodePointRange(target, codePoint, codePoint);
  }
  /** @returns new {@link AtomTransition} if range represents one atom else {@link SetTransition}. */
  static createWithCodePointRange(target, codePointFrom, codePointTo) {
    return codePointFrom === codePointTo ? new AtomTransition(target, codePointFrom) : new RangeTransition(target, codePointFrom, codePointTo);
  }
};

// src/atn/DecisionInfo.ts
var DecisionInfo = class {
  static {
    __name(this, "DecisionInfo");
  }
  /**
   * The decision number, which is an index into {@link ATN.decisionToState}.
   */
  decision = 0;
  /**
   * The total number of times {@link ParserATNSimulator.adaptivePredict} was
   * invoked for this decision.
   */
  invocations = 0;
  /**
   * The total time spent in {@link ParserATNSimulator.adaptivePredict} for
   * this decision, in nanoseconds.
   *
   * The value of this field contains the sum of differential results obtained
   * by {@link process.hrtime()}, and is not adjusted to compensate for JIT
   * and/or garbage collection overhead. For best accuracy, use a modern Node.js
   * version that provides precise results from {@link process.hrtime()}, and
   * perform profiling in a separate process which is warmed up by parsing the
   * input prior to profiling.
   */
  timeInPrediction = 0;
  /**
   * The sum of the lookahead required for SLL prediction for this decision.
   * Note that SLL prediction is used before LL prediction for performance
   * reasons even when {@link PredictionMode.LL} or
   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION} is used.
   */
  sllTotalLook = 0;
  /**
   * Gets the minimum lookahead required for any single SLL prediction to
   * complete for this decision, by reaching a unique prediction, reaching an
   * SLL conflict state, or encountering a syntax error.
   */
  sllMinLook = 0;
  /**
   * Gets the maximum lookahead required for any single SLL prediction to
   * complete for this decision, by reaching a unique prediction, reaching an
   * SLL conflict state, or encountering a syntax error.
   */
  sllMaxLook = 0;
  /**
   * Gets the {@link LookaheadEventInfo} associated with the event where the
   * {@link sllMaxLook} value was set.
   */
  sllMaxLookEvent;
  /**
   * The sum of the lookahead required for LL prediction for this decision.
   * Note that LL prediction is only used when SLL prediction reaches a
   * conflict state.
   */
  llTotalLook = 0;
  /**
   * Gets the minimum lookahead required for any single LL prediction to
   * complete for this decision. An LL prediction completes when the algorithm
   * reaches a unique prediction, a conflict state (for
   * {@link PredictionMode.LL}, an ambiguity state (for
   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
   */
  llMinLook = 0;
  /**
   * Gets the maximum lookahead required for any single LL prediction to
   * complete for this decision. An LL prediction completes when the algorithm
   * reaches a unique prediction, a conflict state (for
   * {@link PredictionMode.LL}, an ambiguity state (for
   * {@link PredictionMode.LL_EXACT_AMBIG_DETECTION}, or a syntax error.
   */
  llMaxLook = 0;
  /**
   * Gets the {@link LookaheadEventInfo} associated with the event where the
   * {@link llMaxLook} value was set.
   */
  llMaxLookEvent;
  /**
   * A collection of {@link ContextSensitivityInfo} instances describing the
   * context sensitivities encountered during LL prediction for this decision.
   */
  contextSensitivities;
  /**
   * A collection of {@link DecisionEventInfo} instances describing the parse errors
   * identified during calls to {@link ParserATNSimulator.adaptivePredict} for
   * this decision.
   */
  errors;
  /**
   * A collection of {@link AmbiguityInfo} instances describing the
   * ambiguities encountered during LL prediction for this decision.
   */
  ambiguities;
  /**
   * A collection of {@link PredicateEvalInfo} instances describing the
   * results of evaluating individual predicates during prediction for this
   * decision.
   */
  predicateEvals;
  /**
   * The total number of ATN transitions required during SLL prediction for
   * this decision. An ATN transition is determined by the number of times the
   * DFA does not contain an edge that is required for prediction, resulting
   * in on-the-fly computation of that edge.
  /**
   * If DFA caching of SLL transitions is employed by the implementation, ATN
   * computation may cache the computed edge for efficient lookup during
   * future parsing of this decision. Otherwise, the SLL parsing algorithm
   * will use ATN transitions exclusively.
   *
   * @see sllDFATransitions
   * @see ParserATNSimulator.computeTargetState
   * @see LexerATNSimulator.computeTargetState
   */
  sllATNTransitions = 0;
  /**
   * The total number of DFA transitions required during SLL prediction for
   * this decision.
   *
   * If the ATN simulator implementation does not use DFA caching for SLL
   * transitions, this value will be 0.
   *
   * @see ParserATNSimulator.getExistingTargetState
   * @see LexerATNSimulator.getExistingTargetState
   */
  sllDFATransitions = 0;
  /**
   * Gets the total number of times SLL prediction completed in a conflict
   * state, resulting in fallback to LL prediction.
   *
   * Note that this value is not related to whether or not
   * {@link PredictionMode.SLL} may be used successfully with a particular
   * grammar. If the ambiguity resolution algorithm applied to the SLL
   * conflicts for this decision produce the same result as LL prediction for
   * this decision, {@link PredictionMode.SLL} would produce the same overall
   * parsing result as {@link PredictionMode.LL}.
   */
  llFallback = 0;
  /**
   * The total number of ATN transitions required during LL prediction for
   * this decision. An ATN transition is determined by the number of times the
   * DFA does not contain an edge that is required for prediction, resulting
   * in on-the-fly computation of that edge.
   *
   * If DFA caching of LL transitions is employed by the implementation, ATN
   * computation may cache the computed edge for efficient lookup during
   * future parsing of this decision. Otherwise, the LL parsing algorithm will
   * use ATN transitions exclusively.
   *
   * @see llDFATransitions
   * @see ParserATNSimulator.computeTargetState
   * @see LexerATNSimulator.computeTargetState
   */
  llATNTransitions = 0;
  /**
   * The total number of DFA transitions required during LL prediction for
   * this decision.
   *
   * If the ATN simulator implementation does not use DFA caching for LL
   * transitions, this value will be 0.
   *
   * @see ParserATNSimulator.getExistingTargetState
   * @see LexerATNSimulator.getExistingTargetState
   */
  llDFATransitions = 0;
  /**
   * Constructs a new instance of the {@link DecisionInfo} class to contain
   * statistics for a particular decision.
   *
   * @param decision The decision number
   */
  constructor(decision) {
    this.decision = decision;
    this.contextSensitivities = [];
    this.errors = [];
    this.ambiguities = [];
    this.predicateEvals = [];
  }
  toString() {
    return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", sllLookahead=" + this.sllTotalLook + ", sllATNTransitions=" + this.sllATNTransitions + ", sllDFATransitions=" + this.sllDFATransitions + ", llFallback=" + this.llFallback + ", llLookahead=" + this.llTotalLook + ", llATNTransitions=" + this.llATNTransitions + "}";
  }
};

// src/atn/LexerATNConfig.ts
var LexerATNConfig = class _LexerATNConfig extends ATNConfig {
  static {
    __name(this, "LexerATNConfig");
  }
  /**
   * This is the backing field for {@link #getLexerActionExecutor}.
   */
  lexerActionExecutor;
  passedThroughNonGreedyDecision;
  constructor(config, state, context, lexerActionExecutor) {
    super(config, state, context ?? config.context, context ? SemanticContext.NONE : config.semanticContext);
    this.lexerActionExecutor = context ? lexerActionExecutor : config.lexerActionExecutor ?? null;
    this.passedThroughNonGreedyDecision = _LexerATNConfig.checkNonGreedyDecision(config, this.state);
    return this;
  }
  static createWithExecutor(config, state, lexerActionExecutor) {
    return new _LexerATNConfig(config, state, config.context, lexerActionExecutor);
  }
  static createWithConfig(state, config, context) {
    return new _LexerATNConfig(config, state, context ?? null, config.lexerActionExecutor);
  }
  static createWithContext(state, alt, context) {
    return new _LexerATNConfig({ alt }, state, context, null);
  }
  static checkNonGreedyDecision(source, target) {
    return source.passedThroughNonGreedyDecision || "nonGreedy" in target && target.nonGreedy;
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hashCode = MurmurHash.initialize(7);
      hashCode = MurmurHash.update(hashCode, this.state.stateNumber);
      hashCode = MurmurHash.update(hashCode, this.alt);
      hashCode = MurmurHash.updateFromComparable(hashCode, this.context);
      hashCode = MurmurHash.updateFromComparable(hashCode, this.semanticContext);
      hashCode = MurmurHash.update(hashCode, this.passedThroughNonGreedyDecision ? 1 : 0);
      hashCode = MurmurHash.updateFromComparable(hashCode, this.lexerActionExecutor);
      hashCode = MurmurHash.finish(hashCode, 6);
      this.cachedHashCode = hashCode;
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor && other.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
  }
};

// src/BaseErrorListener.ts
var BaseErrorListener = class {
  static {
    __name(this, "BaseErrorListener");
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
  }
};

// src/ConsoleErrorListener.ts
var ConsoleErrorListener = class _ConsoleErrorListener extends BaseErrorListener {
  static {
    __name(this, "ConsoleErrorListener");
  }
  /**
   * Provides a default instance of {@link ConsoleErrorListener}.
   */
  static instance = new _ConsoleErrorListener();
  syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, _e) {
    console.error("line " + line + ":" + charPositionInLine + " " + msg);
  }
};

// src/ProxyErrorListener.ts
var ProxyErrorListener = class extends BaseErrorListener {
  constructor(delegates) {
    super();
    this.delegates = delegates;
    return this;
  }
  static {
    __name(this, "ProxyErrorListener");
  }
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.forEach((d) => {
      d.syntaxError(recognizer, offendingSymbol, line, column, msg, e);
    });
  }
  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.forEach((d) => {
      d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    });
  }
  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    this.delegates.forEach((d) => {
      d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs);
    });
  }
  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    this.delegates.forEach((d) => {
      d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs);
    });
  }
};

// src/Recognizer.ts
var Recognizer = class _Recognizer {
  static {
    __name(this, "Recognizer");
  }
  static EOF = -1;
  static tokenTypeMapCache = /* @__PURE__ */ new Map();
  static ruleIndexMapCache = /* @__PURE__ */ new Map();
  interpreter;
  listeners = [ConsoleErrorListener.instance];
  stateNumber = -1;
  checkVersion(toolVersion) {
    const runtimeVersion = "4.13.1";
    if (runtimeVersion !== toolVersion) {
      console.error("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
    }
  }
  addErrorListener(listener) {
    this.listeners.push(listener);
  }
  removeErrorListeners() {
    this.listeners = [];
  }
  removeErrorListener(listener) {
    for (let i = 0; i < this.listeners.length; i++) {
      if (this.listeners[i] === listener) {
        this.listeners.splice(i, 1);
        return;
      }
    }
  }
  getErrorListeners() {
    return this.listeners;
  }
  getTokenTypeMap() {
    const vocabulary = this.vocabulary;
    let result = _Recognizer.tokenTypeMapCache.get(vocabulary);
    if (!result) {
      result = /* @__PURE__ */ new Map();
      for (let i = 0; i <= this.atn.maxTokenType; i++) {
        const literalName = vocabulary.getLiteralName(i);
        if (literalName) {
          result.set(literalName, i);
        }
        const symbolicName = vocabulary.getSymbolicName(i);
        if (symbolicName) {
          result.set(symbolicName, i);
        }
      }
      result.set("EOF", Token.EOF);
      _Recognizer.tokenTypeMapCache.set(vocabulary, result);
    }
    return result;
  }
  /**
   * Get a map from rule names to rule indexes.
   * Used for XPath and tree pattern compilation.
   */
  getRuleIndexMap() {
    const ruleNames = this.ruleNames;
    let result = _Recognizer.ruleIndexMapCache.get(ruleNames);
    if (!result) {
      result = /* @__PURE__ */ new Map();
      ruleNames.forEach((ruleName, idx) => {
        return result.set(ruleName, idx);
      });
      _Recognizer.ruleIndexMapCache.set(ruleNames, result);
    }
    return result;
  }
  getTokenType(tokenName) {
    const ttype = this.getTokenTypeMap().get(tokenName);
    if (ttype) {
      return ttype;
    }
    return Token.INVALID_TYPE;
  }
  /** What is the error header, normally line/character position information? */
  getErrorHeader(e) {
    const line = e.offendingToken?.line;
    const column = e.offendingToken?.column;
    return "line " + line + ":" + column;
  }
  get errorListenerDispatch() {
    return new ProxyErrorListener(this.listeners);
  }
  /**
   * subclass needs to override these if there are semantic predicates or actions
   * that the ATN interp needs to execute
   */
  sempred(_localctx, _ruleIndex, _actionIndex) {
    return true;
  }
  // TODO: make localCtx an optional parameter, not optional null.
  precpred(_localctx, _precedence) {
    return true;
  }
  action(_localctx, _ruleIndex, _actionIndex) {
  }
  get atn() {
    return this.interpreter.atn;
  }
  get state() {
    return this.stateNumber;
  }
  set state(state) {
    this.stateNumber = state;
  }
  getParseInfo() {
    return void 0;
  }
};

// src/CommonTokenFactory.ts
var CommonTokenFactory = class _CommonTokenFactory {
  static {
    __name(this, "CommonTokenFactory");
  }
  /**
   * The default {@link CommonTokenFactory} instance.
   *
   *
   * This token factory does not explicitly copy token text when constructing
   * tokens.
   */
  static DEFAULT = new _CommonTokenFactory();
  /**
   * Indicates whether {@link CommonToken.setText} should be called after
   * constructing tokens to explicitly set the text. This is useful for cases
   * where the input stream might not be able to provide arbitrary substrings
   * of text from the input after the lexer creates a token (e.g. the
   * implementation of {@link CharStream.getText} in
   * {@link UnbufferedCharStream} throws an
   * {@link UnsupportedOperationException}). Explicitly setting the token text
   * allows {@link Token.getText} to be called at any time regardless of the
   * input stream implementation.
   *
   *
   * The default value is `false` to avoid the performance and memory
   * overhead of copying text for every token unless explicitly requested.
   */
  copyText = false;
  constructor(copyText) {
    this.copyText = copyText ?? false;
  }
  create(source, type, text, channel, start, stop, line, column) {
    const t = CommonToken.fromSource(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text) {
      t.text = text;
    } else if (this.copyText && source[1] !== null) {
      t.text = source[1].getTextFromRange(start, stop);
    }
    return t;
  }
};

// src/RecognitionException.ts
var RecognitionException = class _RecognitionException extends Error {
  static {
    __name(this, "RecognitionException");
  }
  ctx;
  /**
   * The current {@link Token} when an error occurred. Since not all streams
   * support accessing symbols by index, we have to track the {@link Token}
   * instance itself
   */
  offendingToken = null;
  /**
   * Get the ATN state number the parser was in at the time the error
   * occurred. For {@link NoViableAltException} and
   * {@link LexerNoViableAltException} exceptions, this is the
   * {@link DecisionState} number. For others, it is the state whose outgoing
   * edge we couldn't match.
   */
  offendingState = -1;
  recognizer;
  input;
  constructor(params) {
    super(params.message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _RecognitionException);
    }
    this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    if (this.recognizer !== null) {
      this.offendingState = this.recognizer.state;
    }
  }
  /**
   * Gets the set of input symbols which could potentially follow the
   * previously matched symbol at the time this exception was thrown.
   *
   * If the set of expected tokens is not known and could not be computed,
   * this method returns `null`.
   *
   * @returns The set of token types that could potentially follow the current
   * state in the ATN, or `null` if the information is not available.
   */
  getExpectedTokens() {
    if (this.recognizer !== null && this.ctx !== null) {
      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
      return null;
    }
  }
  // If the state number is not known, this method returns -1.
  toString() {
    return this.message;
  }
};

// src/LexerNoViableAltException.ts
var LexerNoViableAltException = class extends RecognitionException {
  static {
    __name(this, "LexerNoViableAltException");
  }
  startIndex;
  deadEndConfigs;
  constructor(lexer, input, startIndex, deadEndConfigs) {
    super({ message: "", recognizer: lexer, input, ctx: null });
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
  }
  toString() {
    let symbol = "";
    if (this.input && this.startIndex >= 0 && this.startIndex < this.input.size) {
      symbol = this.input.getTextFromRange(this.startIndex, this.startIndex);
    }
    return `LexerNoViableAltException(${symbol})`;
  }
};

// src/Lexer.ts
var Lexer = class _Lexer extends Recognizer {
  static {
    __name(this, "Lexer");
  }
  static DEFAULT_MODE = 0;
  static MORE = -2;
  static SKIP = -3;
  static DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
  static HIDDEN = Token.HIDDEN_CHANNEL;
  options = {
    minDFAEdge: 0,
    maxDFAEdge: 256,
    minCodePoint: 0,
    maxCodePoint: 1114111
  };
  /**
   * What character index in the stream did the current token start at?
   *  Needed, for example, to get the text for current token.  Set at
   *  the start of nextToken.
   */
  tokenStartCharIndex = -1;
  /** The channel number for the current token */
  channel = 0;
  /** The token type for the current token */
  type = 0;
  mode = _Lexer.DEFAULT_MODE;
  /** The start column of the current token (the one that was last read by `nextToken`). */
  currentTokenColumn = 0;
  /**
   * The line on which the first character of the current token (the one that was last read by `nextToken`) resides.
   */
  currentTokenStartLine = 0;
  input;
  /**
   * The goal of all lexer rules/methods is to create a token object.
   *  This is an instance variable as multiple rules may collaborate to
   *  create a single token.  nextToken will return this object after
   *  matching lexer rule(s).  If you subclass to allow multiple token
   *  emissions, then set this to the last token to be matched or
   *  something non-null so that the auto token emit mechanism will not
   *  emit another token.
   */
  token = null;
  /**
   * Once we see EOF on char stream, next token will be EOF.
   * If you have DONE : EOF ; then you see DONE EOF.
   */
  hitEOF = false;
  factory;
  #modeStack = [];
  /**
   * The text to be used for the next token. If this is not null, then the text
   * for the next token is fixed and is not subject to change in the normal
   * workflow of the lexer.
   */
  #text;
  constructor(input, options) {
    super();
    this.options = { ...this.options, ...options };
    this.input = input;
    this.factory = CommonTokenFactory.DEFAULT;
  }
  reset(seekBack = true) {
    if (seekBack) {
      this.input.seek(0);
    }
    this.token = null;
    this.type = Token.INVALID_TYPE;
    this.channel = Token.DEFAULT_CHANNEL;
    this.tokenStartCharIndex = -1;
    this.currentTokenColumn = -1;
    this.currentTokenStartLine = -1;
    this.#text = void 0;
    this.hitEOF = false;
    this.mode = _Lexer.DEFAULT_MODE;
    this.#modeStack = [];
    this.interpreter.reset();
  }
  /** @returns a token from this source; i.e., match a token on the char stream. */
  nextToken() {
    if (this.input === null) {
      throw new Error("nextToken requires a non-null input stream.");
    }
    const tokenStartMarker = this.input.mark();
    try {
      while (true) {
        if (this.hitEOF) {
          this.emitEOF();
          return this.token;
        }
        this.token = null;
        this.channel = Token.DEFAULT_CHANNEL;
        this.tokenStartCharIndex = this.input.index;
        this.currentTokenColumn = this.interpreter.column;
        this.currentTokenStartLine = this.interpreter.line;
        this.#text = void 0;
        let continueOuter = false;
        while (true) {
          this.type = Token.INVALID_TYPE;
          let ttype = _Lexer.SKIP;
          try {
            ttype = this.interpreter.match(this.input, this.mode);
          } catch (e) {
            if (e instanceof LexerNoViableAltException) {
              this.notifyListeners(e);
              this.recover(e);
            } else {
              throw e;
            }
          }
          if (this.input.LA(1) === Token.EOF) {
            this.hitEOF = true;
          }
          if (this.type === Token.INVALID_TYPE) {
            this.type = ttype;
          }
          if (this.type === _Lexer.SKIP) {
            continueOuter = true;
            break;
          }
          if (this.type !== _Lexer.MORE) {
            break;
          }
        }
        if (continueOuter) {
          continue;
        }
        if (this.token === null) {
          this.emit();
        }
        return this.token;
      }
    } finally {
      this.input.release(tokenStartMarker);
    }
  }
  /**
   * Instruct the lexer to skip creating a token for current lexer rule
   * and look for another token. nextToken() knows to keep looking when
   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
   * if token==null at end of any token rule, it creates one for you
   * and emits it.
   */
  skip() {
    this.type = _Lexer.SKIP;
  }
  more() {
    this.type = _Lexer.MORE;
  }
  pushMode(m2) {
    if (LexerATNSimulator.debug) {
      console.log("pushMode " + m2);
    }
    this.#modeStack.push(this.mode);
    this.mode = m2;
  }
  popMode() {
    if (this.#modeStack.length === 0) {
      throw new Error("Empty Stack");
    }
    if (LexerATNSimulator.debug) {
      console.log("popMode back to " + this.#modeStack.slice(0, -1));
    }
    this.mode = this.#modeStack.pop();
    return this.mode;
  }
  get modeStack() {
    return this.#modeStack;
  }
  /**
   * By default does not support multiple emits per nextToken invocation
   * for efficiency reasons. Subclass and override this method, nextToken,
   * and getToken (to push tokens into a list and pull from that list
   * rather than a single variable as this implementation does).
   */
  emitToken(token) {
    this.token = token;
  }
  /**
   * The standard method called to automatically emit a token at the
   * outermost lexical rule. The token object should point into the
   * char buffer start..stop. If there is a text override in 'text',
   * use that to set the token's text. Override this method to emit
   * custom Token objects or provide a new factory.
   */
  emit() {
    const t = this.factory.create(
      [this, this.input],
      this.type,
      this.#text,
      this.channel,
      this.tokenStartCharIndex,
      this.getCharIndex() - 1,
      this.currentTokenStartLine,
      this.currentTokenColumn
    );
    this.emitToken(t);
    return t;
  }
  emitEOF() {
    const eof = this.factory.create(
      [this, this.input],
      Token.EOF,
      void 0,
      Token.DEFAULT_CHANNEL,
      this.input.index,
      this.input.index - 1,
      this.line,
      this.column
    );
    this.emitToken(eof);
    return eof;
  }
  /** What is the index of the current character of lookahead? */
  getCharIndex() {
    return this.input.index;
  }
  /**
   * Return a list of all Token objects in input char stream.
   * Forces load of all tokens. Does not include EOF token.
   */
  getAllTokens() {
    const tokens = [];
    let t = this.nextToken();
    while (t.type !== Token.EOF) {
      tokens.push(t);
      t = this.nextToken();
    }
    return tokens;
  }
  notifyListeners(e) {
    const start = this.tokenStartCharIndex;
    const stop = this.input.index;
    const text = this.input.getTextFromRange(start, stop);
    const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
    this.errorListenerDispatch.syntaxError(this, null, this.currentTokenStartLine, this.currentTokenColumn, msg, e);
  }
  getErrorDisplay(s) {
    return s;
  }
  getErrorDisplayForChar(c) {
    if (c.charCodeAt(0) === Token.EOF) {
      return "<EOF>";
    }
    if (c === "\n") {
      return "\\n";
    }
    if (c === "	") {
      return "\\t";
    }
    if (c === "\r") {
      return "\\r";
    }
    return c;
  }
  getCharErrorDisplay(c) {
    return "'" + this.getErrorDisplayForChar(c) + "'";
  }
  /**
   * Lexers can normally match any char in it's vocabulary after matching
   * a token, so do the easy thing and just kill a character and hope
   * it all works out. You can instead use the rule invocation stack
   * to do sophisticated error recovery if you are in a fragment rule.
   */
  recover(re) {
    if (this.input.LA(1) !== Token.EOF) {
      if (re instanceof LexerNoViableAltException) {
        this.interpreter.consume(this.input);
      } else {
        this.input.consume();
      }
    }
  }
  get inputStream() {
    return this.input;
  }
  set inputStream(input) {
    this.reset(false);
    this.input = input;
  }
  set tokenFactory(factory) {
    this.factory = factory;
  }
  get tokenFactory() {
    return this.factory;
  }
  get sourceName() {
    return this.input.getSourceName();
  }
  get line() {
    return this.interpreter.line;
  }
  set line(line) {
    this.interpreter.line = line;
  }
  get column() {
    return this.interpreter.column;
  }
  set column(column) {
    this.interpreter.column = column;
  }
  get text() {
    if (this.#text) {
      return this.#text;
    } else {
      return this.interpreter.getText(this.input);
    }
  }
  set text(text) {
    this.#text = text;
  }
};

// src/dfa/DFASerializer.ts
var DFASerializer = class {
  static {
    __name(this, "DFASerializer");
  }
  dfa;
  vocabulary;
  constructor(dfa, vocabulary) {
    this.dfa = dfa;
    this.vocabulary = vocabulary;
  }
  toString() {
    if (!this.dfa.s0) {
      return "";
    }
    let buf = "";
    const states = this.dfa.getStates();
    for (const s of states) {
      let n2 = 0;
      n2 = s.edges.length;
      for (let i = 0; i < n2; i++) {
        const t = s.edges[i];
        if (t && t.stateNumber !== 2147483647) {
          buf += this.getStateString(s);
          const label = this.getEdgeLabel(i);
          buf += "-";
          buf += label;
          buf += "->";
          buf += this.getStateString(t);
          buf += "\n";
        }
      }
    }
    return buf;
  }
  getEdgeLabel(i) {
    const name = this.vocabulary.getDisplayName(i - 1);
    return `${name}`;
  }
  getStateString(s) {
    const n2 = s.stateNumber;
    const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + n2 + (s.requiresFullContext ? "^" : "");
    if (s.isAcceptState) {
      if (s.predicates !== null) {
        return `${baseStateStr}=>${s.predicates.toString()}`;
      }
      return `${baseStateStr}=>${s.prediction}`;
    } else {
      return `${baseStateStr}`;
    }
  }
};

// src/dfa/LexerDFASerializer.ts
var LexerDFASerializer = class extends DFASerializer {
  static {
    __name(this, "LexerDFASerializer");
  }
  constructor(dfa) {
    super(dfa, Vocabulary.EMPTY_VOCABULARY);
  }
  getEdgeLabel = /* @__PURE__ */ __name((i) => {
    return "'" + String.fromCharCode(i) + "'";
  }, "getEdgeLabel");
};

// src/dfa/DFA.ts
var DFA = class {
  static {
    __name(this, "DFA");
  }
  s0;
  decision;
  /** From which ATN state did we create this DFA? */
  atnStartState;
  /**
   * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
   * start state {@link #s0} which is not stored in {@link #states}. The
   * {@link DFAState#edges} array for this start state contains outgoing edges
   * supplying individual start states corresponding to specific precedence
   * values.
   *
   * @returns `true` if this is a precedence DFA; otherwise, `false`.
   */
  isPrecedenceDfa;
  /**
   * A mapping from an ATNConfigSet hash to a DFAState.
   * Used to quick look up the DFA state for a particular configuration set.
   */
  states = /* @__PURE__ */ new Map();
  constructor(atnStartState, decision) {
    this.atnStartState = atnStartState;
    this.decision = decision ?? 0;
    let precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState) {
      if (atnStartState.precedenceRuleDecision) {
        precedenceDfa = true;
        this.s0 = DFAState.fromState(-1);
      }
    }
    this.isPrecedenceDfa = precedenceDfa;
  }
  [Symbol.iterator] = () => {
    return this.states.values()[Symbol.iterator]();
  };
  /**
   * Get the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
    @returns The start state corresponding to the specified precedence, or
   * `null` if no start state exists for the specified precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see #isPrecedenceDfa
   */
  getPrecedenceStartState = /* @__PURE__ */ __name((precedence) => {
    if (!this.isPrecedenceDfa) {
      throw new Error(`Only precedence DFAs may contain a precedence start state.`);
    }
    if (!this.s0 || !this.s0.edges || precedence < 0 || precedence >= this.s0.edges.length) {
      return void 0;
    }
    return this.s0.edges[precedence];
  }, "getPrecedenceStartState");
  /**
   * Set the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @param startState The start state corresponding to the specified precedence.
   */
  setPrecedenceStartState = /* @__PURE__ */ __name((precedence, startState) => {
    if (!this.isPrecedenceDfa) {
      throw new Error(`Only precedence DFAs may contain a precedence start state.`);
    }
    if (precedence < 0 || !this.s0) {
      return;
    }
    this.s0.edges[precedence] = startState;
  }, "setPrecedenceStartState");
  /**
   * @returns a list of all states in this DFA, ordered by state number.
   */
  getStates() {
    const result = [...this.states.values()];
    result.sort((o1, o2) => {
      return o1.stateNumber - o2.stateNumber;
    });
    return result;
  }
  getState(state) {
    return this.states.get(state.configs.hashCode()) ?? null;
  }
  getStateForConfigs(configs) {
    return this.states.get(configs.hashCode()) ?? null;
  }
  addState(state) {
    const hash = state.configs.hashCode();
    if (this.states.has(hash)) {
      return;
    }
    this.states.set(hash, state);
    state.stateNumber = this.states.size - 1;
  }
  toString(vocabulary) {
    if (!vocabulary) {
      return this.toString(Vocabulary.EMPTY_VOCABULARY);
    }
    if (!this.s0) {
      return "";
    }
    const serializer = new DFASerializer(this, vocabulary);
    return serializer.toString() ?? "";
  }
  toLexerString() {
    if (!this.s0) {
      return "";
    }
    const serializer = new LexerDFASerializer(this);
    return serializer.toString() ?? "";
  }
  get length() {
    return this.states.size;
  }
};

// src/atn/LexerIndexedCustomAction.ts
var LexerIndexedCustomAction = class _LexerIndexedCustomAction {
  static {
    __name(this, "LexerIndexedCustomAction");
  }
  offset;
  action;
  actionType;
  isPositionDependent = true;
  cachedHashCode;
  constructor(offset, action) {
    this.actionType = action.actionType;
    this.offset = offset;
    this.action = action;
  }
  /**
   * This method calls {@link execute} on the result of {@link getAction}
   * using the provided `lexer`.
   */
  execute(lexer) {
    this.action.execute(lexer);
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hash = MurmurHash.initialize();
      hash = MurmurHash.update(hash, this.offset);
      hash = MurmurHash.updateFromComparable(hash, this.action);
      this.cachedHashCode = MurmurHash.finish(hash, 2);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof _LexerIndexedCustomAction)) {
      return false;
    }
    return this.offset === other.offset && this.action === other.action;
  }
};

// src/atn/LexerActionExecutor.ts
var LexerActionExecutor = class _LexerActionExecutor {
  static {
    __name(this, "LexerActionExecutor");
  }
  lexerActions;
  actionType;
  isPositionDependent = false;
  cachedHashCode;
  /**
   * Represents an executor for a sequence of lexer actions which traversed during
   * the matching operation of a lexer rule (token).
   *
   * The executor tracks position information for position-dependent lexer actions
   * efficiently, ensuring that actions appearing only at the end of the rule do
   * not cause bloating of the {@link DFA} created for the lexer.
   */
  constructor(lexerActions) {
    this.actionType = -1;
    this.lexerActions = lexerActions ?? [];
    return this;
  }
  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input `lexerActionExecutor` followed by a specified
   * `lexerAction`.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link LexerATNConfig}. If this is `null`, the method behaves as
   * though it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in `lexerActionExecutor`.
   *
   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
   * of `lexerActionExecutor` and `lexerAction`.
   */
  static append(lexerActionExecutor, lexerAction) {
    if (lexerActionExecutor === null) {
      return new _LexerActionExecutor([lexerAction]);
    }
    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
    return new _LexerActionExecutor(lexerActions);
  }
  /**
   * Creates a {@link LexerActionExecutor} which encodes the current offset
   * for position-dependent lexer actions.
   *
   * Normally, when the executor encounters lexer actions where
   * {@link LexerAction//isPositionDependent} returns `true`, it calls
   * {@link IntStream.seek} on the input {@link CharStream} to set the input
   * position to the *end* of the current token. This behavior provides
   * for efficient DFA representation of lexer actions which appear at the end
   * of a lexer rule, even when the lexer rule matches a variable number of
   * characters.
   *
   * Prior to traversing a match transition in the ATN, the current offset
   * from the token start index is assigned to all position-dependent lexer
   * actions which have not already been assigned a fixed offset. By storing
   * the offsets relative to the token start index, the DFA representation of
   * lexer actions which appear in the middle of tokens remains efficient due
   * to sharing among tokens of the same length, regardless of their absolute
   * position in the input stream.
   *
   * If the current executor already has offsets assigned to all
   * position-dependent lexer actions, the method returns `this`.
   *
   * @param offset The current offset to assign to all position-dependent
   * lexer actions which do not already have offsets assigned.
   *
   * @returns {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
   * for all position-dependent lexer actions.
   */
  fixOffsetBeforeMatch(offset) {
    let updatedLexerActions = null;
    for (let i = 0; i < this.lexerActions.length; i++) {
      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
        if (updatedLexerActions === null) {
          updatedLexerActions = this.lexerActions.concat([]);
        }
        updatedLexerActions[i] = new LexerIndexedCustomAction(
          offset,
          this.lexerActions[i]
        );
      }
    }
    if (updatedLexerActions === null) {
      return this;
    } else {
      return new _LexerActionExecutor(updatedLexerActions);
    }
  }
  /**
   * Execute the actions encapsulated by this executor within the context of a
   * particular {@link Lexer}.
   *
   * This method calls {@link IntStream.seek} to set the position of the
   * `input` {@link CharStream} prior to calling
   * {@link LexerAction.execute} on a position-dependent action. Before the
   * method returns, the input position will be restored to the same position
   * it was in when the method was invoked.
   *
   * @param lexer The lexer instance.
   * @param input The input stream which is the source for the current token.
   * When this method is called, the current {@link IntStream.index} for
   * `input` should be the start of the following token, i.e. 1
   * character past the end of the current token.
   * @param startIndex The token start index. This value may be passed to
   * {@link IntStream.seek} to set the `input` position to the beginning
   * of the token.
   */
  execute(lexer, input, startIndex) {
    if (input === void 0 || startIndex === void 0) {
      return;
    }
    let requiresSeek = false;
    const stopIndex = input.index;
    try {
      for (const lexerAction of this.lexerActions) {
        let action = lexerAction;
        if (lexerAction instanceof LexerIndexedCustomAction) {
          const offset = lexerAction.offset;
          input.seek(startIndex + offset);
          action = lexerAction.action;
          requiresSeek = startIndex + offset !== stopIndex;
        } else if (lexerAction.isPositionDependent) {
          input.seek(stopIndex);
          requiresSeek = false;
        }
        action.execute(lexer);
      }
    } finally {
      if (requiresSeek) {
        input.seek(stopIndex);
      }
    }
  }
  hashCode() {
    if (this.cachedHashCode === void 0) {
      let hashCode = MurmurHash.initialize(7);
      for (const lexerAction of this.lexerActions) {
        hashCode = MurmurHash.update(hashCode, lexerAction.hashCode());
      }
      this.cachedHashCode = MurmurHash.finish(hashCode, this.lexerActions.length);
    }
    return this.cachedHashCode;
  }
  equals(other) {
    if (this === other) {
      return true;
    }
    if (this.cachedHashCode !== other.cachedHashCode) {
      return false;
    }
    if (this.lexerActions.length !== other.lexerActions.length) {
      return false;
    }
    return this.lexerActions.every((action, index) => {
      return action.equals(other.lexerActions[index]);
    });
  }
};

// src/misc/OrderedHashSet.ts
var OrderedHashSet = class _OrderedHashSet extends HashSet {
  static {
    __name(this, "OrderedHashSet");
  }
  elements = [];
  getOrAdd(o) {
    const oldSize = this.size;
    const result = super.getOrAdd(o);
    if (this.size > oldSize) {
      this.elements.push(o);
    }
    return result;
  }
  equals(o) {
    if (!(o instanceof _OrderedHashSet)) {
      return false;
    }
    return super.equals(o);
  }
  clear() {
    super.clear();
    this.elements = [];
  }
  *[Symbol.iterator]() {
    yield* this.elements;
  }
  toArray() {
    return this.elements.slice(0);
  }
};

// src/atn/OrderedATNConfigSet.ts
var OrderedATNConfigSet = class extends ATNConfigSet {
  static {
    __name(this, "OrderedATNConfigSet");
  }
  constructor() {
    super();
    this.configLookup = new OrderedHashSet();
  }
};

// src/atn/LexerATNSimulator.ts
var LexerATNSimulator = class _LexerATNSimulator extends ATNSimulator {
  static {
    __name(this, "LexerATNSimulator");
  }
  static debug = false;
  decisionToDFA;
  recognizer = null;
  /**
   * The current token's starting index into the character stream.
   *  Shared across DFA to ATN simulation in case the ATN fails and the
   *  DFA did not have a previous accept state. In this case, we use the
   *  ATN-generated exception object.
   */
  startIndex = -1;
  /** line number 1..n within the input */
  line = 1;
  /** The index of the character relative to the beginning of the line 0..n-1 */
  column = 0;
  mode = Lexer.DEFAULT_MODE;
  /** Used during DFA/ATN exec to record the most recent accept configuration info */
  prevAccept;
  options;
  /** Lookup table for lexer ATN config creation. */
  lexerATNConfigFactory;
  /**
   * When we hit an accept state in either the DFA or the ATN, we
   * have to notify the character stream to start buffering characters
   * via {@link IntStream//mark} and record the current state. The current sim state
   * includes the current index into the input, the current line,
   * and current character position in that line. Note that the Lexer is
   * tracking the starting line and characterization of the token. These
   * variables track the "state" of the simulator when it hits an accept state.
   *
   * We track these variables separately for the DFA and ATN simulation
   * because the DFA simulation often has to fail over to the ATN
   * simulation. If the ATN simulation fails, we need the DFA to fall
   * back to its previously accepted state, if any. If the ATN succeeds,
   * then the ATN does the accept and the DFA simulator that invoked it
   * can simply return the predicted token type.
   */
  constructor(recog, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.decisionToDFA = decisionToDFA;
    this.recognizer = recog;
    if (recog) {
      this.options = recog.options;
    } else {
      this.options = {
        minDFAEdge: 0,
        maxDFAEdge: 256,
        minCodePoint: 0,
        maxCodePoint: 1114111
      };
    }
  }
  match(input, mode) {
    this.mode = mode;
    const mark = input.mark();
    try {
      this.startIndex = input.index;
      this.prevAccept = void 0;
      const dfa = this.decisionToDFA[mode];
      if (!dfa.s0) {
        return this.matchATN(input);
      }
      return this.execATN(input, dfa.s0);
    } finally {
      input.release(mark);
    }
  }
  reset() {
    this.prevAccept = void 0;
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
  }
  clearDFA() {
    for (let d = 0; d < this.decisionToDFA.length; d++) {
      this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
    }
  }
  getDFA(mode) {
    return this.decisionToDFA[mode];
  }
  /** @returns the text matched so far for the current token. */
  getText(input) {
    return input.getTextFromRange(this.startIndex, input.index - 1);
  }
  consume(input) {
    const curChar = input.LA(1);
    if (curChar === "\n".charCodeAt(0)) {
      this.line += 1;
      this.column = 0;
    } else {
      this.column += 1;
    }
    input.consume();
  }
  getTokenName(tt) {
    if (tt === Token.EOF) {
      return "EOF";
    } else {
      return "'" + String.fromCharCode(tt) + "'";
    }
  }
  matchATN(input) {
    const startState = this.atn.modeToStartState[this.mode];
    if (_LexerATNSimulator.debug) {
      console.log("matchATN mode " + this.mode + " start: " + startState);
    }
    const oldMode = this.mode;
    const s0Closure = this.computeStartState(input, startState);
    const suppressEdge = s0Closure.hasSemanticContext;
    s0Closure.hasSemanticContext = false;
    const next = this.addDFAState(s0Closure);
    if (!suppressEdge) {
      this.decisionToDFA[this.mode].s0 = next;
    }
    const predict = this.execATN(input, next);
    if (_LexerATNSimulator.debug) {
      console.log("DFA after matchATN: " + this.decisionToDFA[oldMode].toLexerString());
    }
    return predict;
  }
  execATN(input, state) {
    if (_LexerATNSimulator.debug) {
      console.log("start state closure=" + state.configs);
    }
    if (state.isAcceptState) {
      this.captureSimState(input, state);
    }
    let t = input.LA(1);
    while (true) {
      if (_LexerATNSimulator.debug) {
        console.log("execATN loop starting closure: " + state.configs);
      }
      let target = this.getExistingTargetState(state, t);
      if (!target) {
        target = this.computeTargetState(input, state, t);
      }
      if (target === ATNSimulator.ERROR) {
        break;
      }
      if (t !== Token.EOF) {
        this.consume(input);
      }
      if (target.isAcceptState) {
        this.captureSimState(input, target);
        if (t === Token.EOF) {
          break;
        }
      }
      t = input.LA(1);
      state = target;
    }
    return this.failOrAccept(input, state.configs, t);
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns `null`.
   *
   * @param s The current DFA state.
   * @param t The next input symbol.
   *
   * @returns The existing target DFA state for the given input symbol
   * `t`, or `null` if the target state for this edge is not already cached
   */
  getExistingTargetState(s, t) {
    if (t >= this.options.minDFAEdge && t <= this.options.maxDFAEdge) {
      const target = s.edges[t - this.options.minDFAEdge];
      if (_LexerATNSimulator.debug && target) {
        console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
      }
      return target;
    }
    return void 0;
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the computed state and corresponding
   * edge to the DFA.
   *
   * @param input The input stream
   * @param s The current DFA state
   * @param t The next input symbol
   *
   * @returns The computed target DFA state for the given input symbol `t`.
   *          If `t` does not lead to a valid DFA state, this method returns `ERROR`.
   */
  computeTargetState(input, s, t) {
    const reach = new OrderedATNConfigSet();
    this.getReachableConfigSet(input, s.configs, reach, t);
    if (reach.length === 0) {
      if (!reach.hasSemanticContext) {
        this.addDFAEdge(s, t, ATNSimulator.ERROR);
      }
      return ATNSimulator.ERROR;
    }
    return this.addDFAEdge(s, t, null, reach);
  }
  failOrAccept(input, reach, t) {
    if (this.prevAccept?.dfaState) {
      const { dfaState, index, line, column } = this.prevAccept;
      this.accept(input, dfaState.lexerActionExecutor, this.startIndex, index, line, column);
      return dfaState.prediction;
    }
    if (t === Token.EOF && input.index === this.startIndex) {
      return Token.EOF;
    }
    throw new LexerNoViableAltException(this.recognizer, input, this.startIndex, reach);
  }
  /**
   * Given a starting configuration set, figure out all ATN configurations we can reach upon input `t`.
   * Parameter `reach` is a return parameter.
   */
  getReachableConfigSet(input, closure, reach, t) {
    let skipAlt = ATN.INVALID_ALT_NUMBER;
    for (const cfg of closure) {
      const currentAltReachedAcceptState = cfg.alt === skipAlt;
      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
        continue;
      }
      if (_LexerATNSimulator.debug) {
        console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recognizer, true));
      }
      for (const trans of cfg.state.transitions) {
        const target = this.getReachableTarget(trans, t);
        if (target) {
          let lexerActionExecutor = cfg.lexerActionExecutor;
          if (lexerActionExecutor) {
            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
          }
          const treatEofAsEpsilon = t === Token.EOF;
          const config = LexerATNConfig.createWithExecutor(
            cfg,
            target,
            lexerActionExecutor
          );
          if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
            skipAlt = cfg.alt;
          }
        }
      }
    }
  }
  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
    if (_LexerATNSimulator.debug) {
      console.log("ACTION %s\n", lexerActionExecutor);
    }
    input.seek(index);
    this.line = line;
    this.column = charPos;
    if (lexerActionExecutor && this.recognizer) {
      lexerActionExecutor.execute(this.recognizer, input, startIndex);
    }
  }
  getReachableTarget(trans, t) {
    if (trans.matches(t, this.options.minCodePoint, this.options.maxCodePoint)) {
      return trans.target;
    } else {
      return void 0;
    }
  }
  computeStartState(input, p) {
    const initialContext = EmptyPredictionContext.instance;
    const configs = new OrderedATNConfigSet();
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const cfg = LexerATNConfig.createWithContext(target, i + 1, initialContext);
      this.closure(input, cfg, configs, false, false, false);
    }
    return configs;
  }
  /**
   * Since the alternatives within any lexer decision are ordered by
   * preference, this method stops pursuing the closure as soon as an accept
   * state is reached. After the first accept state is reached by depth-first
   * search from `config`, all other (potentially reachable) states for
   * this rule would have a lower priority.
   *
   * @returns {boolean} `true` if an accept state is reached, otherwise `false`.
   */
  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
    let cfg = null;
    if (_LexerATNSimulator.debug) {
      console.log("closure(" + config.toString(this.recognizer, true) + ")");
    }
    if (config.state.constructor.stateType === ATNState.RULE_STOP) {
      if (_LexerATNSimulator.debug) {
        if (this.recognizer !== null) {
          console.log(
            "closure at %s rule stop %s\n",
            this.recognizer.ruleNames[config.state.ruleIndex],
            config
          );
        } else {
          console.log("closure at rule stop %s\n", config);
        }
      }
      if (!config.context || config.context.hasEmptyPath()) {
        if (!config.context || config.context.isEmpty()) {
          configs.add(config);
          return true;
        } else {
          configs.add(LexerATNConfig.createWithConfig(config.state, config, EmptyPredictionContext.instance));
          currentAltReachedAcceptState = true;
        }
      }
      if (config.context && !config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
            const newContext = config.context.getParent(i);
            const returnState = this.atn.states[config.context.getReturnState(i)];
            cfg = LexerATNConfig.createWithConfig(returnState, config, newContext);
            currentAltReachedAcceptState = this.closure(
              input,
              cfg,
              configs,
              currentAltReachedAcceptState,
              speculative,
              treatEofAsEpsilon
            );
          }
        }
      }
      return currentAltReachedAcceptState;
    }
    if (!config.state.epsilonOnlyTransitions) {
      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
        configs.add(config);
      }
    }
    for (const trans of config.state.transitions) {
      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
      if (cfg) {
        currentAltReachedAcceptState = this.closure(
          input,
          cfg,
          configs,
          currentAltReachedAcceptState,
          speculative,
          treatEofAsEpsilon
        );
      }
    }
    return currentAltReachedAcceptState;
  }
  // side-effect: can alter configs.hasSemanticContext
  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
    if (!this.lexerATNConfigFactory) {
      this.setupATNFactoryLookup();
    }
    const factory = this.lexerATNConfigFactory[trans.transitionType];
    if (!factory) {
      return null;
    }
    return factory(input, config, trans, configs, speculative, treatEofAsEpsilon);
  }
  /**
   * Fills the lookup table for creating lexer ATN configs. This helps to avoid frequent checks of the transition
   * type, which determines the configuration of the created config.
   */
  setupATNFactoryLookup() {
    this.lexerATNConfigFactory = [];
    this.lexerATNConfigFactory[Transition.RULE] = (input, config, trans) => {
      const newContext = createSingletonPredictionContext(
        config.context ?? void 0,
        trans.followState.stateNumber
      );
      return LexerATNConfig.createWithConfig(trans.target, config, newContext);
    };
    this.lexerATNConfigFactory[Transition.PRECEDENCE] = () => {
      throw new Error("Precedence predicates are not supported in lexers.");
    };
    this.lexerATNConfigFactory[Transition.PREDICATE] = (input, config, trans, configs, speculative) => {
      const pt = trans;
      if (_LexerATNSimulator.debug) {
        console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
      }
      configs.hasSemanticContext = true;
      if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
        return LexerATNConfig.createWithConfig(trans.target, config);
      }
      return null;
    };
    this.lexerATNConfigFactory[Transition.ACTION] = (input, config, trans) => {
      if (config.context === null || config.context.hasEmptyPath()) {
        const lexerActionExecutor = LexerActionExecutor.append(
          config.lexerActionExecutor,
          this.atn.lexerActions[trans.actionIndex]
        );
        return LexerATNConfig.createWithExecutor(config, trans.target, lexerActionExecutor);
      } else {
        return LexerATNConfig.createWithConfig(trans.target, config);
      }
    };
    this.lexerATNConfigFactory[Transition.EPSILON] = (input, config, trans) => {
      return LexerATNConfig.createWithConfig(trans.target, config);
    };
    const simple = /* @__PURE__ */ __name((input, config, trans, configs, speculative, treatEofAsEpsilon) => {
      if (treatEofAsEpsilon) {
        if (trans.matches(Token.EOF, this.options.minCodePoint, this.options.maxCodePoint)) {
          return LexerATNConfig.createWithConfig(trans.target, config);
        }
      }
      return null;
    }, "simple");
    this.lexerATNConfigFactory[Transition.ATOM] = simple;
    this.lexerATNConfigFactory[Transition.RANGE] = simple;
    this.lexerATNConfigFactory[Transition.SET] = simple;
  }
  /**
   * Evaluate a predicate specified in the lexer.
   *
   * If `speculative` is `true`, this method was called before
   * {@link consume} for the matched character. This method should call
   * {@link consume} before evaluating the predicate to ensure position
   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
   * and {@link Lexer}, properly reflect the current
   * lexer state. This method should restore `input` and the simulator
   * to the original state before returning (i.e. undo the actions made by the
   * call to {@link consume}.
   *
   * @param input The input stream.
   * @param ruleIndex The rule containing the predicate.
   * @param predIndex The index of the predicate within the rule.
   * @param speculative `true` if the current index in `input` is
   * one character before the predicate's location.
   *
   * @returns `true` if the specified predicate evaluates to
   * `true`.
   */
  evaluatePredicate(input, ruleIndex, predIndex, speculative) {
    if (!this.recognizer) {
      return true;
    }
    if (!speculative) {
      return this.recognizer.sempred(null, ruleIndex, predIndex);
    }
    const savedColumn = this.column;
    const savedLine = this.line;
    const index = input.index;
    const marker = input.mark();
    try {
      this.consume(input);
      return this.recognizer.sempred(null, ruleIndex, predIndex);
    } finally {
      this.column = savedColumn;
      this.line = savedLine;
      input.seek(index);
      input.release(marker);
    }
  }
  captureSimState(input, dfaState) {
    this.prevAccept = {
      index: input.index,
      line: this.line,
      column: this.column,
      dfaState
    };
  }
  addDFAEdge(from, tk, to, configs) {
    if (!to && configs) {
      const suppressEdge = configs.hasSemanticContext;
      configs.hasSemanticContext = false;
      to = this.addDFAState(configs);
      if (suppressEdge) {
        return to;
      }
    }
    if (tk < this.options.minDFAEdge || tk > this.options.maxDFAEdge) {
      return to;
    }
    if (_LexerATNSimulator.debug) {
      console.log("EDGE " + from + " -> " + to + " upon " + tk);
    }
    from.edges[tk - this.options.minDFAEdge] = to;
    return to;
  }
  /**
   * Add a new DFA state if there isn't one with this set of configurations already. This method also detects
   * the first configuration containing an ATN rule stop state. Later, when traversing the DFA, we will know
   * which rule to accept.
   */
  addDFAState(configs) {
    const dfa = this.decisionToDFA[this.mode];
    const existing = dfa.getStateForConfigs(configs);
    if (existing) {
      return existing;
    }
    const proposed = DFAState.fromConfigs(configs);
    const firstConfigWithRuleStopState = configs.firstStopState;
    if (firstConfigWithRuleStopState) {
      proposed.isAcceptState = true;
      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
    }
    configs.setReadonly(true);
    dfa.addState(proposed);
    return proposed;
  }
};

// src/atn/ParseInfo.ts
var ParseInfo = class {
  static {
    __name(this, "ParseInfo");
  }
  atnSimulator;
  constructor(atnSimulator) {
    this.atnSimulator = atnSimulator;
  }
  /**
   * Gets an array of {@link DecisionInfo} instances containing the profiling
   * information gathered for each decision in the ATN.
   *
   * @returns An array of {@link DecisionInfo} instances, indexed by decision
   * number.
   */
  getDecisionInfo() {
    return this.atnSimulator.getDecisionInfo();
  }
  /**
   * Gets the decision numbers for decisions that required one or more
   * full-context predictions during parsing. These are decisions for which
   * {@link DecisionInfo#llFallback} is non-zero.
   *
   * @returns A list of decision numbers which required one or more
   * full-context predictions during parsing.
   */
  getLLDecisions() {
    const decisions = this.atnSimulator.getDecisionInfo();
    const result = new Array();
    for (let i = 0; i < decisions.length; i++) {
      const fallBack = decisions[i].llFallback;
      if (fallBack > 0) {
        result.push(i);
      }
    }
    return result;
  }
  /**
   * Gets the total time spent during prediction across all decisions made
   * during parsing. This value is the sum of
   * {@link DecisionInfo#timeInPrediction} for all decisions.
   */
  getTotalTimeInPrediction() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let t = 0;
    for (const decision of decisions) {
      t += decision.timeInPrediction;
    }
    return t;
  }
  /**
   * Gets the total number of SLL lookahead operations across all decisions
   * made during parsing. This value is the sum of
   * {@link DecisionInfo#sllTotalLook} for all decisions.
   */
  getTotalSLLLookaheadOps() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let k = 0;
    for (const decision of decisions) {
      k += decision.sllTotalLook;
    }
    return k;
  }
  /**
   * Gets the total number of LL lookahead operations across all decisions
   * made during parsing. This value is the sum of
   * {@link DecisionInfo#llTotalLook} for all decisions.
   */
  getTotalLLLookaheadOps() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let k = 0;
    for (const decision of decisions) {
      k += decision.llTotalLook;
    }
    return k;
  }
  /**
   * Gets the total number of ATN lookahead operations for SLL prediction
   * across all decisions made during parsing.
   */
  getTotalSLLATNLookaheadOps() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let k = 0;
    for (const decision of decisions) {
      k += decision.sllATNTransitions;
    }
    return k;
  }
  /**
   * Gets the total number of ATN lookahead operations for LL prediction
   * across all decisions made during parsing.
   */
  getTotalLLATNLookaheadOps() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let k = 0;
    for (const decision of decisions) {
      k += decision.llATNTransitions;
    }
    return k;
  }
  /**
   * Gets the total number of ATN lookahead operations for SLL and LL
   * prediction across all decisions made during parsing.
   *
   *
   * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
   * {@link #getTotalLLATNLookaheadOps}.
   */
  getTotalATNLookaheadOps() {
    const decisions = this.atnSimulator.getDecisionInfo();
    let k = 0;
    for (const decision of decisions) {
      k += decision.sllATNTransitions;
      k += decision.llATNTransitions;
    }
    return k;
  }
  getDFASize(decision) {
    if (decision === void 0) {
      let n2 = 0;
      const decisionToDFA = this.atnSimulator.decisionToDFA;
      for (let i = 0; i < decisionToDFA.length; i++) {
        n2 += this.getDFASize(i);
      }
      return n2;
    } else {
      const decisionToDFA = this.atnSimulator.decisionToDFA[decision];
      return decisionToDFA.length;
    }
  }
};

// src/NoViableAltException.ts
var NoViableAltException = class extends RecognitionException {
  static {
    __name(this, "NoViableAltException");
  }
  /** Which configurations did we try at input.index() that couldn't match input.LT(1)? */
  deadEndConfigs = null;
  /**
   * The token object at the start index; the input stream might
   * 	not be buffering tokens so get a reference to it. (At the
   *  time the error occurred, of course the stream needs to keep a
   *  buffer all of the tokens but later we might not have access to those.)
   */
  startToken;
  constructor(recognizer, input = null, startToken = null, offendingToken = null, deadEndConfigs = null, ctx = null) {
    ctx = ctx ?? recognizer.context;
    offendingToken = offendingToken ?? recognizer.getCurrentToken();
    startToken = startToken ?? recognizer.getCurrentToken();
    input = input ?? recognizer.inputStream;
    super({ message: "", recognizer, input, ctx });
    this.deadEndConfigs = deadEndConfigs;
    this.startToken = startToken;
    this.offendingToken = offendingToken;
  }
};

// src/utils/DoubleDict.ts
var DoubleDict = class {
  static {
    __name(this, "DoubleDict");
  }
  cacheMap;
  constructor() {
    this.cacheMap = new HashMap();
  }
  get(a, b) {
    const d = this.cacheMap.get(a) ?? null;
    return d === null ? null : d.get(b) ?? null;
  }
  set(a, b, o) {
    let d = this.cacheMap.get(a);
    if (!d) {
      d = new HashMap();
      this.cacheMap.set(a, d);
    }
    d.set(b, o);
  }
};

// src/atn/PredictionMode.ts
var SubsetEqualityComparer = class _SubsetEqualityComparer {
  static {
    __name(this, "SubsetEqualityComparer");
  }
  static instance = new _SubsetEqualityComparer();
  hashCode(config) {
    let hashCode = MurmurHash.initialize(7);
    hashCode = MurmurHash.update(hashCode, config.state.stateNumber);
    hashCode = MurmurHash.updateFromComparable(hashCode, config.context);
    hashCode = MurmurHash.finish(hashCode, 2);
    return hashCode;
  }
  equals(a, b) {
    return a.state.stateNumber === b.state.stateNumber && (a.context?.equals(b.context) ?? true);
  }
};
var PredictionMode = class _PredictionMode {
  static {
    __name(this, "PredictionMode");
  }
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   *
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link LL} prediction abilities to complete successfully.
   *
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  static SLL = 0;
  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   *
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for *exactly which* alternatives are
   * ambiguous.
   *
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  static LL = 1;
  /**
   *
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   *
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.
   *
   *
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.
   */
  static LL_EXACT_AMBIG_DETECTION = 2;
  /**
   *
   *Computes the SLL prediction termination condition.
   *
   *
   *This method computes the SLL prediction termination condition for both of
   *the following cases.
   *
   * - The usual SLL+LL fallback upon SLL conflict
   * - Pure SLL without LL fallback
   *
   ***COMBINED SLL+LL PARSING**
   *
   *When LL-fallback is enabled upon SLL conflict, correct predictions are
   *ensured regardless of how the termination condition is computed by this
   *method. Due to the substantially higher cost of LL prediction, the
   *prediction should only fall back to LL when the additional lookahead
   *cannot lead to a unique SLL prediction.
   *
   *Assuming combined SLL+LL parsing, an SLL configuration set with only
   *conflicting subsets should fall back to full LL, even if the
   *configuration sets don't resolve to the same alternative (e.g.
   *`{1,2`} and `{3,4`}. If there is at least one non-conflicting
   *configuration, SLL could continue with the hopes that more lookahead will
   *resolve via one of those non-conflicting configurations.
   *
   *Here's the prediction termination rule them: SLL (for SLL+LL parsing)
   *stops when it sees only conflicting configuration subsets. In contrast,
   *full LL keeps going when there is uncertainty.
   *
   ***HEURISTIC**
   *
   *As a heuristic, we stop prediction when we see any conflicting subset
   *unless we see a state that only has one alternative associated with it.
   *The single-alt-state thing lets prediction continue upon rules like
   *(otherwise, it would admit defeat too soon):
   *
   *`[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;`
   *
   *When the ATN simulation reaches the state before `';'`, it has a
   *DFA state that looks like: `[12|1|[], 6|2|[], 12|2|[]]`. Naturally
   *`12|1|[]` and `12|2|[]` conflict, but we cannot stop
   *processing this node because alternative to has another way to continue,
   *via `[6|2|[]]`.
   *
   *It also let's us continue for this rule:
   *
   *`[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;`
   *
   *After matching input A, we reach the stop state for rule A, state 1.
   *State 8 is the state right before B. Clearly alternatives 1 and 2
   *conflict and no amount of further lookahead will separate the two.
   *However, alternative 3 will be able to continue and so we do not stop
   *working on this state. In the previous example, we're concerned with
   *states associated with the conflicting alternatives. Here alt 3 is not
   *associated with the conflicting configs, but since we can continue
   *looking for input reasonably, don't declare the state done.
   *
   ***PURE SLL PARSING**
   *
   *To handle pure SLL parsing, all we have to do is make sure that we
   *combine stack contexts for configurations that differ only by semantic
   *predicate. From there, we can do the usual SLL termination heuristic.
   *
   ***PREDICATES IN SLL+LL PARSING**
   *
   *SLL decisions don't evaluate predicates until after they reach DFA stop
   *states because they need to create the DFA cache that works in all
   *semantic situations. In contrast, full LL evaluates predicates collected
   *during start state computation so it can ignore predicates thereafter.
   *This means that SLL termination detection can totally ignore semantic
   *predicates.
   *
   *Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
   *semantic predicate contexts so we might see two configurations like the
   *following.
   *
   *`(s, 1, x, {`), (s, 1, x', {p})}
   *
   *Before testing these configurations against others, we have to merge
   *`x` and `x'` (without modifying the existing configurations).
   *For example, we test `(x+x')==x''` when looking for conflicts in
   *the following configurations.
   *
   *`(s, 1, x, {`), (s, 1, x', {p}), (s, 2, x'', {})}
   *
   *If the configuration set has predicates (as indicated by
   *{@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
   *the configurations to strip out all of the predicates so that a standard
   *{@link ATNConfigSet} will merge everything ignoring predicates.
   */
  static hasSLLConflictTerminatingPrediction(mode, configs) {
    if (_PredictionMode.allConfigsInRuleStopStates(configs)) {
      return true;
    }
    if (mode === _PredictionMode.SLL) {
      if (configs.hasSemanticContext) {
        const dup = new ATNConfigSet();
        for (let c of configs) {
          c = ATNConfig.duplicate(c, SemanticContext.NONE);
          dup.add(c);
        }
        configs = dup;
      }
    }
    const altSets = _PredictionMode.getConflictingAltSubsets(configs);
    return _PredictionMode.hasConflictingAltSet(altSets) && !_PredictionMode.hasStateAssociatedWithOneAlt(configs);
  }
  /**
   * Checks if any configuration in `configs` is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @returns `true` if any configuration in `configs` is in a
   * {@link RuleStopState}, otherwise `false`
   */
  static hasConfigInRuleStopState(configs) {
    for (const c of configs) {
      if (c.state instanceof RuleStopState) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks if all configurations in `configs` are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @returns `true` if all configurations in `configs` are in a
   * {@link RuleStopState}, otherwise `false`
   */
  static allConfigsInRuleStopStates(configs) {
    for (const c of configs) {
      if (!(c.state instanceof RuleStopState)) {
        return false;
      }
    }
    return true;
  }
  /**
   *
   * Full LL prediction termination.
   *
   * Can we stop looking ahead during ATN simulation or is there some
   * uncertainty as to which alternative we will ultimately pick, after
   * consuming more input? Even if there are partial conflicts, we might know
   * that everything is going to resolve to the same minimum alternative. That
   * means we can stop since no more lookahead will change that fact. On the
   * other hand, there might be multiple conflicts that resolve to different
   * minimums. That means we need more look ahead to decide which of those
   * alternatives we should predict.
   *
   * The basic idea is to split the set of configurations `C`, into
   * conflicting subsets `(s, _, ctx, _)` and singleton subsets with
   * non-conflicting configurations. Two configurations conflict if they have
   * identical {@link ATNConfig.state} and {@link ATNConfig.context} values
   * but different {@link ATNConfig.alt} value, e.g. `(s, i, ctx, _)`
   * and `(s, j, ctx, _)` for `i!=j`.
   *
   * Reduce these configuration subsets to the set of possible alternatives.
   * You can compute the alternative subsets in one pass as follows:
   *
   * `A_s,ctx = {i | (s, i, ctx, _)`} for each configuration in
   * `C` holding `s` and `ctx` fixed.
   *
   * Or in pseudo-code, for each configuration `c` in `C`:
   *
   * ```
   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * ```
   *
   * The values in `map` are the set of `A_s,ctx` sets.
   *
   * If `|A_s,ctx|=1` then there is no conflict associated with
   * `s` and `ctx`.
   *
   * Reduce the subsets to singletons by choosing a minimum of each subset. If
   * the union of these alternative subsets is a singleton, then no amount of
   * more lookahead will help us. We will always pick that alternative. If,
   * however, there is more than one alternative, then we are uncertain which
   * alternative to predict and must continue looking for resolution. We may
   * or may not discover an ambiguity in the future, even if there are no
   * conflicting subsets this round.
   *
   * The biggest sin is to terminate early because it means we've made a
   * decision but were uncertain as to the eventual outcome. We haven't used
   * enough lookahead. On the other hand, announcing a conflict too late is no
   * big deal; you will still have the conflict. It's just inefficient. It
   * might even look until the end of file.
   *
   * No special consideration for semantic predicates is required because
   * predicates are evaluated on-the-fly for full LL prediction, ensuring that
   * no configuration contains a semantic context during the termination
   * check.
   *
   * **CONFLICTING CONFIGS**
   *
   * Two configurations `(s, i, x)` and `(s, j, x')`, conflict when `i!=j` but `x=x'`. Because we merge all
   * `(s, i, _)` configurations together, that means that there are at most `n` configurations associated with state
   * `s` for `n` possible alternatives in the decision. The merged stacks complicate the comparison of configuration
   * contexts `x` and `x'`. Sam checks to see if one is a subset of the other by calling merge and checking to see
   * if the merged result is either `x` or `x'`. If the `x` associated with lowest alternative `i` is the superset,
   * then `i` is the only possible prediction since the others resolve to `min(i)` as well. However, if `x` is
   * associated with `j>i` then at least one stack configuration for `j` is not in conflict with alternative `i`.
   * The algorithm should keep going, looking for more lookahead due to the uncertainty.
   *
   * For simplicity, I'm doing a equality check between `x` and `x'` that lets the algorithm continue to consume
   * lookahead longer than necessary. The reason I like the equality is of course the simplicity but also because
   * that is the test you need to detect the alternatives that are actually in conflict.
   *
   * **CONTINUE/STOP RULE**
   *
   * Continue if union of resolved alternative sets from non-conflicting and conflicting alternative subsets has more
   * than one alternative. We are uncertain about which alternative to predict.
   *
   * The complete set of alternatives, `[i for (_,i,_)]`, tells us which alternatives are still in the running for
   * the amount of input we've consumed at this point. The conflicting sets let us to strip away configurations that
   * won't lead to more states because we resolve conflicts to the configuration with a minimum alternate for the
   * conflicting set.
   *
   * **CASES**
   *
   * - no conflicts and more than 1 alternative in set => continue
   * -  `(s, 1, x)`, `(s, 2, x)`, `(s, 3, z)`, `(s', 1, y)`, `(s', 2, y)` yields non-conflicting set `{3`} U
   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1,3`} => continue
   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)`, `(s'', 1, z)` yields non-conflicting set `{1`} U
   *   conflicting sets `min({1,2`)} U `min({1,2`)} = `{1`} => stop and predict 1
   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 1, y)`, `(s', 2, y)` yields conflicting, reduced sets `{1`} U
   *   `{1`} = `{1`} => stop and predict 1, can announce ambiguity `{1,2`}
   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 2, y)`, `(s', 3, y)` yields conflicting, reduced sets `{1`} U
   *   `{2`} = `{1,2`} => continue
   * - `(s, 1, x)`, `(s, 2, x)`, `(s', 3, y)`, `(s', 4, y)` yields conflicting, reduced sets `{1`} U
   *   `{3`} = `{1,3`} => continue
   *
   * **EXACT AMBIGUITY DETECTION**
   *
   *If all states report the same conflicting set of alternatives, then we
   *know we have the exact ambiguity set.
   *
   * `|A_*i*|>1` and `A_*i* = A_*j*` for all *i*, *j*.
   *
   * In other words, we continue examining lookahead until all `A_i` have more than one alternative and all `A_i`
   * are the same. If `A={{1,2`, {1,3}}}, then regular LL prediction would terminate because the resolved set
   * is `{1`}. To determine what the real ambiguity is, we have to know whether the ambiguity is between one and
   * two or one and three so we keep going. We can only stop prediction when we need exact ambiguity detection when
   * the sets look like `A={{1,2`}} or `{{1,2`,{1,2}}}, etc...
   */
  static resolvesToJustOneViableAlt(altSets) {
    return _PredictionMode.getSingleViableAlt(altSets);
  }
  /**
   * Determines if every alternative subset in `altSets` contains more
   * than one alternative.
   *
   * @param altSets a collection of alternative subsets
   * @returns `true` if every {@link BitSet} in `altSets` has
   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
   */
  static allSubsetsConflict(altSets) {
    return !_PredictionMode.hasNonConflictingAltSet(altSets);
  }
  /**
   * Determines if any single alternative subset in `altSets` contains
   * exactly one alternative.
   *
   * @param altSets a collection of alternative subsets
   * @returns `true` if `altSets` contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} 1, otherwise `false`
   */
  static hasNonConflictingAltSet(altSets) {
    for (const alts of altSets) {
      if (alts.length === 1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Determines if any single alternative subset in `altSets` contains
   * more than one alternative.
   *
   * @param altSets a collection of alternative subsets
   * @returns `true` if `altSets` contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} > 1, otherwise `false`
   */
  static hasConflictingAltSet(altSets) {
    for (const alts of altSets) {
      if (alts.length > 1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Determines if every alternative subset in `altSets` is equivalent.
   *
   * @param altSets a collection of alternative subsets
   * @returns `true` if every member of `altSets` is equal to the
   * others, otherwise `false`
   */
  static allSubsetsEqual(altSets) {
    let first = null;
    for (const alts of altSets) {
      if (first === null) {
        first = alts;
      } else if (alts !== first) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns the unique alternative predicted by all alternative subsets in
   * `altSets`. If no such alternative exists, this method returns
   * {@link ATN.INVALID_ALT_NUMBER}.
   *
   * @param altSets a collection of alternative subsets
   */
  static getUniqueAlt(altSets) {
    const all = _PredictionMode.getAlts(altSets);
    if (all.length === 1) {
      return all.nextSetBit(0);
    } else {
      return ATN.INVALID_ALT_NUMBER;
    }
  }
  /**
   * Gets the complete set of represented alternatives for a collection of
   * alternative subsets. This method returns the union of each {@link BitSet}
   * in `altSets`.
   *
   * @param altSets a collection of alternative subsets
   * @returns the set of represented alternatives in `altSets`
   */
  static getAlts(altSets) {
    const all = new BitSet();
    altSets.forEach((alts) => {
      all.or(alts);
    });
    return all;
  }
  /**
   * This function gets the conflicting alt subsets from a configuration set.
   * For each configuration `c` in `configs`:
   *
   * ```
   * map[c] U= c.{@link ATNConfig.alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * ```
   */
  static getConflictingAltSubsets(configs) {
    const configToAlts = new HashMap(SubsetEqualityComparer.instance);
    for (const cfg of configs) {
      let alts = configToAlts.get(cfg);
      if (!alts) {
        alts = new BitSet();
        configToAlts.set(cfg, alts);
      }
      alts.set(cfg.alt);
    }
    return Array.from(configToAlts.values());
  }
  /**
   * Get a map from state to alt subset from a configuration set. For each configuration `c` in `configs`:
   *
   * ```
   * map[c.state] = c.alt
   * ```
   */
  static getStateToAltMap(configs) {
    const m2 = new HashMap(ObjectEqualityComparator.instance);
    for (const c of configs) {
      let alts = m2.get(c.state);
      if (!alts) {
        alts = new BitSet();
        m2.set(c.state, alts);
      }
      alts.set(c.alt);
    }
    return m2;
  }
  static hasStateAssociatedWithOneAlt(configs) {
    const counts = {};
    for (const c of configs) {
      const stateNumber = c.state.stateNumber;
      if (!counts[stateNumber]) {
        counts[stateNumber] = 0;
      }
      counts[stateNumber]++;
    }
    return Object.values(counts).some((count) => {
      return count === 1;
    });
  }
  static getSingleViableAlt(altSets) {
    let result = null;
    for (const alts of altSets) {
      const minAlt = alts.nextSetBit(0);
      if (result === null) {
        result = minAlt;
      } else if (result !== minAlt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return result ?? 0;
  }
};

// src/atn/ParserATNSimulator.ts
var ParserATNSimulator = class _ParserATNSimulator extends ATNSimulator {
  static {
    __name(this, "ParserATNSimulator");
  }
  static traceATNSimulator = false;
  static debug;
  static debugAdd = false;
  static debugClosure = false;
  static dfaDebug = false;
  static retryDebug = false;
  /** SLL, LL, or LL + exact ambig detection? */
  predictionMode;
  decisionToDFA;
  parser;
  /**
   * Each prediction operation uses a cache for merge of prediction contexts.
   * Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
   * isn't synchronized but we're ok since two threads shouldn't reuse same
   * parser/atn sim object because it can only handle one input at a time.
   * This maps graphs a and b to merged result c. (a,b)->c. We can avoid
   * the merge if we ever see a and b again.  Note that (b,a)->c should
   * also be examined during cache lookup.
   */
  mergeCache = new DoubleDict();
  // Used also in the profiling ATN simulator.
  predictionState;
  constructor(recog, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.parser = recog;
    this.decisionToDFA = decisionToDFA;
  }
  static getUniqueAlt(configs) {
    let alt = ATN.INVALID_ALT_NUMBER;
    for (const c of configs) {
      if (alt === ATN.INVALID_ALT_NUMBER) {
        alt = c.alt;
      } else if (c.alt !== alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return alt;
  }
  reset() {
  }
  clearDFA() {
    for (let d = 0; d < this.decisionToDFA.length; d++) {
      this.decisionToDFA[d] = new DFA(this.atn.getDecisionState(d), d);
    }
  }
  // TODO: make outerContext an optional parameter, not optional null.
  adaptivePredict(input, decision, outerContext) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
      console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    const dfa = this.decisionToDFA[decision];
    this.predictionState = {
      input,
      startIndex: input.index,
      outerContext: outerContext ?? void 0,
      dfa
    };
    const m2 = input.mark();
    const index = input.index;
    try {
      let s0;
      if (dfa.isPrecedenceDfa) {
        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
      } else {
        s0 = dfa.s0;
      }
      if (!s0) {
        if (!outerContext) {
          outerContext = ParserRuleContext.empty;
        }
        if (_ParserATNSimulator.debug) {
          console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
        }
        const fullCtx = false;
        let s0_closure = this.computeStartState(dfa.atnStartState, ParserRuleContext.empty, fullCtx);
        if (dfa.isPrecedenceDfa) {
          s0_closure = this.applyPrecedenceFilter(s0_closure);
          s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
        } else {
          s0 = this.addDFAState(dfa, DFAState.fromConfigs(s0_closure));
          dfa.s0 = s0;
        }
      }
      const alt = this.execATN(dfa, s0, input, index, outerContext);
      if (_ParserATNSimulator.debug) {
        console.log("DFA after predictATN: " + dfa.toString(this.parser.vocabulary));
      }
      return alt;
    } finally {
      this.predictionState.dfa = void 0;
      this.mergeCache = new DoubleDict();
      input.seek(index);
      input.release(m2);
    }
  }
  /**
   * Performs ATN simulation to compute a predicted alternative based
   *  upon the remaining input, but also updates the DFA cache to avoid
   *  having to traverse the ATN again for the same input sequence.
   *
   * There are some key conditions we're looking for after computing a new
   * set of ATN configs (proposed DFA state):
   *       if the set is empty, there is no viable alternative for current symbol
   *       does the state uniquely predict an alternative?
   *       does the state have a conflict that would prevent us from
   *         putting it on the work list?
   *
   * We also have some key operations to do:
   *       add an edge from previous DFA state to potentially new DFA state, D,
   *         upon current symbol but only if adding to work list, which means in all
   *         cases except no viable alternative (and possibly non-greedy decisions?)
   *       collecting predicates and adding semantic context to DFA accept states
   *       adding rule context to context-sensitive DFA accept states
   *       consuming an input symbol
   *       reporting a conflict
   *       reporting an ambiguity
   *       reporting a context sensitivity
   *       reporting insufficient predicates
   *
   * cover these cases:
   *    dead end
   *    single alt
   *    single alt + preds
   *    conflict
   *    conflict + preds
   */
  execATN(dfa, s0, input, startIndex, outerContext) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
      console.log("execATN decision " + dfa.decision + ", DFA state " + s0 + ", LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    let alt;
    let previousState = s0;
    let t = input.LA(1);
    while (true) {
      let nextState = this.getExistingTargetState(previousState, t);
      if (!nextState) {
        nextState = this.computeTargetState(dfa, previousState, t);
      }
      if (nextState === ATNSimulator.ERROR) {
        const e = this.noViableAlt(input, outerContext, previousState.configs, startIndex);
        input.seek(startIndex);
        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousState.configs, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      if (nextState.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
        let conflictingAlts = null;
        if (nextState.predicates !== null) {
          if (_ParserATNSimulator.debug) {
            console.log("DFA state has preds in DFA sim LL failover");
          }
          const conflictIndex = input.index;
          if (conflictIndex !== startIndex) {
            input.seek(startIndex);
          }
          conflictingAlts = this.evalSemanticContext(nextState.predicates, outerContext, true);
          if (conflictingAlts.length === 1) {
            if (_ParserATNSimulator.debug) {
              console.log("Full LL avoided");
            }
            return conflictingAlts.nextSetBit(0);
          }
          if (conflictIndex !== startIndex) {
            input.seek(conflictIndex);
          }
        }
        if (_ParserATNSimulator.dfaDebug) {
          console.log("ctx sensitive state " + outerContext + " in " + nextState);
        }
        const fullCtx = true;
        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
        this.reportAttemptingFullContext(dfa, conflictingAlts, nextState.configs, startIndex, input.index);
        alt = this.execATNWithFullContext(dfa, nextState, s0_closure, input, startIndex, outerContext);
        return alt;
      }
      if (nextState.isAcceptState) {
        if (nextState.predicates === null) {
          return nextState.prediction;
        }
        const stopIndex = input.index;
        input.seek(startIndex);
        const alts = this.evalSemanticContext(nextState.predicates, outerContext, true);
        if (alts.length === 0) {
          throw this.noViableAlt(input, outerContext, nextState.configs, startIndex);
        }
        if (alts.length === 1) {
          return alts.nextSetBit(0);
        }
        this.reportAmbiguity(dfa, nextState, startIndex, stopIndex, false, alts, nextState.configs);
        return alts.nextSetBit(0);
      }
      previousState = nextState;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns `null`.
   *
   * @param previousD The current DFA state
   * @param t The next input symbol
   * @returns The existing target DFA state for the given input symbol
   * `t`, or `null` if the target state for this edge is not
   * already cached
   */
  getExistingTargetState(previousD, t) {
    return previousD.edges[t + 1];
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param dfa The DFA
   * @param previousD The current DFA state
   * @param t The next input symbol
   *
   * @returns The computed target DFA state for the given input symbol
   * `t`. If `t` does not lead to a valid DFA state, this method
   * returns {@link ERROR
   */
  computeTargetState(dfa, previousD, t) {
    const reach = this.computeReachSet(previousD.configs, t, false);
    if (reach === null) {
      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
      return ATNSimulator.ERROR;
    }
    let D = DFAState.fromConfigs(reach);
    const predictedAlt = _ParserATNSimulator.getUniqueAlt(reach);
    if (_ParserATNSimulator.debug) {
      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
      console.log("SLL altSubSets=" + arrayToString(altSubSets) + /*", previous=" + previousD.configs + */
      ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
    }
    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
      D.isAcceptState = true;
      D.configs.uniqueAlt = predictedAlt;
      D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
      D.configs.conflictingAlts = this.getConflictingAlts(reach);
      D.requiresFullContext = true;
      D.isAcceptState = true;
      D.prediction = D.configs.conflictingAlts.nextSetBit(0);
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
      if (D.predicates !== null) {
        D.prediction = ATN.INVALID_ALT_NUMBER;
      }
    }
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
  }
  getRuleName(index) {
    if (this.parser !== null && index >= 0) {
      return this.parser.ruleNames[index];
    } else {
      return "<rule " + index + ">";
    }
  }
  getTokenName(t) {
    if (t === Token.EOF) {
      return "EOF";
    }
    const vocabulary = this.parser?.vocabulary ?? Vocabulary.EMPTY_VOCABULARY;
    const displayName = vocabulary.getDisplayName(t);
    if (displayName === t.toString()) {
      return displayName;
    }
    return displayName + "<" + t + ">";
  }
  getLookaheadName(input) {
    return this.getTokenName(input.LA(1));
  }
  /**
   * Used for debugging in adaptivePredict around execATN but I cut
   * it out for clarity now that alg. works well. We can leave this
   * "dead" code for a bit
   */
  dumpDeadEndConfigs(e) {
    console.log("dead end configs: ");
    const decs = e.deadEndConfigs;
    for (const c of decs) {
      let trans = "no edges";
      if (c.state.transitions.length > 0) {
        const t = c.state.transitions[0];
        if (t instanceof AtomTransition) {
          trans = "Atom " + this.getTokenName(t.labelValue);
        } else if (t instanceof SetTransition) {
          const neg = t instanceof NotSetTransition;
          trans = (neg ? "~" : "") + "Set " + t.label;
        }
      }
      console.error(c.toString(this.parser, true) + ":" + trans);
    }
  }
  predicateDFAState(dfaState, decisionState) {
    const altCount = decisionState.transitions.length;
    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, altCount);
    if (altToPred !== null) {
      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
      dfaState.prediction = ATN.INVALID_ALT_NUMBER;
    } else {
      dfaState.prediction = altsToCollectPredsFrom.nextSetBit(0);
    }
  }
  // comes back with reach.uniqueAlt set to a valid alt
  execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.traceATNSimulator) {
      console.log("execATNWithFullContext " + s0);
    }
    const fullCtx = true;
    let foundExactAmbig = false;
    let reach;
    let previous = s0;
    input.seek(startIndex);
    let t = input.LA(1);
    let predictedAlt = -1;
    for (; ; ) {
      reach = this.computeReachSet(previous, t, fullCtx);
      if (reach === null) {
        const e = this.noViableAlt(input, outerContext, previous, startIndex);
        input.seek(startIndex);
        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }
      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
      if (_ParserATNSimulator.debug) {
        console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
      }
      reach.uniqueAlt = _ParserATNSimulator.getUniqueAlt(reach);
      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        predictedAlt = reach.uniqueAlt;
        break;
      } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
        predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          break;
        }
      } else {
        if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
          foundExactAmbig = true;
          predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
          break;
        }
      }
      previous = reach;
      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
      return predictedAlt;
    }
    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, reach.getAlts(), reach);
    return predictedAlt;
  }
  computeReachSet(closure, t, fullCtx) {
    if (_ParserATNSimulator.debug) {
      console.log("in computeReachSet, starting closure: " + closure);
    }
    const intermediate = new ATNConfigSet(fullCtx);
    let skippedStopStates = null;
    for (const c of closure) {
      if (_ParserATNSimulator.debug) {
        console.log("testing " + this.getTokenName(t) + " at " + c);
      }
      if (c.state instanceof RuleStopState) {
        if (fullCtx || t === Token.EOF) {
          if (skippedStopStates === null) {
            skippedStopStates = [];
          }
          skippedStopStates.push(c);
        }
        continue;
      }
      for (const trans of c.state.transitions) {
        const target = this.getReachableTarget(trans, t);
        if (target !== null) {
          const cfg = ATNConfig.createWithConfig(target, c);
          intermediate.add(cfg, this.mergeCache);
          if (_ParserATNSimulator.debugAdd) {
            console.log("added " + cfg + " to intermediate");
          }
        }
      }
    }
    let reach = null;
    if (skippedStopStates === null && t !== Token.EOF) {
      if (intermediate.length === 1) {
        reach = intermediate;
      } else if (_ParserATNSimulator.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
        reach = intermediate;
      }
    }
    if (reach === null) {
      reach = new ATNConfigSet(fullCtx);
      const closureBusy = new HashSet();
      const treatEofAsEpsilon = t === Token.EOF;
      for (const config of intermediate) {
        this.closure(config, reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
      }
    }
    if (t === Token.EOF) {
      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
      for (const config of skippedStopStates) {
        reach.add(config, this.mergeCache);
      }
    }
    if (_ParserATNSimulator.traceATNSimulator) {
      console.log("computeReachSet " + closure + " -> " + reach);
    }
    if (reach.length === 0) {
      return null;
    } else {
      return reach;
    }
  }
  /**
   * Return a configuration set containing only the configurations from
   * `configs` which are in a {@link RuleStopState}. If all
   * configurations in `configs` are already in a rule stop state, this
   * method simply returns `configs`.
   *
   * When `lookToEndOfRule` is true, this method uses
   * {@link ATN.nextTokens} for each configuration in `configs` which is
   * not already in a rule stop state to see if a rule stop state is reachable
   * from the configuration via epsilon-only transitions.
   *
   * @param configs the configuration set to update
   * @param lookToEndOfRule when true, this method checks for rule stop states
   * reachable by epsilon-only transitions from each configuration in
   * `configs`.
   *
   * @returns `configs` if all configurations in `configs` are in a
   * rule stop state, otherwise return a new configuration set containing only
   * the configurations from `configs` which are in a rule stop state
   */
  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return configs;
    }
    const result = new ATNConfigSet(configs.fullCtx);
    for (const config of configs) {
      if (config.state instanceof RuleStopState) {
        result.add(config, this.mergeCache);
        continue;
      }
      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
        const nextTokens = this.atn.nextTokens(config.state);
        if (nextTokens.contains(Token.EPSILON)) {
          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
          result.add(ATNConfig.createWithConfig(endOfRuleState, config), this.mergeCache);
        }
      }
    }
    return result;
  }
  computeStartState(p, ctx, fullCtx) {
    const initialContext = predictionContextFromRuleContext(this.atn, ctx);
    const configs = new ATNConfigSet(fullCtx);
    if (_ParserATNSimulator.traceATNSimulator) {
      console.log("computeStartState from ATN state " + p + " initialContext=" + initialContext.toString(this.parser));
    }
    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const c = ATNConfig.createWithContext(target, i + 1, initialContext);
      const closureBusy = new HashSet();
      this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
  }
  /**
   * This method transforms the start state computed by
   * {@link computeStartState} to the special start state used by a
   * precedence DFA for a particular precedence value. The transformation
   * process applies the following changes to the start state's configuration
   * set.
   *
   * 1. Evaluate the precedence predicates for each configuration using
   * {@link SemanticContext//evalPrecedence}.
   * 2. Remove all configurations which predict an alternative greater than
   * 1, for which another configuration that predicts alternative 1 is in the
   * same ATN state with the same prediction context. This transformation is
   * valid for the following reasons:
   * 3. The closure block cannot contain any epsilon transitions which bypass
   * the body of the closure, so all states reachable via alternative 1 are
   * part of the precedence alternatives of the transformed left-recursive
   * rule.
   * 4. The "primary" portion of a left recursive rule cannot contain an
   * epsilon transition, so the only way an alternative other than 1 can exist
   * in a state that is also reachable via alternative 1 is by nesting calls
   * to the left-recursive rule, with the outer calls not being at the
   * preferred precedence level.
   *
   *
   * The prediction context must be considered by this filter to address
   * situations like the following.
   *
   * `
   * ```
   * grammar TA;
   * prog: statement* EOF;
   * statement: letterA | statement letterA 'b' ;
   * letterA: 'a';
   * ```
   * `
   *
   * If the above grammar, the ATN state immediately before the token
   * reference `'a'` in `letterA` is reachable from the left edge
   * of both the primary and closure blocks of the left-recursive rule
   * `statement`. The prediction context associated with each of these
   * configurations distinguishes between them, and prevents the alternative
   * which stepped out to `prog` (and then back in to `statement`
   * from being eliminated by the filter.
   *
   * @param configs The configuration set computed by
   * {@link computeStartState} as the start state for the DFA.
   * @returns The transformed configuration set representing the start state
   * for a precedence DFA at a particular precedence level (determined by
   * calling {@link Parser//getPrecedence})
   */
  applyPrecedenceFilter(configs) {
    const statesFromAlt1 = [];
    const configSet = new ATNConfigSet(configs.fullCtx);
    for (const config of configs) {
      if (config.alt !== 1) {
        continue;
      }
      const updatedContext = config.semanticContext.evalPrecedence(
        this.parser,
        this.predictionState.outerContext
      );
      if (updatedContext === null) {
        continue;
      }
      statesFromAlt1[config.state.stateNumber] = config.context;
      if (updatedContext !== config.semanticContext) {
        configSet.add(ATNConfig.duplicate(config, updatedContext), this.mergeCache);
      } else {
        configSet.add(config, this.mergeCache);
      }
    }
    for (const config of configs) {
      if (config.alt === 1) {
        continue;
      }
      if (!config.precedenceFilterSuppressed) {
        const context = statesFromAlt1[config.state.stateNumber] || null;
        if (context !== null && context.equals(config.context)) {
          continue;
        }
      }
      configSet.add(config, this.mergeCache);
    }
    return configSet;
  }
  getReachableTarget(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
      return trans.target;
    } else {
      return null;
    }
  }
  getPredsForAmbigAlts(ambigAlts, configs, altCount) {
    let altToPred = [];
    for (const c of configs) {
      if (ambigAlts.get(c.alt)) {
        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] ?? null, c.semanticContext);
      }
    }
    let nPredAlts = 0;
    for (let i = 1; i < altCount + 1; i++) {
      const pred = altToPred[i] ?? null;
      if (pred === null) {
        altToPred[i] = SemanticContext.NONE;
      } else if (pred !== SemanticContext.NONE) {
        nPredAlts += 1;
      }
    }
    if (nPredAlts === 0) {
      altToPred = null;
    }
    if (_ParserATNSimulator.debug) {
      console.log("getPredsForAmbigAlts result " + arrayToString(altToPred));
    }
    return altToPred;
  }
  getPredicatePredictions(ambigAlts, altToPred) {
    const pairs = [];
    let containsPredicate = false;
    for (let i = 1; i < altToPred.length; i++) {
      const pred = altToPred[i];
      if (ambigAlts.get(i)) {
        pairs.push({ pred, alt: i });
      }
      if (pred !== SemanticContext.NONE) {
        containsPredicate = true;
      }
    }
    if (!containsPredicate) {
      return null;
    }
    return pairs;
  }
  /**
   * This method is used to improve the localization of error messages by
   * choosing an alternative rather than throwing a
   * {@link NoViableAltException} in particular prediction scenarios where the
   * {@link ERROR} state was reached during ATN simulation.
   *
   *
   * The default implementation of this method uses the following
   * algorithm to identify an ATN configuration which successfully parsed the
   * decision entry rule. Choosing such an alternative ensures that the
   * {@link ParserRuleContext} returned by the calling rule will be complete
   * and valid, and the syntax error will be reported later at a more
   * localized location.
   *
   * - If a syntactically valid path or paths reach the end of the decision rule and
   * they are semantically valid if predicated, return the min associated alt.
   * - Else, if a semantically invalid but syntactically valid path exist
   * or paths exist, return the minimum associated alt.
   *
   * - Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.
   *
   *
   * In some scenarios, the algorithm described above could predict an
   * alternative which will result in a {@link FailedPredicateException} in
   * the parser. Specifically, this could occur if the *only* configuration
   * capable of successfully parsing to the end of the decision rule is
   * blocked by a semantic predicate. By choosing this alternative within
   * {@link adaptivePredict} instead of throwing a
   * {@link NoViableAltException}, the resulting
   * {@link FailedPredicateException} in the parser will identify the specific
   * predicate which is preventing the parser from successfully parsing the
   * decision rule, which helps developers identify and correct logic errors
   * in semantic predicates.
   *
   * @param configs The ATN configurations which were valid immediately before
   * the {@link ERROR} state was reached
   * @param outerContext The is the \gamma_0 initial parser context from the paper
   * or the parser stack at the instant before prediction commences.
   *
   * @returns The value to return from {@link adaptivePredict}, or
   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
   * identified and {@link adaptivePredict} should report an error instead
   */
  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
    const splitConfigs = this.splitAccordingToSemanticValidity(configs, outerContext);
    const semValidConfigs = splitConfigs[0];
    const semInvalidConfigs = splitConfigs[1];
    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt !== ATN.INVALID_ALT_NUMBER) {
      return alt;
    }
    if (semInvalidConfigs.length > 0) {
      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
      if (alt !== ATN.INVALID_ALT_NUMBER) {
        return alt;
      }
    }
    return ATN.INVALID_ALT_NUMBER;
  }
  getAltThatFinishedDecisionEntryRule(configs) {
    const alts = [];
    for (const c of configs) {
      if (c.reachesIntoOuterContext || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
        if (alts.indexOf(c.alt) < 0) {
          alts.push(c.alt);
        }
      }
    }
    if (alts.length === 0) {
      return ATN.INVALID_ALT_NUMBER;
    } else {
      return Math.min(...alts);
    }
  }
  /**
   * Walk the list of configurations and split them according to
   * those that have preds evaluating to true/false.  If no pred, assume
   * true pred and include in succeeded set.  Returns Pair of sets.
   *
   * Create a new set so as not to alter the incoming parameter.
   *
   * Assumption: the input stream has been restored to the starting point
   * prediction, which is where predicates need to evaluate.
   */
  splitAccordingToSemanticValidity(configs, outerContext) {
    const succeeded = new ATNConfigSet(configs.fullCtx);
    const failed = new ATNConfigSet(configs.fullCtx);
    for (const c of configs) {
      if (c.semanticContext !== SemanticContext.NONE) {
        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
        if (predicateEvaluationResult) {
          succeeded.add(c);
        } else {
          failed.add(c);
        }
      } else {
        succeeded.add(c);
      }
    }
    return [succeeded, failed];
  }
  /**
   * Look through a list of predicate/alt pairs, returning alts for the
   * pairs that win. A `NONE` predicate indicates an alt containing an
   * unpredicated config which behaves as "always true." If !complete
   * then we stop at the first predicate that evaluates to true. This
   * includes pairs with null predicates.
   */
  evalSemanticContext(predPredictions, outerContext, complete) {
    const predictions = new BitSet();
    for (const pair of predPredictions) {
      if (pair.pred === SemanticContext.NONE) {
        predictions.set(pair.alt);
        if (!complete) {
          break;
        }
        continue;
      }
      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
      if (_ParserATNSimulator.debug || _ParserATNSimulator.dfaDebug) {
        console.log("eval pred " + pair + "=" + predicateEvaluationResult);
      }
      if (predicateEvaluationResult) {
        predictions.set(pair.alt);
        if (!complete) {
          break;
        }
      }
    }
    return predictions;
  }
  // TODO: If we are doing predicates, there is no point in pursuing
  //     closure operations if we reach a DFA state that uniquely predicts
  //     alternative. We will not be caching that DFA state and it is a
  //     waste to pursue the closure. Might have to advance when we do
  //     ambig detection thought :(
  //
  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    const initialDepth = 0;
    this.closureCheckingStopState(
      config,
      configs,
      closureBusy,
      collectPredicates,
      fullCtx,
      initialDepth,
      treatEofAsEpsilon
    );
  }
  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (_ParserATNSimulator.traceATNSimulator || _ParserATNSimulator.debugClosure) {
      console.log("closure(" + config.toString(this.parser, true) + ")");
    }
    if (config.state instanceof RuleStopState) {
      if (config.context && !config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
            if (fullCtx) {
              configs.add(
                ATNConfig.createWithConfig(
                  config.state,
                  config,
                  EmptyPredictionContext.instance
                ),
                this.mergeCache
              );
              continue;
            } else {
              if (_ParserATNSimulator.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
              }
              this.closure_(
                config,
                configs,
                closureBusy,
                collectPredicates,
                fullCtx,
                depth,
                treatEofAsEpsilon
              );
            }
            continue;
          }
          const returnState = this.atn.states[config.context.getReturnState(i)];
          const newContext = config.context.getParent(i);
          const c = ATNConfig.createWithContext(returnState, config.alt, newContext, config.semanticContext);
          c.reachesIntoOuterContext = config.reachesIntoOuterContext;
          this.closureCheckingStopState(
            c,
            configs,
            closureBusy,
            collectPredicates,
            fullCtx,
            depth - 1,
            treatEofAsEpsilon
          );
        }
        return;
      } else if (fullCtx) {
        configs.add(config, this.mergeCache);
        return;
      } else {
        if (_ParserATNSimulator.debug) {
          console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
        }
      }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
  }
  // Do the actual work of walking epsilon edges//
  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    const p = config.state;
    if (!p.epsilonOnlyTransitions) {
      configs.add(config, this.mergeCache);
    }
    for (let i = 0; i < p.transitions.length; i++) {
      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) {
        continue;
      }
      const t = p.transitions[i];
      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
      if (c) {
        let newDepth = depth;
        if (config.state.constructor.stateType === ATNState.RULE_STOP) {
          if (this.predictionState.dfa && this.predictionState?.dfa.isPrecedenceDfa) {
            const outermostPrecedenceReturn = t.outermostPrecedenceReturn;
            if (outermostPrecedenceReturn === this.predictionState?.dfa.atnStartState?.ruleIndex) {
              c.precedenceFilterSuppressed = true;
            }
          }
          c.reachesIntoOuterContext = true;
          if (closureBusy.getOrAdd(c) !== c) {
            continue;
          }
          configs.dipsIntoOuterContext = true;
          newDepth -= 1;
          if (_ParserATNSimulator.debug) {
            console.log("dips into outer ctx: " + c);
          }
        } else {
          if (!t.isEpsilon && closureBusy.getOrAdd(c) !== c) {
            continue;
          }
          if (t instanceof RuleTransition) {
            if (newDepth >= 0) {
              newDepth += 1;
            }
          }
        }
        this.closureCheckingStopState(
          c,
          configs,
          closureBusy,
          continueCollecting,
          fullCtx,
          newDepth,
          treatEofAsEpsilon
        );
      }
    }
  }
  canDropLoopEntryEdgeInLeftRecursiveRule(config) {
    const p = config.state;
    if (p.constructor.stateType !== ATNState.STAR_LOOP_ENTRY || !config.context) {
      return false;
    }
    if (!p.precedenceRuleDecision || config.context.isEmpty() || config.context.hasEmptyPath()) {
      return false;
    }
    const numCtxs = config.context.length;
    for (let i = 0; i < numCtxs; i++) {
      const returnState = this.atn.states[config.context.getReturnState(i)];
      if (returnState.ruleIndex !== p.ruleIndex) {
        return false;
      }
    }
    const decisionStartState = p.transitions[0].target;
    const blockEndStateNum = decisionStartState.endState.stateNumber;
    const blockEndState = this.atn.states[blockEndStateNum];
    for (let i = 0; i < numCtxs; i++) {
      const returnStateNumber = config.context.getReturnState(i);
      const returnState = this.atn.states[returnStateNumber];
      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) {
        return false;
      }
      const returnStateTarget = returnState.transitions[0].target;
      if (returnState.constructor.stateType === ATNState.BLOCK_END && returnStateTarget === p) {
        continue;
      }
      if (returnState === blockEndState) {
        continue;
      }
      if (returnStateTarget === blockEndState) {
        continue;
      }
      if (returnStateTarget.constructor.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) {
        continue;
      }
      return false;
    }
    return true;
  }
  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch (t.transitionType) {
      case Transition.RULE: {
        return this.ruleTransition(config, t);
      }
      case Transition.PRECEDENCE: {
        return this.precedenceTransition(
          config,
          t,
          collectPredicates,
          inContext,
          fullCtx
        );
      }
      case Transition.PREDICATE: {
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
      }
      case Transition.ACTION: {
        if (_ParserATNSimulator.debug) {
          const at = t;
          const index = at.actionIndex === -1 ? 65535 : at.actionIndex;
          console.log("ACTION edge " + at.ruleIndex + ":" + index);
        }
        return ATNConfig.createWithConfig(t.target, config);
      }
      case Transition.EPSILON: {
        return ATNConfig.createWithConfig(t.target, config);
      }
      case Transition.ATOM:
      case Transition.RANGE:
      case Transition.SET: {
        if (treatEofAsEpsilon) {
          if (t.matches(Token.EOF, 0, 1)) {
            return ATNConfig.createWithConfig(t.target, config);
          }
        }
        return null;
      }
      default:
        return null;
    }
  }
  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (_ParserATNSimulator.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && inContext) {
      if (fullCtx && this.predictionState?.input) {
        const currentPosition = this.predictionState.input.index;
        this.predictionState.input.seek(this.predictionState.startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
        this.predictionState.input.seek(currentPosition);
        if (predSucceeds) {
          c = ATNConfig.createWithConfig(pt.target, config);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
      }
    } else {
      c = ATNConfig.createWithConfig(pt.target, config);
    }
    if (_ParserATNSimulator.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  predTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (_ParserATNSimulator.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
      if (this.parser !== null) {
        console.log("context surrounding pred is " + arrayToString(this.parser.getRuleInvocationStack()));
      }
    }
    let c = null;
    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
      if (fullCtx && this.predictionState?.input) {
        const currentPosition = this.predictionState.input.index;
        this.predictionState.input.seek(this.predictionState.startIndex);
        const predSucceeds = pt.getPredicate().evaluate(this.parser, this.predictionState.outerContext);
        this.predictionState.input.seek(currentPosition);
        if (predSucceeds) {
          c = ATNConfig.createWithConfig(pt.target, config);
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = ATNConfig.createWithSemanticContext(pt.target, config, newSemCtx);
      }
    } else {
      c = ATNConfig.createWithConfig(pt.target, config);
    }
    if (_ParserATNSimulator.debug) {
      console.log("config from pred transition=" + c);
    }
    return c;
  }
  ruleTransition(config, t) {
    if (_ParserATNSimulator.debug) {
      console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    const returnState = t.followState;
    const newContext = createSingletonPredictionContext(config.context ?? void 0, returnState.stateNumber);
    return ATNConfig.createWithConfig(t.target, config, newContext);
  }
  getConflictingAlts(configs) {
    const altSets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altSets);
  }
  /**
   * Sam pointed out a problem with the previous definition, v3, of
   * ambiguous states. If we have another state associated with conflicting
   * alternatives, we should keep going. For example, the following grammar
   *
   * s : (ID | ID ID?) ';' ;
   *
   * When the ATN simulation reaches the state before ';', it has a DFA
   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
   * because alternative to has another way to continue, via [6|2|[]].
   * The key is that we have a single state that has config's only associated
   * with a single alternative, 2, and crucially the state transitions
   * among the configurations are all non-epsilon transitions. That means
   * we don't consider any conflicts that include alternative 2. So, we
   * ignore the conflict between alts 1 and 2. We ignore a set of
   * conflicting alts when there is an intersection with an alternative
   * associated with a single alt state in the state -> config-list map.
   *
   * It's also the case that we might have two conflicting configurations but
   * also a 3rd nonconflicting configuration for a different alternative:
   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
   *
   * a : A | A | A B ;
   *
   * After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not
   * stop working on this state. In the previous example, we're concerned
   * with states associated with the conflicting alternatives. Here alt
   * 3 is not associated with the conflicting configs, but since we can continue
   * looking for input reasonably, I don't declare the state done. We
   * ignore a set of conflicting alts when we have an alternative
   * that we still need to pursue
   */
  getConflictingAltsOrUniqueAlt(configs) {
    let conflictingAlts;
    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = new BitSet();
      conflictingAlts.set(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
  }
  noViableAlt(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
  }
  /**
   * Add an edge to the DFA, if possible. This method calls
   * {@link addDFAState} to ensure the `to` state is present in the
   * DFA. If `from` is `null`, or if `t` is outside the
   * range of edges that can be represented in the DFA tables, this method
   * returns without adding the edge to the DFA.
   *
   * If `to` is `null`, this method returns `null`.
   * Otherwise, this method returns the {@link DFAState} returned by calling
   * {@link addDFAState} for the `to` state.
   *
   * @param dfa The DFA
   * @param from The source state for the edge
   * @param t The input symbol
   * @param to The target state for the edge
   *
   * @returns If `to` is `null`, this method returns `null`;
   * otherwise this method returns the result of calling {@link addDFAState}
   * on `to`
   */
  addDFAEdge(dfa, from, t, to) {
    if (_ParserATNSimulator.debug) {
      console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
    }
    to = this.addDFAState(dfa, to);
    if (t < -1 || t > this.atn.maxTokenType) {
      return to;
    }
    if (_ParserATNSimulator.debug) {
      console.log("DFA=\n" + dfa.toString(this.parser != null ? this.parser.vocabulary : Vocabulary.EMPTY_VOCABULARY));
    }
    from.edges[t + 1] = to;
    return to;
  }
  /**
   * Add state `D` to the DFA if it is not already present, and return
   * the actual instance stored in the DFA. If a state equivalent to `D`
   * is already in the DFA, the existing state is returned. Otherwise this
   * method returns `D` after adding it to the DFA.
   *
   * If `D` is {@link ERROR}, this method returns {@link ERROR} and
   * does not change the DFA.
   *
   * @param dfa The dfa.
   * @param newState The DFA state to add.
   *
   * @returns The state stored in the DFA. This will be either the existing state if `newState` is already in
   *          the DFA, or `newState` itself if the state was not already present.
   */
  addDFAState(dfa, newState) {
    if (newState === ATNSimulator.ERROR) {
      return newState;
    }
    const existing = dfa.getState(newState);
    if (existing !== null) {
      return existing;
    }
    if (!newState.configs.readOnly) {
      newState.configs.optimizeConfigs(this);
      newState.configs.setReadonly(true);
    }
    if (_ParserATNSimulator.traceATNSimulator) {
      console.log("addDFAState new " + newState);
    }
    dfa.addState(newState);
    return newState;
  }
  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
    }
    this.parser.errorListenerDispatch.reportAttemptingFullContext(
      this.parser,
      dfa,
      startIndex,
      stopIndex,
      conflictingAlts,
      configs
    );
  }
  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
    }
    this.parser.errorListenerDispatch.reportContextSensitivity(
      this.parser,
      dfa,
      startIndex,
      stopIndex,
      prediction,
      configs
    );
  }
  // If context sensitive parsing, we know it's ambiguity not conflict.
  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (_ParserATNSimulator.debug || _ParserATNSimulator.retryDebug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.tokenStream.getTextFromInterval(interval));
    }
    this.parser.errorListenerDispatch.reportAmbiguity(
      this.parser,
      dfa,
      startIndex,
      stopIndex,
      exact,
      ambigAlts,
      configs
    );
  }
};

// src/atn/PredictionContextCache.ts
var PredictionContextCache = class {
  static {
    __name(this, "PredictionContextCache");
  }
  cache = new HashMap(ObjectEqualityComparator.instance);
  /**
   * Add a context to the cache and return it. If the context already exists,
   * return that one instead and do not add a new context to the cache.
   * Protect shared cache from unsafe thread access.
   *
   * @param ctx tbd
   * @returns tbd
   */
  add(ctx) {
    if (ctx === EmptyPredictionContext.instance) {
      return ctx;
    }
    const existing = this.cache.get(ctx);
    if (existing) {
      return existing;
    }
    this.cache.set(ctx, ctx);
    return ctx;
  }
  get(ctx) {
    return this.cache.get(ctx);
  }
  get length() {
    return this.cache.size;
  }
};

// src/atn/ProfilingATNSimulator.ts
var ProfilingATNSimulator = class extends ParserATNSimulator {
  static {
    __name(this, "ProfilingATNSimulator");
  }
  decisions;
  numDecisions = 0;
  currentDecision = 0;
  currentState;
  /**
   * At the point of LL failover, we record how SLL would resolve the conflict so that
   *  we can determine whether or not a decision / input pair is context-sensitive.
   *  If LL gives a different result than SLL's predicted alternative, we have a
   *  context sensitivity for sure. The converse is not necessarily true, however.
   *  It's possible that after conflict resolution chooses minimum alternatives,
   *  SLL could get the same answer as LL. Regardless of whether or not the result indicates
   *  an ambiguity, it is not treated as a context sensitivity because LL prediction
   *  was not required in order to produce a correct prediction for this decision and input sequence.
   *  It may in fact still be a context sensitivity but we don't know by looking at the
   *  minimum alternatives for the current input.
   */
  conflictingAltResolvedBySLL;
  sllStopIndex = 0;
  llStopIndex = 0;
  constructor(parser) {
    const sharedContextCache = parser.interpreter.sharedContextCache;
    super(parser, parser.interpreter.atn, parser.interpreter.decisionToDFA, sharedContextCache);
    if (sharedContextCache) {
      this.numDecisions = this.atn.decisionToState.length;
      this.decisions = new Array(this.numDecisions);
      for (let i = 0; i < this.numDecisions; i++) {
        this.decisions[i] = new DecisionInfo(i);
      }
    }
  }
  adaptivePredict(input, decision, outerContext) {
    try {
      this.sllStopIndex = -1;
      this.llStopIndex = -1;
      this.currentDecision = decision;
      const start = performance.now();
      const alt = super.adaptivePredict(input, decision, outerContext);
      const stop = performance.now();
      this.decisions[decision].timeInPrediction += stop - start;
      this.decisions[decision].invocations++;
      const sllLook = this.sllStopIndex - this.predictionState.startIndex + 1;
      this.decisions[decision].sllTotalLook += sllLook;
      this.decisions[decision].sllMinLook = this.decisions[decision].sllMinLook === 0 ? sllLook : Math.min(this.decisions[decision].sllMinLook, sllLook);
      if (sllLook > this.decisions[decision].sllMaxLook) {
        this.decisions[decision].sllMaxLook = sllLook;
        this.decisions[decision].sllMaxLookEvent = {
          decision,
          configs: null,
          predictedAlt: alt,
          input,
          startIndex: this.predictionState.startIndex,
          stopIndex: this.sllStopIndex,
          fullCtx: false
        };
      }
      if (this.llStopIndex >= 0) {
        const llLook = this.llStopIndex - this.predictionState.startIndex + 1;
        this.decisions[decision].llTotalLook += llLook;
        this.decisions[decision].llMinLook = this.decisions[decision].llMinLook === 0 ? llLook : Math.min(this.decisions[decision].llMinLook, llLook);
        if (llLook > this.decisions[decision].llMaxLook) {
          this.decisions[decision].llMaxLook = llLook;
          this.decisions[decision].llMaxLookEvent = {
            decision,
            configs: null,
            predictedAlt: alt,
            input,
            startIndex: this.predictionState.startIndex,
            stopIndex: this.llStopIndex,
            fullCtx: true
          };
        }
      }
      return alt;
    } finally {
      this.currentDecision = -1;
    }
  }
  getExistingTargetState(previousD, t) {
    this.sllStopIndex = this.predictionState.input.index;
    const existingTargetState = super.getExistingTargetState(previousD, t);
    if (existingTargetState !== void 0) {
      this.decisions[this.currentDecision].sllDFATransitions++;
      if (existingTargetState === ATNSimulator.ERROR) {
        this.decisions[this.currentDecision].errors.push({
          decision: this.currentDecision,
          configs: previousD.configs,
          input: this.predictionState.input,
          startIndex: this.predictionState.startIndex,
          stopIndex: this.sllStopIndex,
          fullCtx: false
        });
      }
    }
    this.currentState = existingTargetState;
    return existingTargetState;
  }
  computeTargetState(dfa, previousD, t) {
    const state = super.computeTargetState(dfa, previousD, t);
    this.currentState = state;
    return state;
  }
  computeReachSet(closure, t, fullCtx) {
    if (fullCtx && this.predictionState?.input) {
      this.llStopIndex = this.predictionState.input.index;
    }
    const reachConfigs = super.computeReachSet(closure, t, fullCtx);
    if (this.predictionState?.input) {
      if (fullCtx) {
        this.decisions[this.currentDecision].llATNTransitions++;
        if (reachConfigs === null) {
          this.decisions[this.currentDecision].errors.push({
            decision: this.currentDecision,
            configs: closure,
            input: this.predictionState.input,
            startIndex: this.predictionState.startIndex,
            stopIndex: this.sllStopIndex,
            fullCtx: true
          });
        }
      } else {
        this.decisions[this.currentDecision].sllATNTransitions++;
        if (reachConfigs === null) {
          this.decisions[this.currentDecision].errors.push({
            decision: this.currentDecision,
            configs: closure,
            input: this.predictionState.input,
            startIndex: this.predictionState.startIndex,
            stopIndex: this.sllStopIndex,
            fullCtx: false
          });
        }
      }
    }
    return reachConfigs;
  }
  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (conflictingAlts !== null) {
      this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
    } else {
      this.conflictingAltResolvedBySLL = configs.getAlts().nextSetBit(0);
    }
    this.decisions[this.currentDecision].llFallback++;
    if (conflictingAlts) {
      super.reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex);
    }
  }
  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (prediction !== this.conflictingAltResolvedBySLL && this.predictionState.input) {
      this.decisions[this.currentDecision].contextSensitivities.push({
        decision: this.currentDecision,
        configs,
        input: this.predictionState.input,
        startIndex,
        stopIndex,
        fullCtx: true
      });
    }
    super.reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex);
  }
  reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs) {
    let prediction;
    if (ambigAlts) {
      prediction = ambigAlts.nextSetBit(0);
    } else {
      prediction = configs.getAlts().nextSetBit(0);
    }
    if (this.predictionState?.input) {
      if (configs.fullCtx && prediction !== this.conflictingAltResolvedBySLL) {
        this.decisions[this.currentDecision].contextSensitivities.push({
          decision: this.currentDecision,
          configs,
          input: this.predictionState.input,
          startIndex,
          stopIndex,
          fullCtx: true
        });
      }
      this.decisions[this.currentDecision].ambiguities.push({
        ambigAlts,
        decision: this.currentDecision,
        configs,
        input: this.predictionState.input,
        startIndex,
        stopIndex,
        fullCtx: configs.fullCtx
      });
    }
    super.reportAmbiguity(dfa, state, startIndex, stopIndex, exact, ambigAlts, configs);
  }
  getDecisionInfo() {
    return this.decisions;
  }
  getCurrentState() {
    return this.currentState;
  }
};

// src/dfa/PredPrediction.ts
var PredPrediction;
((PredPrediction2) => {
  PredPrediction2.toString = /* @__PURE__ */ __name((prediction) => {
    return `(${prediction.pred}, ${prediction.alt})`;
  }, "toString");
})(PredPrediction || (PredPrediction = {}));

// src/misc/ParseCancellationException.ts
var ParseCancellationException = class extends Error {
  static {
    __name(this, "ParseCancellationException");
  }
  constructor(e) {
    super();
    this.cause = e;
  }
};

// src/misc/InterpreterDataReader.ts
var InterpreterDataReader = class {
  static {
    __name(this, "InterpreterDataReader");
  }
  /**
   * The structure of the data file is very simple. Everything is line based with empty lines
   * separating the different parts. For lexers the layout is:
   * token literal names:
   * ...
   *
   * token symbolic names:
   * ...
   *
   * rule names:
   * ...
   *
   * channel names:
   * ...
   *
   * mode names:
   * ...
   *
   * atn:
   * a single line with comma separated int values, enclosed in a pair of squared brackets.
   *
   * Data for a parser does not contain channel and mode names.
   */
  static parseInterpreterData(source) {
    const ruleNames = [];
    const channels = [];
    const modes = [];
    const literalNames = [];
    const symbolicNames = [];
    const lines = source.split("\n");
    let index = 0;
    let line = lines[index++];
    if (line !== "token literal names:") {
      throw new Error("Unexpected data entry");
    }
    do {
      line = lines[index++];
      if (line.length === 0) {
        break;
      }
      literalNames.push(line === "null" ? null : line);
    } while (true);
    line = lines[index++];
    if (line !== "token symbolic names:") {
      throw new Error("Unexpected data entry");
    }
    do {
      line = lines[index++];
      if (line.length === 0) {
        break;
      }
      symbolicNames.push(line === "null" ? null : line);
    } while (true);
    line = lines[index++];
    if (line !== "rule names:") {
      throw new Error("Unexpected data entry");
    }
    do {
      line = lines[index++];
      if (line.length === 0) {
        break;
      }
      ruleNames.push(line);
    } while (true);
    line = lines[index++];
    if (line === "channel names:") {
      do {
        line = lines[index++];
        if (line.length === 0) {
          break;
        }
        channels.push(line);
      } while (true);
      line = lines[index++];
      if (line !== "mode names:") {
        throw new Error("Unexpected data entry");
      }
      do {
        line = lines[index++];
        if (line.length === 0) {
          break;
        }
        modes.push(line);
      } while (true);
    }
    line = lines[index++];
    if (line !== "atn:") {
      throw new Error("Unexpected data entry");
    }
    line = lines[index++];
    const elements = line.split(",");
    let value;
    const serializedATN = [];
    for (let i = 0; i < elements.length; ++i) {
      const element = elements[i];
      if (element.startsWith("[")) {
        value = Number(element.substring(1).trim());
      } else if (element.endsWith("]")) {
        value = Number(element.substring(0, element.length - 1).trim());
      } else {
        value = Number(element.trim());
      }
      serializedATN[i] = value;
    }
    const deserializer = new ATNDeserializer();
    return {
      atn: deserializer.deserialize(serializedATN),
      vocabulary: new Vocabulary(literalNames, symbolicNames, []),
      ruleNames,
      channels: channels.length > 0 ? channels : void 0,
      modes: modes.length > 0 ? modes : void 0
    };
  }
};

// src/tree/AbstractParseTreeVisitor.ts
var AbstractParseTreeVisitor = class {
  static {
    __name(this, "AbstractParseTreeVisitor");
  }
  visit(tree) {
    return tree.accept(this);
  }
  visitChildren(node) {
    let result = this.defaultResult();
    const n2 = node.getChildCount();
    for (let i = 0; i < n2; i++) {
      if (!this.shouldVisitNextChild(node, result)) {
        break;
      }
      const c = node.getChild(i);
      if (c) {
        const childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);
      }
    }
    return result;
  }
  visitTerminal(_node) {
    return this.defaultResult();
  }
  visitErrorNode(_node) {
    return this.defaultResult();
  }
  defaultResult() {
    return null;
  }
  shouldVisitNextChild(_node, _currentResult) {
    return true;
  }
  aggregateResult(aggregate, nextResult) {
    return nextResult;
  }
};

// src/tree/ParseTreeWalker.ts
var ParseTreeWalker = class _ParseTreeWalker {
  static {
    __name(this, "ParseTreeWalker");
  }
  static DEFAULT = new _ParseTreeWalker();
  /**
   * Performs a walk on the given parse tree starting at the root and going down recursively
   * with depth-first search. On each node, {@link ParseTreeWalker.enterRule} is called before
   * recursively walking down into child nodes, then
   * {@link ParseTreeWalker.exitRule} is called after the recursive call to wind up.
   *
   * @param listener The listener used by the walker to process grammar rules
   * @param t The parse tree to be walked on
   */
  walk(listener, t) {
    const errorNode = t instanceof ErrorNode;
    if (errorNode) {
      listener.visitErrorNode(t);
    } else if (t instanceof TerminalNode) {
      listener.visitTerminal(t);
    } else {
      const r = t;
      this.enterRule(listener, r);
      for (let i = 0; i < t.getChildCount(); i++) {
        this.walk(listener, t.getChild(i));
      }
      this.exitRule(listener, r);
    }
  }
  /**
   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener.enterEveryRule}
   * then by triggering the event specific to the given parse tree node
   *
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  enterRule(listener, r) {
    const ctx = r.ruleContext;
    listener.enterEveryRule(ctx);
    ctx.enterRule(listener);
  }
  /**
   * Exits a grammar rule by first triggering the event specific to the given parse tree node
   * then by triggering the generic event {@link ParseTreeListener.exitEveryRule}
   *
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */
  exitRule(listener, r) {
    const ctx = r.ruleContext;
    ctx.exitRule(listener);
    listener.exitEveryRule(ctx);
  }
};

// src/CharStream.ts
var CharStream;
((CharStream2) => {
  CharStream2.fromString = /* @__PURE__ */ __name((str) => {
    return new CharStreamImpl(str);
  }, "fromString");
})(CharStream || (CharStream = {}));
var CharStreamImpl = class {
  static {
    __name(this, "CharStreamImpl");
  }
  name = "";
  index = 0;
  data;
  constructor(input) {
    const codePoints = [];
    for (const char of input) {
      codePoints.push(char.codePointAt(0));
    }
    this.data = new Uint32Array(codePoints);
  }
  /**
   * Reset the stream so that it's in the same state it was
   * when the object was created *except* the data array is not
   * touched.
   */
  reset() {
    this.index = 0;
  }
  consume() {
    if (this.index >= this.data.length) {
      throw new Error("cannot consume EOF");
    }
    this.index += 1;
  }
  LA(offset) {
    if (offset === 0) {
      return 0;
    }
    if (offset < 0) {
      offset += 1;
    }
    const pos = this.index + offset - 1;
    if (pos < 0 || pos >= this.data.length) {
      return Token.EOF;
    }
    return this.data[pos];
  }
  // mark/release do nothing; we have entire buffer
  mark() {
    return -1;
  }
  release(_marker) {
  }
  /**
   * consume() ahead until p==_index; can't just set p=_index as we must
   * update line and column. If we seek backwards, just set p
   */
  seek(index) {
    if (index <= this.index) {
      this.index = index;
      return;
    }
    this.index = Math.min(index, this.data.length);
  }
  getTextFromRange(start, stop) {
    stop = stop ?? this.data.length - 1;
    if (stop >= this.data.length) {
      stop = this.data.length - 1;
    }
    if (start >= this.data.length) {
      return "";
    }
    return this.stringFromRange(start, stop + 1);
  }
  getTextFromInterval(interval) {
    const start = interval.start;
    let stop = interval.stop;
    if (stop >= this.data.length) {
      stop = this.data.length - 1;
    }
    if (start >= this.data.length) {
      return "";
    }
    return this.stringFromRange(start, stop + 1);
  }
  toString() {
    return this.stringFromRange(0);
  }
  get size() {
    return this.data.length;
  }
  getSourceName() {
    if (this.name) {
      return this.name;
    }
    return IntStream.UNKNOWN_SOURCE_NAME;
  }
  stringFromRange(start, stop) {
    const data = this.data.slice(start, stop);
    let result = "";
    data.forEach((value) => {
      result += String.fromCodePoint(value);
    });
    return result;
  }
};

// src/WritableToken.ts
var isWritableToken = /* @__PURE__ */ __name((candidate) => {
  return candidate.setText !== void 0;
}, "isWritableToken");

// src/BufferedTokenStream.ts
var BufferedTokenStream = class {
  static {
    __name(this, "BufferedTokenStream");
  }
  /**
   * The {@link TokenSource} from which tokens for this stream are fetched.
   */
  tokenSource;
  /**
   * A collection of all tokens fetched from the token source. The list is
   * considered a complete view of the input once {@link fetchedEOF} is set
   * to `true`.
   */
  tokens = [];
  /**
   * The index into {@link tokens} of the current token (next token to
   * {@link consume}). {@link tokens}`[p]` should be
   * {@link LT LT(1)}.
   *
   * This field is set to -1 when the stream is first constructed or when
   * {@link setTokenSource} is called, indicating that the first token has
   * not yet been fetched from the token source. For additional information,
   * see the documentation of {@link IntStream} for a description of
   * Initializing Methods.
   */
  p = -1;
  /**
   * Indicates whether the {@link Token.EOF} token has been fetched from
   * {@link tokenSource} and added to {@link tokens}. This field improves
   * performance for the following cases:
   *
   * - {@link consume}: The lookahead check in {@link consume} to prevent
   * consuming the EOF symbol is optimized by checking the values of
   * {@link fetchedEOF} and {@link p} instead of calling {@link LA}.
   * - {@link fetch}: The check to prevent adding multiple EOF symbols into
   * {@link tokens} is trivial with this field.
   */
  fetchedEOF = false;
  constructor(tokenSource) {
    this.tokenSource = tokenSource;
  }
  mark() {
    return 0;
  }
  release(_marker) {
  }
  reset() {
    this.seek(0);
  }
  seek(index) {
    this.lazyInit();
    this.p = this.adjustSeekIndex(index);
  }
  get size() {
    return this.tokens.length;
  }
  get index() {
    return this.p;
  }
  get(index) {
    this.lazyInit();
    return this.tokens[index];
  }
  consume() {
    let skipEofCheck = false;
    if (this.p >= 0) {
      if (this.fetchedEOF) {
        skipEofCheck = this.p < this.tokens.length - 1;
      } else {
        skipEofCheck = this.p < this.tokens.length;
      }
    } else {
      skipEofCheck = false;
    }
    if (!skipEofCheck && this.LA(1) === Token.EOF) {
      throw new Error("cannot consume EOF");
    }
    if (this.sync(this.p + 1)) {
      this.p = this.adjustSeekIndex(this.p + 1);
    }
  }
  /**
   * Make sure index `i` in tokens has a token.
   *
   * @returns {boolean} `true` if a token is located at index `i`, otherwise `false`.
   */
  sync(i) {
    const n2 = i - this.tokens.length + 1;
    if (n2 > 0) {
      const fetched = this.fetch(n2);
      return fetched >= n2;
    }
    return true;
  }
  /**
   * Add `n` elements to buffer.
   *
   * @returns {number} The actual number of elements added to the buffer.
   */
  fetch(n2) {
    if (this.fetchedEOF) {
      return 0;
    }
    for (let i = 0; i < n2; i++) {
      const t = this.tokenSource.nextToken();
      if (isWritableToken(t)) {
        t.tokenIndex = this.tokens.length;
      }
      this.tokens.push(t);
      if (t.type === Token.EOF) {
        this.fetchedEOF = true;
        return i + 1;
      }
    }
    return n2;
  }
  /** Get all tokens from start..stop, inclusively. */
  getTokens(start, stop, types) {
    this.lazyInit();
    if (start === void 0 && stop === void 0) {
      return this.tokens;
    }
    start ??= 0;
    if (stop === void 0) {
      stop = this.tokens.length - 1;
    }
    if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
      throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
    }
    if (start > stop) {
      return [];
    }
    if (types === void 0) {
      return this.tokens.slice(start, stop + 1);
    }
    const subset = [];
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    for (let i = start; i < stop; i++) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        subset.push(t);
        break;
      }
      if (types.has(t.type)) {
        subset.push(t);
      }
    }
    return subset;
  }
  LA(k) {
    return this.LT(k)?.type ?? Token.INVALID_TYPE;
  }
  LB(k) {
    if (this.p - k < 0) {
      return null;
    }
    return this.tokens[this.p - k];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    const i = this.p + k - 1;
    this.sync(i);
    if (i >= this.tokens.length) {
      return this.tokens[this.tokens.length - 1];
    }
    return this.tokens[i];
  }
  /**
   * Allowed derived classes to modify the behavior of operations which change
   * the current stream position by adjusting the target token index of a seek
   * operation. The default implementation simply returns `i`. If an
   * exception is thrown in this method, the current stream index should not be
   * changed.
   *
   * For example, {@link CommonTokenStream} overrides this method to ensure that
   * the seek target is always an on-channel token.
   *
   * @param  i The target token index.
   *
   * @returns The adjusted target token index.
   */
  adjustSeekIndex(i) {
    return i;
  }
  lazyInit() {
    if (this.p === -1) {
      this.setup();
    }
  }
  setup() {
    this.sync(0);
    this.p = this.adjustSeekIndex(0);
  }
  /** Reset this token stream by setting its token source. */
  setTokenSource(tokenSource) {
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.p = -1;
    this.fetchedEOF = false;
  }
  /**
   * Given a starting index, return the index of the next token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and EOF.
   */
  nextTokenOnChannel(i, channel) {
    this.sync(i);
    if (i >= this.tokens.length) {
      return -1;
    }
    let token = this.tokens[i];
    while (token.channel !== channel) {
      if (token.type === Token.EOF) {
        return -1;
      }
      i += 1;
      this.sync(i);
      token = this.tokens[i];
    }
    return i;
  }
  /**
   * Given a starting index, return the index of the previous token on
   * channel. Return `i` if `tokens[i]` is on channel. Return -1
   * if there are no tokens on channel between `i` and 0.
   *
   * If `i` specifies an index at or after the EOF token, the EOF token
   * index is returned. This is due to the fact that the EOF token is treated
   * as though it were on every channel.
   */
  previousTokenOnChannel(i, channel) {
    if (i >= this.tokens.length) {
      return this.tokens.length - 1;
    }
    while (i >= 0) {
      const token = this.tokens[i];
      if (token.type === Token.EOF || token.channel === channel) {
        return i;
      }
      --i;
    }
    return i;
  }
  /**
   * Collect all tokens on specified channel to the right of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
   * EOF. If channel is -1, find any non default channel token.
   */
  getHiddenTokensToRight(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
    }
    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    const from = tokenIndex + 1;
    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
    return this.filterForChannel(from, to, channel);
  }
  /**
   * Collect all tokens on specified channel to the left of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
   * If channel is -1, find any non default channel token.
   */
  getHiddenTokensToLeft(tokenIndex, channel) {
    if (channel === void 0) {
      channel = -1;
    }
    this.lazyInit();
    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw new Error(`${tokenIndex} not in 0..${this.tokens.length - 1}`);
    }
    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    if (prevOnChannel === tokenIndex - 1) {
      return void 0;
    }
    const from = prevOnChannel + 1;
    const to = tokenIndex - 1;
    return this.filterForChannel(from, to, channel);
  }
  filterForChannel(left, right, channel) {
    const hidden = [];
    for (let i = left; i < right + 1; i++) {
      const t = this.tokens[i];
      if (channel === -1) {
        if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
          hidden.push(t);
        }
      } else if (t.channel === channel) {
        hidden.push(t);
      }
    }
    if (hidden.length === 0) {
      return void 0;
    }
    return hidden;
  }
  getSourceName() {
    return this.tokenSource.sourceName;
  }
  /** Get the text of all tokens in this buffer. */
  getText() {
    return this.getTextFromInterval(Interval.of(0, this.size - 1));
  }
  getTextFromInterval(interval) {
    const start = interval.start;
    let stop = interval.stop;
    if (start < 0 || stop < 0) {
      return "";
    }
    this.sync(stop);
    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }
    let result = "";
    for (let i = start; i <= stop; ++i) {
      const t = this.tokens[i];
      if (t.type === Token.EOF) {
        break;
      }
      result += t.text;
    }
    return result;
  }
  getTextFromContext(ctx) {
    return this.getTextFromInterval(ctx.getSourceInterval());
  }
  getTextFromRange(start, stop) {
    if (start !== null && stop !== null) {
      return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
    }
    return "";
  }
  /** Get all tokens from lexer until EOF. */
  fill() {
    this.lazyInit();
    while (this.fetch(1e3) === 1e3) {
      ;
    }
  }
  setLine(line) {
    this.tokenSource.line = line;
  }
  setColumn(column) {
    this.tokenSource.column = column;
  }
};

// src/CommonTokenStream.ts
var CommonTokenStream = class extends BufferedTokenStream {
  static {
    __name(this, "CommonTokenStream");
  }
  /**
   * Specifies the channel to use for filtering tokens.
   *
   *
   * The default value is {@link Token.DEFAULT_CHANNEL}, which matches the
   * default channel assigned to tokens created by the lexer.
   */
  channel = Token.DEFAULT_CHANNEL;
  constructor(lexer, channel) {
    super(lexer);
    this.channel = channel ?? Token.DEFAULT_CHANNEL;
  }
  adjustSeekIndex(i) {
    return this.nextTokenOnChannel(i, this.channel);
  }
  LB(k) {
    if (k === 0 || this.index - k < 0) {
      return null;
    }
    let i = this.index;
    let n2 = 1;
    while (n2 <= k) {
      i = this.previousTokenOnChannel(i - 1, this.channel);
      n2 += 1;
    }
    if (i < 0) {
      return null;
    }
    return this.tokens[i];
  }
  LT(k) {
    this.lazyInit();
    if (k === 0) {
      return null;
    }
    if (k < 0) {
      return this.LB(-k);
    }
    let i = this.index;
    let n2 = 1;
    while (n2 < k) {
      if (this.sync(i + 1)) {
        i = this.nextTokenOnChannel(i + 1, this.channel);
      }
      n2 += 1;
    }
    return this.tokens[i];
  }
  // Count EOF just once.
  getNumberOfOnChannelTokens() {
    let n2 = 0;
    this.fill();
    for (const t of this.tokens) {
      if (t.channel === this.channel) {
        n2 += 1;
      }
      if (t.type === Token.EOF) {
        break;
      }
    }
    return n2;
  }
};

// src/tree/xpath/XPathLexer.ts
var XPathLexer = class _XPathLexer extends Lexer {
  static {
    __name(this, "XPathLexer");
  }
  static TOKEN_REF = 1;
  static RULE_REF = 2;
  static ANYWHERE = 3;
  static ROOT = 4;
  static WILDCARD = 5;
  static BANG = 6;
  static ID = 7;
  static STRING = 8;
  static channelNames = [
    "DEFAULT_TOKEN_CHANNEL",
    "HIDDEN"
  ];
  static literalNames = [
    null,
    null,
    null,
    "'//'",
    "'/'",
    "'*'",
    "'!'"
  ];
  static symbolicNames = [
    null,
    "TOKEN_REF",
    "RULE_REF",
    "ANYWHERE",
    "ROOT",
    "WILDCARD",
    "BANG",
    "ID",
    "STRING"
  ];
  static modeNames = [
    "DEFAULT_MODE"
  ];
  static ruleNames = [
    "ANYWHERE",
    "ROOT",
    "WILDCARD",
    "BANG",
    "ID",
    "NameChar",
    "NameStartChar",
    "STRING"
  ];
  constructor(input) {
    super(input);
    this.interpreter = new LexerATNSimulator(this, _XPathLexer._ATN, _XPathLexer.decisionsToDFA, new PredictionContextCache());
  }
  get grammarFileName() {
    return "XPathLexer.g4";
  }
  get literalNames() {
    return _XPathLexer.literalNames;
  }
  get symbolicNames() {
    return _XPathLexer.symbolicNames;
  }
  get ruleNames() {
    return _XPathLexer.ruleNames;
  }
  get serializedATN() {
    return _XPathLexer._serializedATN;
  }
  get channelNames() {
    return _XPathLexer.channelNames;
  }
  get modeNames() {
    return _XPathLexer.modeNames;
  }
  action(localContext, ruleIndex, actionIndex) {
    switch (ruleIndex) {
      case 4:
        this.ID_action(localContext, actionIndex);
        break;
    }
  }
  ID_action(localContext, actionIndex) {
    switch (actionIndex) {
      case 0:
        const text = this.text;
        if (text.charAt(0) === text.charAt(0).toUpperCase()) {
          this.type = _XPathLexer.TOKEN_REF;
        } else {
          this.type = _XPathLexer.RULE_REF;
        }
        break;
    }
  }
  static _serializedATN = [
    4,
    0,
    8,
    48,
    6,
    -1,
    2,
    0,
    7,
    0,
    2,
    1,
    7,
    1,
    2,
    2,
    7,
    2,
    2,
    3,
    7,
    3,
    2,
    4,
    7,
    4,
    2,
    5,
    7,
    5,
    2,
    6,
    7,
    6,
    2,
    7,
    7,
    7,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    3,
    1,
    3,
    1,
    4,
    1,
    4,
    5,
    4,
    29,
    8,
    4,
    10,
    4,
    12,
    4,
    32,
    9,
    4,
    1,
    4,
    1,
    4,
    1,
    5,
    1,
    5,
    1,
    6,
    1,
    6,
    1,
    7,
    1,
    7,
    5,
    7,
    42,
    8,
    7,
    10,
    7,
    12,
    7,
    45,
    9,
    7,
    1,
    7,
    1,
    7,
    1,
    43,
    0,
    8,
    1,
    3,
    3,
    4,
    5,
    5,
    7,
    6,
    9,
    7,
    11,
    0,
    13,
    0,
    15,
    8,
    1,
    0,
    2,
    784,
    0,
    0,
    8,
    14,
    27,
    48,
    57,
    65,
    90,
    95,
    95,
    97,
    122,
    127,
    159,
    170,
    170,
    173,
    173,
    181,
    181,
    186,
    186,
    192,
    214,
    216,
    246,
    248,
    705,
    710,
    721,
    736,
    740,
    748,
    748,
    750,
    750,
    768,
    884,
    886,
    887,
    890,
    893,
    895,
    895,
    902,
    902,
    904,
    906,
    908,
    908,
    910,
    929,
    931,
    1013,
    1015,
    1153,
    1155,
    1159,
    1162,
    1327,
    1329,
    1366,
    1369,
    1369,
    1376,
    1416,
    1425,
    1469,
    1471,
    1471,
    1473,
    1474,
    1476,
    1477,
    1479,
    1479,
    1488,
    1514,
    1519,
    1522,
    1536,
    1541,
    1552,
    1562,
    1564,
    1564,
    1568,
    1641,
    1646,
    1747,
    1749,
    1757,
    1759,
    1768,
    1770,
    1788,
    1791,
    1791,
    1807,
    1866,
    1869,
    1969,
    1984,
    2037,
    2042,
    2042,
    2045,
    2045,
    2048,
    2093,
    2112,
    2139,
    2144,
    2154,
    2160,
    2183,
    2185,
    2190,
    2192,
    2193,
    2200,
    2403,
    2406,
    2415,
    2417,
    2435,
    2437,
    2444,
    2447,
    2448,
    2451,
    2472,
    2474,
    2480,
    2482,
    2482,
    2486,
    2489,
    2492,
    2500,
    2503,
    2504,
    2507,
    2510,
    2519,
    2519,
    2524,
    2525,
    2527,
    2531,
    2534,
    2545,
    2556,
    2556,
    2558,
    2558,
    2561,
    2563,
    2565,
    2570,
    2575,
    2576,
    2579,
    2600,
    2602,
    2608,
    2610,
    2611,
    2613,
    2614,
    2616,
    2617,
    2620,
    2620,
    2622,
    2626,
    2631,
    2632,
    2635,
    2637,
    2641,
    2641,
    2649,
    2652,
    2654,
    2654,
    2662,
    2677,
    2689,
    2691,
    2693,
    2701,
    2703,
    2705,
    2707,
    2728,
    2730,
    2736,
    2738,
    2739,
    2741,
    2745,
    2748,
    2757,
    2759,
    2761,
    2763,
    2765,
    2768,
    2768,
    2784,
    2787,
    2790,
    2799,
    2809,
    2815,
    2817,
    2819,
    2821,
    2828,
    2831,
    2832,
    2835,
    2856,
    2858,
    2864,
    2866,
    2867,
    2869,
    2873,
    2876,
    2884,
    2887,
    2888,
    2891,
    2893,
    2901,
    2903,
    2908,
    2909,
    2911,
    2915,
    2918,
    2927,
    2929,
    2929,
    2946,
    2947,
    2949,
    2954,
    2958,
    2960,
    2962,
    2965,
    2969,
    2970,
    2972,
    2972,
    2974,
    2975,
    2979,
    2980,
    2984,
    2986,
    2990,
    3001,
    3006,
    3010,
    3014,
    3016,
    3018,
    3021,
    3024,
    3024,
    3031,
    3031,
    3046,
    3055,
    3072,
    3084,
    3086,
    3088,
    3090,
    3112,
    3114,
    3129,
    3132,
    3140,
    3142,
    3144,
    3146,
    3149,
    3157,
    3158,
    3160,
    3162,
    3165,
    3165,
    3168,
    3171,
    3174,
    3183,
    3200,
    3203,
    3205,
    3212,
    3214,
    3216,
    3218,
    3240,
    3242,
    3251,
    3253,
    3257,
    3260,
    3268,
    3270,
    3272,
    3274,
    3277,
    3285,
    3286,
    3293,
    3294,
    3296,
    3299,
    3302,
    3311,
    3313,
    3315,
    3328,
    3340,
    3342,
    3344,
    3346,
    3396,
    3398,
    3400,
    3402,
    3406,
    3412,
    3415,
    3423,
    3427,
    3430,
    3439,
    3450,
    3455,
    3457,
    3459,
    3461,
    3478,
    3482,
    3505,
    3507,
    3515,
    3517,
    3517,
    3520,
    3526,
    3530,
    3530,
    3535,
    3540,
    3542,
    3542,
    3544,
    3551,
    3558,
    3567,
    3570,
    3571,
    3585,
    3642,
    3648,
    3662,
    3664,
    3673,
    3713,
    3714,
    3716,
    3716,
    3718,
    3722,
    3724,
    3747,
    3749,
    3749,
    3751,
    3773,
    3776,
    3780,
    3782,
    3782,
    3784,
    3790,
    3792,
    3801,
    3804,
    3807,
    3840,
    3840,
    3864,
    3865,
    3872,
    3881,
    3893,
    3893,
    3895,
    3895,
    3897,
    3897,
    3902,
    3911,
    3913,
    3948,
    3953,
    3972,
    3974,
    3991,
    3993,
    4028,
    4038,
    4038,
    4096,
    4169,
    4176,
    4253,
    4256,
    4293,
    4295,
    4295,
    4301,
    4301,
    4304,
    4346,
    4348,
    4680,
    4682,
    4685,
    4688,
    4694,
    4696,
    4696,
    4698,
    4701,
    4704,
    4744,
    4746,
    4749,
    4752,
    4784,
    4786,
    4789,
    4792,
    4798,
    4800,
    4800,
    4802,
    4805,
    4808,
    4822,
    4824,
    4880,
    4882,
    4885,
    4888,
    4954,
    4957,
    4959,
    4992,
    5007,
    5024,
    5109,
    5112,
    5117,
    5121,
    5740,
    5743,
    5759,
    5761,
    5786,
    5792,
    5866,
    5870,
    5880,
    5888,
    5909,
    5919,
    5940,
    5952,
    5971,
    5984,
    5996,
    5998,
    6e3,
    6002,
    6003,
    6016,
    6099,
    6103,
    6103,
    6108,
    6109,
    6112,
    6121,
    6155,
    6169,
    6176,
    6264,
    6272,
    6314,
    6320,
    6389,
    6400,
    6430,
    6432,
    6443,
    6448,
    6459,
    6470,
    6509,
    6512,
    6516,
    6528,
    6571,
    6576,
    6601,
    6608,
    6617,
    6656,
    6683,
    6688,
    6750,
    6752,
    6780,
    6783,
    6793,
    6800,
    6809,
    6823,
    6823,
    6832,
    6845,
    6847,
    6862,
    6912,
    6988,
    6992,
    7001,
    7019,
    7027,
    7040,
    7155,
    7168,
    7223,
    7232,
    7241,
    7245,
    7293,
    7296,
    7304,
    7312,
    7354,
    7357,
    7359,
    7376,
    7378,
    7380,
    7418,
    7424,
    7957,
    7960,
    7965,
    7968,
    8005,
    8008,
    8013,
    8016,
    8023,
    8025,
    8025,
    8027,
    8027,
    8029,
    8029,
    8031,
    8061,
    8064,
    8116,
    8118,
    8124,
    8126,
    8126,
    8130,
    8132,
    8134,
    8140,
    8144,
    8147,
    8150,
    8155,
    8160,
    8172,
    8178,
    8180,
    8182,
    8188,
    8203,
    8207,
    8234,
    8238,
    8255,
    8256,
    8276,
    8276,
    8288,
    8292,
    8294,
    8303,
    8305,
    8305,
    8319,
    8319,
    8336,
    8348,
    8400,
    8412,
    8417,
    8417,
    8421,
    8432,
    8450,
    8450,
    8455,
    8455,
    8458,
    8467,
    8469,
    8469,
    8473,
    8477,
    8484,
    8484,
    8486,
    8486,
    8488,
    8488,
    8490,
    8493,
    8495,
    8505,
    8508,
    8511,
    8517,
    8521,
    8526,
    8526,
    8544,
    8584,
    11264,
    11492,
    11499,
    11507,
    11520,
    11557,
    11559,
    11559,
    11565,
    11565,
    11568,
    11623,
    11631,
    11631,
    11647,
    11670,
    11680,
    11686,
    11688,
    11694,
    11696,
    11702,
    11704,
    11710,
    11712,
    11718,
    11720,
    11726,
    11728,
    11734,
    11736,
    11742,
    11744,
    11775,
    11823,
    11823,
    12293,
    12295,
    12321,
    12335,
    12337,
    12341,
    12344,
    12348,
    12353,
    12438,
    12441,
    12442,
    12445,
    12447,
    12449,
    12538,
    12540,
    12543,
    12549,
    12591,
    12593,
    12686,
    12704,
    12735,
    12784,
    12799,
    13312,
    19903,
    19968,
    42124,
    42192,
    42237,
    42240,
    42508,
    42512,
    42539,
    42560,
    42607,
    42612,
    42621,
    42623,
    42737,
    42775,
    42783,
    42786,
    42888,
    42891,
    42954,
    42960,
    42961,
    42963,
    42963,
    42965,
    42969,
    42994,
    43047,
    43052,
    43052,
    43072,
    43123,
    43136,
    43205,
    43216,
    43225,
    43232,
    43255,
    43259,
    43259,
    43261,
    43309,
    43312,
    43347,
    43360,
    43388,
    43392,
    43456,
    43471,
    43481,
    43488,
    43518,
    43520,
    43574,
    43584,
    43597,
    43600,
    43609,
    43616,
    43638,
    43642,
    43714,
    43739,
    43741,
    43744,
    43759,
    43762,
    43766,
    43777,
    43782,
    43785,
    43790,
    43793,
    43798,
    43808,
    43814,
    43816,
    43822,
    43824,
    43866,
    43868,
    43881,
    43888,
    44010,
    44012,
    44013,
    44016,
    44025,
    44032,
    55203,
    55216,
    55238,
    55243,
    55291,
    63744,
    64109,
    64112,
    64217,
    64256,
    64262,
    64275,
    64279,
    64285,
    64296,
    64298,
    64310,
    64312,
    64316,
    64318,
    64318,
    64320,
    64321,
    64323,
    64324,
    64326,
    64433,
    64467,
    64829,
    64848,
    64911,
    64914,
    64967,
    65008,
    65019,
    65024,
    65039,
    65056,
    65071,
    65075,
    65076,
    65101,
    65103,
    65136,
    65140,
    65142,
    65276,
    65279,
    65279,
    65296,
    65305,
    65313,
    65338,
    65343,
    65343,
    65345,
    65370,
    65382,
    65470,
    65474,
    65479,
    65482,
    65487,
    65490,
    65495,
    65498,
    65500,
    65529,
    65531,
    65536,
    65547,
    65549,
    65574,
    65576,
    65594,
    65596,
    65597,
    65599,
    65613,
    65616,
    65629,
    65664,
    65786,
    65856,
    65908,
    66045,
    66045,
    66176,
    66204,
    66208,
    66256,
    66272,
    66272,
    66304,
    66335,
    66349,
    66378,
    66384,
    66426,
    66432,
    66461,
    66464,
    66499,
    66504,
    66511,
    66513,
    66517,
    66560,
    66717,
    66720,
    66729,
    66736,
    66771,
    66776,
    66811,
    66816,
    66855,
    66864,
    66915,
    66928,
    66938,
    66940,
    66954,
    66956,
    66962,
    66964,
    66965,
    66967,
    66977,
    66979,
    66993,
    66995,
    67001,
    67003,
    67004,
    67072,
    67382,
    67392,
    67413,
    67424,
    67431,
    67456,
    67461,
    67463,
    67504,
    67506,
    67514,
    67584,
    67589,
    67592,
    67592,
    67594,
    67637,
    67639,
    67640,
    67644,
    67644,
    67647,
    67669,
    67680,
    67702,
    67712,
    67742,
    67808,
    67826,
    67828,
    67829,
    67840,
    67861,
    67872,
    67897,
    67968,
    68023,
    68030,
    68031,
    68096,
    68099,
    68101,
    68102,
    68108,
    68115,
    68117,
    68119,
    68121,
    68149,
    68152,
    68154,
    68159,
    68159,
    68192,
    68220,
    68224,
    68252,
    68288,
    68295,
    68297,
    68326,
    68352,
    68405,
    68416,
    68437,
    68448,
    68466,
    68480,
    68497,
    68608,
    68680,
    68736,
    68786,
    68800,
    68850,
    68864,
    68903,
    68912,
    68921,
    69248,
    69289,
    69291,
    69292,
    69296,
    69297,
    69373,
    69404,
    69415,
    69415,
    69424,
    69456,
    69488,
    69509,
    69552,
    69572,
    69600,
    69622,
    69632,
    69702,
    69734,
    69749,
    69759,
    69818,
    69821,
    69821,
    69826,
    69826,
    69837,
    69837,
    69840,
    69864,
    69872,
    69881,
    69888,
    69940,
    69942,
    69951,
    69956,
    69959,
    69968,
    70003,
    70006,
    70006,
    70016,
    70084,
    70089,
    70092,
    70094,
    70106,
    70108,
    70108,
    70144,
    70161,
    70163,
    70199,
    70206,
    70209,
    70272,
    70278,
    70280,
    70280,
    70282,
    70285,
    70287,
    70301,
    70303,
    70312,
    70320,
    70378,
    70384,
    70393,
    70400,
    70403,
    70405,
    70412,
    70415,
    70416,
    70419,
    70440,
    70442,
    70448,
    70450,
    70451,
    70453,
    70457,
    70459,
    70468,
    70471,
    70472,
    70475,
    70477,
    70480,
    70480,
    70487,
    70487,
    70493,
    70499,
    70502,
    70508,
    70512,
    70516,
    70656,
    70730,
    70736,
    70745,
    70750,
    70753,
    70784,
    70853,
    70855,
    70855,
    70864,
    70873,
    71040,
    71093,
    71096,
    71104,
    71128,
    71133,
    71168,
    71232,
    71236,
    71236,
    71248,
    71257,
    71296,
    71352,
    71360,
    71369,
    71424,
    71450,
    71453,
    71467,
    71472,
    71481,
    71488,
    71494,
    71680,
    71738,
    71840,
    71913,
    71935,
    71942,
    71945,
    71945,
    71948,
    71955,
    71957,
    71958,
    71960,
    71989,
    71991,
    71992,
    71995,
    72003,
    72016,
    72025,
    72096,
    72103,
    72106,
    72151,
    72154,
    72161,
    72163,
    72164,
    72192,
    72254,
    72263,
    72263,
    72272,
    72345,
    72349,
    72349,
    72368,
    72440,
    72704,
    72712,
    72714,
    72758,
    72760,
    72768,
    72784,
    72793,
    72818,
    72847,
    72850,
    72871,
    72873,
    72886,
    72960,
    72966,
    72968,
    72969,
    72971,
    73014,
    73018,
    73018,
    73020,
    73021,
    73023,
    73031,
    73040,
    73049,
    73056,
    73061,
    73063,
    73064,
    73066,
    73102,
    73104,
    73105,
    73107,
    73112,
    73120,
    73129,
    73440,
    73462,
    73472,
    73488,
    73490,
    73530,
    73534,
    73538,
    73552,
    73561,
    73648,
    73648,
    73728,
    74649,
    74752,
    74862,
    74880,
    75075,
    77712,
    77808,
    77824,
    78933,
    82944,
    83526,
    92160,
    92728,
    92736,
    92766,
    92768,
    92777,
    92784,
    92862,
    92864,
    92873,
    92880,
    92909,
    92912,
    92916,
    92928,
    92982,
    92992,
    92995,
    93008,
    93017,
    93027,
    93047,
    93053,
    93071,
    93760,
    93823,
    93952,
    94026,
    94031,
    94087,
    94095,
    94111,
    94176,
    94177,
    94179,
    94180,
    94192,
    94193,
    94208,
    100343,
    100352,
    101589,
    101632,
    101640,
    110576,
    110579,
    110581,
    110587,
    110589,
    110590,
    110592,
    110882,
    110898,
    110898,
    110928,
    110930,
    110933,
    110933,
    110948,
    110951,
    110960,
    111355,
    113664,
    113770,
    113776,
    113788,
    113792,
    113800,
    113808,
    113817,
    113821,
    113822,
    113824,
    113827,
    118528,
    118573,
    118576,
    118598,
    119141,
    119145,
    119149,
    119170,
    119173,
    119179,
    119210,
    119213,
    119362,
    119364,
    119808,
    119892,
    119894,
    119964,
    119966,
    119967,
    119970,
    119970,
    119973,
    119974,
    119977,
    119980,
    119982,
    119993,
    119995,
    119995,
    119997,
    120003,
    120005,
    120069,
    120071,
    120074,
    120077,
    120084,
    120086,
    120092,
    120094,
    120121,
    120123,
    120126,
    120128,
    120132,
    120134,
    120134,
    120138,
    120144,
    120146,
    120485,
    120488,
    120512,
    120514,
    120538,
    120540,
    120570,
    120572,
    120596,
    120598,
    120628,
    120630,
    120654,
    120656,
    120686,
    120688,
    120712,
    120714,
    120744,
    120746,
    120770,
    120772,
    120779,
    120782,
    120831,
    121344,
    121398,
    121403,
    121452,
    121461,
    121461,
    121476,
    121476,
    121499,
    121503,
    121505,
    121519,
    122624,
    122654,
    122661,
    122666,
    122880,
    122886,
    122888,
    122904,
    122907,
    122913,
    122915,
    122916,
    122918,
    122922,
    122928,
    122989,
    123023,
    123023,
    123136,
    123180,
    123184,
    123197,
    123200,
    123209,
    123214,
    123214,
    123536,
    123566,
    123584,
    123641,
    124112,
    124153,
    124896,
    124902,
    124904,
    124907,
    124909,
    124910,
    124912,
    124926,
    124928,
    125124,
    125136,
    125142,
    125184,
    125259,
    125264,
    125273,
    126464,
    126467,
    126469,
    126495,
    126497,
    126498,
    126500,
    126500,
    126503,
    126503,
    126505,
    126514,
    126516,
    126519,
    126521,
    126521,
    126523,
    126523,
    126530,
    126530,
    126535,
    126535,
    126537,
    126537,
    126539,
    126539,
    126541,
    126543,
    126545,
    126546,
    126548,
    126548,
    126551,
    126551,
    126553,
    126553,
    126555,
    126555,
    126557,
    126557,
    126559,
    126559,
    126561,
    126562,
    126564,
    126564,
    126567,
    126570,
    126572,
    126578,
    126580,
    126583,
    126585,
    126588,
    126590,
    126590,
    126592,
    126601,
    126603,
    126619,
    126625,
    126627,
    126629,
    126633,
    126635,
    126651,
    130032,
    130041,
    131072,
    173791,
    173824,
    177977,
    177984,
    178205,
    178208,
    183969,
    183984,
    191456,
    194560,
    195101,
    196608,
    201546,
    201552,
    205743,
    917505,
    917505,
    917536,
    917631,
    917760,
    917999,
    662,
    0,
    65,
    90,
    97,
    122,
    170,
    170,
    181,
    181,
    186,
    186,
    192,
    214,
    216,
    246,
    248,
    705,
    710,
    721,
    736,
    740,
    748,
    748,
    750,
    750,
    880,
    884,
    886,
    887,
    890,
    893,
    895,
    895,
    902,
    902,
    904,
    906,
    908,
    908,
    910,
    929,
    931,
    1013,
    1015,
    1153,
    1162,
    1327,
    1329,
    1366,
    1369,
    1369,
    1376,
    1416,
    1488,
    1514,
    1519,
    1522,
    1568,
    1610,
    1646,
    1647,
    1649,
    1747,
    1749,
    1749,
    1765,
    1766,
    1774,
    1775,
    1786,
    1788,
    1791,
    1791,
    1808,
    1808,
    1810,
    1839,
    1869,
    1957,
    1969,
    1969,
    1994,
    2026,
    2036,
    2037,
    2042,
    2042,
    2048,
    2069,
    2074,
    2074,
    2084,
    2084,
    2088,
    2088,
    2112,
    2136,
    2144,
    2154,
    2160,
    2183,
    2185,
    2190,
    2208,
    2249,
    2308,
    2361,
    2365,
    2365,
    2384,
    2384,
    2392,
    2401,
    2417,
    2432,
    2437,
    2444,
    2447,
    2448,
    2451,
    2472,
    2474,
    2480,
    2482,
    2482,
    2486,
    2489,
    2493,
    2493,
    2510,
    2510,
    2524,
    2525,
    2527,
    2529,
    2544,
    2545,
    2556,
    2556,
    2565,
    2570,
    2575,
    2576,
    2579,
    2600,
    2602,
    2608,
    2610,
    2611,
    2613,
    2614,
    2616,
    2617,
    2649,
    2652,
    2654,
    2654,
    2674,
    2676,
    2693,
    2701,
    2703,
    2705,
    2707,
    2728,
    2730,
    2736,
    2738,
    2739,
    2741,
    2745,
    2749,
    2749,
    2768,
    2768,
    2784,
    2785,
    2809,
    2809,
    2821,
    2828,
    2831,
    2832,
    2835,
    2856,
    2858,
    2864,
    2866,
    2867,
    2869,
    2873,
    2877,
    2877,
    2908,
    2909,
    2911,
    2913,
    2929,
    2929,
    2947,
    2947,
    2949,
    2954,
    2958,
    2960,
    2962,
    2965,
    2969,
    2970,
    2972,
    2972,
    2974,
    2975,
    2979,
    2980,
    2984,
    2986,
    2990,
    3001,
    3024,
    3024,
    3077,
    3084,
    3086,
    3088,
    3090,
    3112,
    3114,
    3129,
    3133,
    3133,
    3160,
    3162,
    3165,
    3165,
    3168,
    3169,
    3200,
    3200,
    3205,
    3212,
    3214,
    3216,
    3218,
    3240,
    3242,
    3251,
    3253,
    3257,
    3261,
    3261,
    3293,
    3294,
    3296,
    3297,
    3313,
    3314,
    3332,
    3340,
    3342,
    3344,
    3346,
    3386,
    3389,
    3389,
    3406,
    3406,
    3412,
    3414,
    3423,
    3425,
    3450,
    3455,
    3461,
    3478,
    3482,
    3505,
    3507,
    3515,
    3517,
    3517,
    3520,
    3526,
    3585,
    3632,
    3634,
    3635,
    3648,
    3654,
    3713,
    3714,
    3716,
    3716,
    3718,
    3722,
    3724,
    3747,
    3749,
    3749,
    3751,
    3760,
    3762,
    3763,
    3773,
    3773,
    3776,
    3780,
    3782,
    3782,
    3804,
    3807,
    3840,
    3840,
    3904,
    3911,
    3913,
    3948,
    3976,
    3980,
    4096,
    4138,
    4159,
    4159,
    4176,
    4181,
    4186,
    4189,
    4193,
    4193,
    4197,
    4198,
    4206,
    4208,
    4213,
    4225,
    4238,
    4238,
    4256,
    4293,
    4295,
    4295,
    4301,
    4301,
    4304,
    4346,
    4348,
    4680,
    4682,
    4685,
    4688,
    4694,
    4696,
    4696,
    4698,
    4701,
    4704,
    4744,
    4746,
    4749,
    4752,
    4784,
    4786,
    4789,
    4792,
    4798,
    4800,
    4800,
    4802,
    4805,
    4808,
    4822,
    4824,
    4880,
    4882,
    4885,
    4888,
    4954,
    4992,
    5007,
    5024,
    5109,
    5112,
    5117,
    5121,
    5740,
    5743,
    5759,
    5761,
    5786,
    5792,
    5866,
    5870,
    5880,
    5888,
    5905,
    5919,
    5937,
    5952,
    5969,
    5984,
    5996,
    5998,
    6e3,
    6016,
    6067,
    6103,
    6103,
    6108,
    6108,
    6176,
    6264,
    6272,
    6276,
    6279,
    6312,
    6314,
    6314,
    6320,
    6389,
    6400,
    6430,
    6480,
    6509,
    6512,
    6516,
    6528,
    6571,
    6576,
    6601,
    6656,
    6678,
    6688,
    6740,
    6823,
    6823,
    6917,
    6963,
    6981,
    6988,
    7043,
    7072,
    7086,
    7087,
    7098,
    7141,
    7168,
    7203,
    7245,
    7247,
    7258,
    7293,
    7296,
    7304,
    7312,
    7354,
    7357,
    7359,
    7401,
    7404,
    7406,
    7411,
    7413,
    7414,
    7418,
    7418,
    7424,
    7615,
    7680,
    7957,
    7960,
    7965,
    7968,
    8005,
    8008,
    8013,
    8016,
    8023,
    8025,
    8025,
    8027,
    8027,
    8029,
    8029,
    8031,
    8061,
    8064,
    8116,
    8118,
    8124,
    8126,
    8126,
    8130,
    8132,
    8134,
    8140,
    8144,
    8147,
    8150,
    8155,
    8160,
    8172,
    8178,
    8180,
    8182,
    8188,
    8305,
    8305,
    8319,
    8319,
    8336,
    8348,
    8450,
    8450,
    8455,
    8455,
    8458,
    8467,
    8469,
    8469,
    8473,
    8477,
    8484,
    8484,
    8486,
    8486,
    8488,
    8488,
    8490,
    8493,
    8495,
    8505,
    8508,
    8511,
    8517,
    8521,
    8526,
    8526,
    8544,
    8584,
    11264,
    11492,
    11499,
    11502,
    11506,
    11507,
    11520,
    11557,
    11559,
    11559,
    11565,
    11565,
    11568,
    11623,
    11631,
    11631,
    11648,
    11670,
    11680,
    11686,
    11688,
    11694,
    11696,
    11702,
    11704,
    11710,
    11712,
    11718,
    11720,
    11726,
    11728,
    11734,
    11736,
    11742,
    11823,
    11823,
    12293,
    12295,
    12321,
    12329,
    12337,
    12341,
    12344,
    12348,
    12353,
    12438,
    12445,
    12447,
    12449,
    12538,
    12540,
    12543,
    12549,
    12591,
    12593,
    12686,
    12704,
    12735,
    12784,
    12799,
    13312,
    19903,
    19968,
    42124,
    42192,
    42237,
    42240,
    42508,
    42512,
    42527,
    42538,
    42539,
    42560,
    42606,
    42623,
    42653,
    42656,
    42735,
    42775,
    42783,
    42786,
    42888,
    42891,
    42954,
    42960,
    42961,
    42963,
    42963,
    42965,
    42969,
    42994,
    43009,
    43011,
    43013,
    43015,
    43018,
    43020,
    43042,
    43072,
    43123,
    43138,
    43187,
    43250,
    43255,
    43259,
    43259,
    43261,
    43262,
    43274,
    43301,
    43312,
    43334,
    43360,
    43388,
    43396,
    43442,
    43471,
    43471,
    43488,
    43492,
    43494,
    43503,
    43514,
    43518,
    43520,
    43560,
    43584,
    43586,
    43588,
    43595,
    43616,
    43638,
    43642,
    43642,
    43646,
    43695,
    43697,
    43697,
    43701,
    43702,
    43705,
    43709,
    43712,
    43712,
    43714,
    43714,
    43739,
    43741,
    43744,
    43754,
    43762,
    43764,
    43777,
    43782,
    43785,
    43790,
    43793,
    43798,
    43808,
    43814,
    43816,
    43822,
    43824,
    43866,
    43868,
    43881,
    43888,
    44002,
    44032,
    55203,
    55216,
    55238,
    55243,
    55291,
    63744,
    64109,
    64112,
    64217,
    64256,
    64262,
    64275,
    64279,
    64285,
    64285,
    64287,
    64296,
    64298,
    64310,
    64312,
    64316,
    64318,
    64318,
    64320,
    64321,
    64323,
    64324,
    64326,
    64433,
    64467,
    64829,
    64848,
    64911,
    64914,
    64967,
    65008,
    65019,
    65136,
    65140,
    65142,
    65276,
    65313,
    65338,
    65345,
    65370,
    65382,
    65470,
    65474,
    65479,
    65482,
    65487,
    65490,
    65495,
    65498,
    65500,
    65536,
    65547,
    65549,
    65574,
    65576,
    65594,
    65596,
    65597,
    65599,
    65613,
    65616,
    65629,
    65664,
    65786,
    65856,
    65908,
    66176,
    66204,
    66208,
    66256,
    66304,
    66335,
    66349,
    66378,
    66384,
    66421,
    66432,
    66461,
    66464,
    66499,
    66504,
    66511,
    66513,
    66517,
    66560,
    66717,
    66736,
    66771,
    66776,
    66811,
    66816,
    66855,
    66864,
    66915,
    66928,
    66938,
    66940,
    66954,
    66956,
    66962,
    66964,
    66965,
    66967,
    66977,
    66979,
    66993,
    66995,
    67001,
    67003,
    67004,
    67072,
    67382,
    67392,
    67413,
    67424,
    67431,
    67456,
    67461,
    67463,
    67504,
    67506,
    67514,
    67584,
    67589,
    67592,
    67592,
    67594,
    67637,
    67639,
    67640,
    67644,
    67644,
    67647,
    67669,
    67680,
    67702,
    67712,
    67742,
    67808,
    67826,
    67828,
    67829,
    67840,
    67861,
    67872,
    67897,
    67968,
    68023,
    68030,
    68031,
    68096,
    68096,
    68112,
    68115,
    68117,
    68119,
    68121,
    68149,
    68192,
    68220,
    68224,
    68252,
    68288,
    68295,
    68297,
    68324,
    68352,
    68405,
    68416,
    68437,
    68448,
    68466,
    68480,
    68497,
    68608,
    68680,
    68736,
    68786,
    68800,
    68850,
    68864,
    68899,
    69248,
    69289,
    69296,
    69297,
    69376,
    69404,
    69415,
    69415,
    69424,
    69445,
    69488,
    69505,
    69552,
    69572,
    69600,
    69622,
    69635,
    69687,
    69745,
    69746,
    69749,
    69749,
    69763,
    69807,
    69840,
    69864,
    69891,
    69926,
    69956,
    69956,
    69959,
    69959,
    69968,
    70002,
    70006,
    70006,
    70019,
    70066,
    70081,
    70084,
    70106,
    70106,
    70108,
    70108,
    70144,
    70161,
    70163,
    70187,
    70207,
    70208,
    70272,
    70278,
    70280,
    70280,
    70282,
    70285,
    70287,
    70301,
    70303,
    70312,
    70320,
    70366,
    70405,
    70412,
    70415,
    70416,
    70419,
    70440,
    70442,
    70448,
    70450,
    70451,
    70453,
    70457,
    70461,
    70461,
    70480,
    70480,
    70493,
    70497,
    70656,
    70708,
    70727,
    70730,
    70751,
    70753,
    70784,
    70831,
    70852,
    70853,
    70855,
    70855,
    71040,
    71086,
    71128,
    71131,
    71168,
    71215,
    71236,
    71236,
    71296,
    71338,
    71352,
    71352,
    71424,
    71450,
    71488,
    71494,
    71680,
    71723,
    71840,
    71903,
    71935,
    71942,
    71945,
    71945,
    71948,
    71955,
    71957,
    71958,
    71960,
    71983,
    71999,
    71999,
    72001,
    72001,
    72096,
    72103,
    72106,
    72144,
    72161,
    72161,
    72163,
    72163,
    72192,
    72192,
    72203,
    72242,
    72250,
    72250,
    72272,
    72272,
    72284,
    72329,
    72349,
    72349,
    72368,
    72440,
    72704,
    72712,
    72714,
    72750,
    72768,
    72768,
    72818,
    72847,
    72960,
    72966,
    72968,
    72969,
    72971,
    73008,
    73030,
    73030,
    73056,
    73061,
    73063,
    73064,
    73066,
    73097,
    73112,
    73112,
    73440,
    73458,
    73474,
    73474,
    73476,
    73488,
    73490,
    73523,
    73648,
    73648,
    73728,
    74649,
    74752,
    74862,
    74880,
    75075,
    77712,
    77808,
    77824,
    78895,
    78913,
    78918,
    82944,
    83526,
    92160,
    92728,
    92736,
    92766,
    92784,
    92862,
    92880,
    92909,
    92928,
    92975,
    92992,
    92995,
    93027,
    93047,
    93053,
    93071,
    93760,
    93823,
    93952,
    94026,
    94032,
    94032,
    94099,
    94111,
    94176,
    94177,
    94179,
    94179,
    94208,
    100343,
    100352,
    101589,
    101632,
    101640,
    110576,
    110579,
    110581,
    110587,
    110589,
    110590,
    110592,
    110882,
    110898,
    110898,
    110928,
    110930,
    110933,
    110933,
    110948,
    110951,
    110960,
    111355,
    113664,
    113770,
    113776,
    113788,
    113792,
    113800,
    113808,
    113817,
    119808,
    119892,
    119894,
    119964,
    119966,
    119967,
    119970,
    119970,
    119973,
    119974,
    119977,
    119980,
    119982,
    119993,
    119995,
    119995,
    119997,
    120003,
    120005,
    120069,
    120071,
    120074,
    120077,
    120084,
    120086,
    120092,
    120094,
    120121,
    120123,
    120126,
    120128,
    120132,
    120134,
    120134,
    120138,
    120144,
    120146,
    120485,
    120488,
    120512,
    120514,
    120538,
    120540,
    120570,
    120572,
    120596,
    120598,
    120628,
    120630,
    120654,
    120656,
    120686,
    120688,
    120712,
    120714,
    120744,
    120746,
    120770,
    120772,
    120779,
    122624,
    122654,
    122661,
    122666,
    122928,
    122989,
    123136,
    123180,
    123191,
    123197,
    123214,
    123214,
    123536,
    123565,
    123584,
    123627,
    124112,
    124139,
    124896,
    124902,
    124904,
    124907,
    124909,
    124910,
    124912,
    124926,
    124928,
    125124,
    125184,
    125251,
    125259,
    125259,
    126464,
    126467,
    126469,
    126495,
    126497,
    126498,
    126500,
    126500,
    126503,
    126503,
    126505,
    126514,
    126516,
    126519,
    126521,
    126521,
    126523,
    126523,
    126530,
    126530,
    126535,
    126535,
    126537,
    126537,
    126539,
    126539,
    126541,
    126543,
    126545,
    126546,
    126548,
    126548,
    126551,
    126551,
    126553,
    126553,
    126555,
    126555,
    126557,
    126557,
    126559,
    126559,
    126561,
    126562,
    126564,
    126564,
    126567,
    126570,
    126572,
    126578,
    126580,
    126583,
    126585,
    126588,
    126590,
    126590,
    126592,
    126601,
    126603,
    126619,
    126625,
    126627,
    126629,
    126633,
    126635,
    126651,
    131072,
    173791,
    173824,
    177977,
    177984,
    178205,
    178208,
    183969,
    183984,
    191456,
    194560,
    195101,
    196608,
    201546,
    201552,
    205743,
    47,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    3,
    1,
    0,
    0,
    0,
    0,
    5,
    1,
    0,
    0,
    0,
    0,
    7,
    1,
    0,
    0,
    0,
    0,
    9,
    1,
    0,
    0,
    0,
    0,
    15,
    1,
    0,
    0,
    0,
    1,
    17,
    1,
    0,
    0,
    0,
    3,
    20,
    1,
    0,
    0,
    0,
    5,
    22,
    1,
    0,
    0,
    0,
    7,
    24,
    1,
    0,
    0,
    0,
    9,
    26,
    1,
    0,
    0,
    0,
    11,
    35,
    1,
    0,
    0,
    0,
    13,
    37,
    1,
    0,
    0,
    0,
    15,
    39,
    1,
    0,
    0,
    0,
    17,
    18,
    5,
    47,
    0,
    0,
    18,
    19,
    5,
    47,
    0,
    0,
    19,
    2,
    1,
    0,
    0,
    0,
    20,
    21,
    5,
    47,
    0,
    0,
    21,
    4,
    1,
    0,
    0,
    0,
    22,
    23,
    5,
    42,
    0,
    0,
    23,
    6,
    1,
    0,
    0,
    0,
    24,
    25,
    5,
    33,
    0,
    0,
    25,
    8,
    1,
    0,
    0,
    0,
    26,
    30,
    3,
    13,
    6,
    0,
    27,
    29,
    3,
    11,
    5,
    0,
    28,
    27,
    1,
    0,
    0,
    0,
    29,
    32,
    1,
    0,
    0,
    0,
    30,
    28,
    1,
    0,
    0,
    0,
    30,
    31,
    1,
    0,
    0,
    0,
    31,
    33,
    1,
    0,
    0,
    0,
    32,
    30,
    1,
    0,
    0,
    0,
    33,
    34,
    6,
    4,
    0,
    0,
    34,
    10,
    1,
    0,
    0,
    0,
    35,
    36,
    7,
    0,
    0,
    0,
    36,
    12,
    1,
    0,
    0,
    0,
    37,
    38,
    7,
    1,
    0,
    0,
    38,
    14,
    1,
    0,
    0,
    0,
    39,
    43,
    5,
    39,
    0,
    0,
    40,
    42,
    9,
    0,
    0,
    0,
    41,
    40,
    1,
    0,
    0,
    0,
    42,
    45,
    1,
    0,
    0,
    0,
    43,
    44,
    1,
    0,
    0,
    0,
    43,
    41,
    1,
    0,
    0,
    0,
    44,
    46,
    1,
    0,
    0,
    0,
    45,
    43,
    1,
    0,
    0,
    0,
    46,
    47,
    5,
    39,
    0,
    0,
    47,
    16,
    1,
    0,
    0,
    0,
    3,
    0,
    30,
    43,
    1,
    1,
    4,
    0
  ];
  static __ATN;
  static get _ATN() {
    if (!_XPathLexer.__ATN) {
      _XPathLexer.__ATN = new ATNDeserializer().deserialize(_XPathLexer._serializedATN);
    }
    return _XPathLexer.__ATN;
  }
  static vocabulary = new Vocabulary(_XPathLexer.literalNames, _XPathLexer.symbolicNames, []);
  get vocabulary() {
    return _XPathLexer.vocabulary;
  }
  static decisionsToDFA = _XPathLexer._ATN.decisionToState.map((ds, index) => {
    return new DFA(ds, index);
  });
};

// src/tree/xpath/XPathLexerErrorListener.ts
var XPathLexerErrorListener = class extends BaseErrorListener {
  static {
    __name(this, "XPathLexerErrorListener");
  }
  syntaxError(_recognizer, _offendingSymbol, _line, _charPositionInLine, _msg, _e) {
  }
};

// src/tree/xpath/XPathElement.ts
var XPathElement = class {
  static {
    __name(this, "XPathElement");
  }
  invert;
  nodeName;
  /**
   * Construct element like `/ID` or `ID` or `/*` etc... `nodeName` is undefined if just node
   *
   * @param nodeName The name of the node; may be undefined for any node.
   */
  constructor(nodeName) {
    this.nodeName = nodeName;
    this.invert = false;
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathRuleAnywhereElement.ts
var XPathRuleAnywhereElement = class extends XPathElement {
  static {
    __name(this, "XPathRuleAnywhereElement");
  }
  ruleIndex;
  constructor(ruleName, ruleIndex) {
    super(ruleName);
    this.ruleIndex = ruleIndex;
  }
  evaluate(t) {
    return Trees.findAllRuleNodes(t, this.ruleIndex);
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathRuleAnywhereElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathRuleElement.ts
var XPathRuleElement = class extends XPathElement {
  static {
    __name(this, "XPathRuleElement");
  }
  ruleIndex;
  constructor(ruleName, ruleIndex) {
    super(ruleName);
    this.ruleIndex = ruleIndex;
  }
  evaluate(t) {
    const nodes = [];
    for (const c of Trees.getChildren(t)) {
      if (c instanceof ParserRuleContext) {
        if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
          nodes.push(c);
        }
      }
    }
    return nodes;
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathRuleElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathTokenAnywhereElement.ts
var XPathTokenAnywhereElement = class extends XPathElement {
  static {
    __name(this, "XPathTokenAnywhereElement");
  }
  tokenType;
  constructor(tokenName, tokenType) {
    super(tokenName);
    this.tokenType = tokenType;
  }
  evaluate(t) {
    return Trees.findAllTokenNodes(t, this.tokenType);
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathTokenAnywhereElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathTokenElement.ts
var XPathTokenElement = class extends XPathElement {
  static {
    __name(this, "XPathTokenElement");
  }
  tokenType;
  constructor(tokenName, tokenType) {
    super(tokenName);
    this.tokenType = tokenType;
  }
  evaluate(t) {
    const nodes = [];
    for (const c of Trees.getChildren(t)) {
      if (c instanceof TerminalNode && c.symbol) {
        if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
          nodes.push(c);
        }
      }
    }
    return nodes;
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathTokenElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathWildcardAnywhereElement.ts
var XPathWildcardAnywhereElement = class extends XPathElement {
  static {
    __name(this, "XPathWildcardAnywhereElement");
  }
  constructor() {
    super(XPath.WILDCARD);
  }
  evaluate(t) {
    if (this.invert) {
      return [];
    }
    return Trees.descendants(t);
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathWildcardAnywhereElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPathWildcardElement.ts
var XPathWildcardElement = class extends XPathElement {
  static {
    __name(this, "XPathWildcardElement");
  }
  constructor() {
    super(XPath.WILDCARD);
  }
  evaluate(t) {
    const kids = [];
    if (this.invert) {
      return kids;
    }
    for (const c of Trees.getChildren(t)) {
      kids.push(c);
    }
    return kids;
  }
  toString() {
    const inv = this.invert ? "!" : "";
    return "XPathWildcardElement[" + inv + this.nodeName + "]";
  }
};

// src/tree/xpath/XPath.ts
var XPath = class _XPath {
  static {
    __name(this, "XPath");
  }
  static WILDCARD = "*";
  // word not operator/separator
  static NOT = "!";
  // word for invert operator
  path;
  elements;
  parser;
  constructor(parser, path) {
    this.parser = parser;
    this.path = path;
    this.elements = this.split(path);
  }
  static findAll(tree, xpath, parser) {
    const p = new _XPath(parser, xpath);
    return p.evaluate(tree);
  }
  // TODO: check for invalid token/rule names, bad syntax
  split(path) {
    const lexer = new XPathLexer(CharStream.fromString(path));
    lexer.recover = (e) => {
      throw e;
    };
    lexer.removeErrorListeners();
    lexer.addErrorListener(new XPathLexerErrorListener());
    const tokenStream = new CommonTokenStream(lexer);
    try {
      tokenStream.fill();
    } catch (e) {
      if (e instanceof LexerNoViableAltException) {
        const pos = lexer.column;
        const msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
        throw new RangeError(msg);
      }
      throw e;
    }
    const tokens = tokenStream.getTokens();
    const elements = [];
    const n2 = tokens.length;
    let i = 0;
    loop:
      while (i < n2) {
        const el = tokens[i];
        let next;
        switch (el.type) {
          case XPathLexer.ROOT:
          case XPathLexer.ANYWHERE:
            const anywhere = el.type === XPathLexer.ANYWHERE;
            i++;
            next = tokens[i];
            const invert = next.type === XPathLexer.BANG;
            if (invert) {
              i++;
              next = tokens[i];
            }
            const pathElement = this.getXPathElement(next, anywhere);
            pathElement.invert = invert;
            elements.push(pathElement);
            i++;
            break;
          case XPathLexer.TOKEN_REF:
          case XPathLexer.RULE_REF:
          case XPathLexer.WILDCARD:
            elements.push(this.getXPathElement(el, false));
            ++i;
            break;
          case Token.EOF:
            break loop;
          default:
            throw new Error("Unknown path element " + el);
        }
      }
    return elements;
  }
  /**
   * Return a list of all nodes starting at `t` as root that satisfy the
   * path. The root `/` is relative to the node passed to {@link evaluate}.
   */
  evaluate(t) {
    const dummyRoot = new ParserRuleContext(null);
    dummyRoot.addChild(t);
    let work = /* @__PURE__ */ new Set([dummyRoot]);
    let i = 0;
    while (i < this.elements.length) {
      const next = /* @__PURE__ */ new Set();
      for (const node of work) {
        if (node.getChildCount() > 0) {
          const matching = this.elements[i].evaluate(node);
          matching.forEach((tree) => {
            next.add(tree);
          }, next);
        }
      }
      i++;
      work = next;
    }
    return work;
  }
  /**
   * Convert word like `*` or `ID` or `expr` to a path
   * element. `anywhere` is `true` if `//` precedes the
   * word.
   */
  getXPathElement(wordToken, anywhere) {
    if (wordToken.type === Token.EOF) {
      throw new Error("Missing path element at end of path");
    }
    const word = wordToken.text;
    if (word == null) {
      throw new Error("Expected wordToken to have text content.");
    }
    const ttype = this.parser.getTokenType(word);
    const ruleIndex = this.parser.getRuleIndex(word);
    switch (wordToken.type) {
      case XPathLexer.WILDCARD:
        return anywhere ? new XPathWildcardAnywhereElement() : new XPathWildcardElement();
      case XPathLexer.TOKEN_REF:
      case XPathLexer.STRING:
        if (ttype === Token.INVALID_TYPE) {
          throw new Error(word + " at index " + wordToken.start + " isn't a valid token name");
        }
        return anywhere ? new XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement(word, ttype);
      default:
        if (ruleIndex === -1) {
          throw new Error(word + " at index " + wordToken.start + " isn't a valid rule name");
        }
        return anywhere ? new XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement(word, ruleIndex);
    }
  }
};

// src/tree/pattern/Chunk.ts
var Chunk = class {
  static {
    __name(this, "Chunk");
  }
};

// src/tree/pattern/ParseTreeMatch.ts
var ParseTreeMatch = class {
  static {
    __name(this, "ParseTreeMatch");
  }
  /**
   * This is the backing field for {@link #getTree()}.
   */
  tree;
  /**
   * This is the backing field for {@link #getPattern()}.
   */
  pattern;
  /**
   * This is the backing field for {@link #getLabels()}.
   */
  labels;
  /**
   * This is the backing field for {@link #getMismatchedNode()}.
   */
  mismatchedNode;
  /**
   * Constructs a new instance of {@link ParseTreeMatch} from the specified
   * parse tree and pattern.
   *
   * @param tree The parse tree to match against the pattern.
   * @param pattern The parse tree pattern.
   * @param labels A mapping from label names to collections of
   * {@link ParseTree} objects located by the tree pattern matching process.
   * @param mismatchedNode The first node which failed to match the tree
   * pattern during the matching process.
   */
  constructor(tree, pattern, labels, mismatchedNode) {
    this.tree = tree;
    this.pattern = pattern;
    this.labels = labels;
    this.mismatchedNode = mismatchedNode;
  }
  /**
   * Get the last node associated with a specific `label`.
   *
   * For example, for pattern `<id:ID>`, `get("id")` returns the
   * node matched for that `ID`. If more than one node
   * matched the specified label, only the last is returned. If there is
   * no node associated with the label, this returns `null`.
   *
   * Pattern tags like `<ID>` and `<expr>` without labels are
   * considered to be labeled with `ID` and `expr`, respectively.
   *
   * @param label The label to check.
   *
   * @returns The last {@link ParseTree} to match a tag with the specified
   * label, or `null` if no parse tree matched a tag with the label.
   */
  get(label) {
    const parseTrees = this.labels.get(label);
    if (!parseTrees || parseTrees.length === 0) {
      return null;
    }
    return parseTrees[parseTrees.length - 1];
  }
  /**
   * Return all nodes matching a rule or token tag with the specified label.
   *
   * If the `label` is the name of a parser rule or token in the
   * grammar, the resulting list will contain both the parse trees matching
   * rule or tags explicitly labeled with the label and the complete set of
   * parse trees matching the labeled and unlabeled tags in the pattern for
   * the parser rule or token. For example, if `label` is `"foo"`,
   * the result will contain *all* of the following.
   *
   * - Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
   * `<foo:AnyTokenName>`.
   * - Parse tree nodes matching tags of the form `<anyLabel:foo>`.
   * - Parse tree nodes matching tags of the form `<foo>`.
   *
   * @param label The label.
   *
   * @returns A collection of all {@link ParseTree} nodes matching tags with
   * the specified `label`. If no nodes matched the label, an empty list
   * is returned.
   */
  getAll(label) {
    const nodes = this.labels.get(label);
    return nodes ?? [];
  }
  /**
   * Return a mapping from label -> [list of nodes].
   *
   * The map includes special entries corresponding to the names of rules and
   * tokens referenced in tags in the original pattern. For additional
   * information, see the description of {@link getAll(String)}.
   *
   * @returns A mapping from labels to parse tree nodes. If the parse tree
   * pattern did not contain any rule or token tags, this map will be empty.
   */
  getLabels() {
    return this.labels;
  }
  /**
   * Get the node at which we first detected a mismatch.
   *
   * @returns the node at which we first detected a mismatch, or `null`
   * if the match was successful.
   */
  getMismatchedNode() {
    return this.mismatchedNode;
  }
  /**
   * Gets a value indicating whether the match operation succeeded.
   *
   * @returns `true` if the match operation succeeded; otherwise, `false`.
   */
  succeeded() {
    return !this.mismatchedNode;
  }
  /**
   * Get the tree pattern we are matching against.
   *
   * @returns The tree pattern we are matching against.
   */
  getPattern() {
    return this.pattern;
  }
  /**
   * Get the parse tree we are trying to match to a pattern.
   *
   * @returns The {@link ParseTree} we are trying to match to a pattern.
   */
  getTree() {
    return this.tree;
  }
  toString() {
    return `Match ${this.succeeded() ? "succeeded" : "failed"}; found ${this.getLabels().size} labels`;
  }
};

// src/tree/pattern/ParseTreePattern.ts
var ParseTreePattern = class {
  static {
    __name(this, "ParseTreePattern");
  }
  /**
   * This is the backing field for {@link #getPatternRuleIndex()}.
   */
  patternRuleIndex;
  /**
   * This is the backing field for {@link #getPattern()}.
   */
  pattern;
  /**
   * This is the backing field for {@link #getPatternTree()}.
   */
  patternTree;
  /**
   * This is the backing field for {@link #getMatcher()}.
   */
  matcher;
  /**
   * Construct a new instance of the {@link ParseTreePattern} class.
   *
   * @param matcher The {@link ParseTreePatternMatcher} which created this
   * tree pattern.
   * @param pattern The tree pattern in concrete syntax form.
   * @param patternRuleIndex The parser rule which serves as the root of the
   * tree pattern.
   * @param patternTree The tree pattern in {@link ParseTree} form.
   */
  constructor(matcher, pattern, patternRuleIndex, patternTree) {
    this.matcher = matcher;
    this.patternRuleIndex = patternRuleIndex;
    this.pattern = pattern;
    this.patternTree = patternTree;
  }
  /**
   * Match a specific parse tree against this tree pattern.
   *
   * @param tree The parse tree to match against this tree pattern.
   * @returns A {@link ParseTreeMatch} object describing the result of the
   * match operation. The {@link ParseTreeMatch#succeeded()} method can be
   * used to determine whether or not the match was successful.
   */
  match(tree) {
    return this.matcher.match(tree, this);
  }
  /**
   * Determine whether or not a parse tree matches this tree pattern.
   *
   * @param tree The parse tree to match against this tree pattern.
   * @returns `true` if `tree` is a match for the current tree
   * pattern; otherwise, `false`.
   */
  matches(tree) {
    return this.matcher.match(tree, this).succeeded();
  }
  /**
   * Find all nodes using XPath and then try to match those subtrees against
   * this tree pattern.
   *
   * @param tree The {@link ParseTree} to match against this pattern.
   * @param xpath An expression matching the nodes
   *
   * @returns A collection of {@link ParseTreeMatch} objects describing the
   * successful matches. Unsuccessful matches are omitted from the result,
   * regardless of the reason for the failure.
   */
  findAll(tree, xpath) {
    const subtrees = XPath.findAll(tree, xpath, this.matcher.getParser());
    const matches = new Array();
    for (const t of subtrees) {
      const match = this.match(t);
      if (match.succeeded()) {
        matches.push(match);
      }
    }
    return matches;
  }
  /**
   * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
   *
   * @returns The {@link ParseTreePatternMatcher} which created this tree
   * pattern.
   */
  getMatcher() {
    return this.matcher;
  }
  /**
   * Get the tree pattern in concrete syntax form.
   *
   * @returns The tree pattern in concrete syntax form.
   */
  getPattern() {
    return this.pattern;
  }
  /**
   * Get the parser rule which serves as the outermost rule for the tree
   * pattern.
   *
   * @returns The parser rule which serves as the outermost rule for the tree
   * pattern.
   */
  getPatternRuleIndex() {
    return this.patternRuleIndex;
  }
  /**
   * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
   * the pattern are present in the parse tree as terminal nodes with a symbol
   * of type {@link RuleTagToken} or {@link TokenTagToken}.
   *
   * @returns The tree pattern as a {@link ParseTree}.
   */
  getPatternTree() {
    return this.patternTree;
  }
};

// src/InputMismatchException.ts
var InputMismatchException = class extends RecognitionException {
  static {
    __name(this, "InputMismatchException");
  }
  constructor(recognizer) {
    super({ message: "", recognizer, input: recognizer.inputStream, ctx: recognizer.context });
    this.offendingToken = recognizer.getCurrentToken();
  }
};

// src/FailedPredicateException.ts
var FailedPredicateException = class extends RecognitionException {
  static {
    __name(this, "FailedPredicateException");
  }
  ruleIndex = 0;
  predicateIndex = 0;
  predicate;
  constructor(recognizer, predicate, message = null) {
    super({
      message: formatMessage(predicate ?? "no predicate", message ?? null),
      recognizer,
      input: recognizer.inputStream,
      ctx: recognizer.context
    });
    const s = recognizer.atn.states[recognizer.state];
    const trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
      this.ruleIndex = trans.ruleIndex;
      this.predicateIndex = trans.predIndex;
    } else {
      this.ruleIndex = 0;
      this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
  }
};
var formatMessage = /* @__PURE__ */ __name((predicate, message) => {
  if (message !== null) {
    return message;
  }
  return "failed predicate: {" + predicate + "}?";
}, "formatMessage");

// src/DefaultErrorStrategy.ts
var DefaultErrorStrategy = class {
  static {
    __name(this, "DefaultErrorStrategy");
  }
  /**
   * Indicates whether the error strategy is currently "recovering from an
   * error". This is used to suppress reporting multiple error messages while
   * attempting to recover from a detected syntax error.
   *
   * @see #inErrorRecoveryMode
   */
  errorRecoveryMode = false;
  /**
   * The index into the input stream where the last error occurred.
   * 	This is used to prevent infinite loops where an error is found
   *  but no token is consumed during recovery...another error is found,
   *  ad nauseam.  This is a failsafe mechanism to guarantee that at least
   *  one token/tree node is consumed for two errors.
   */
  lastErrorIndex = -1;
  lastErrorStates = new IntervalSet();
  /**
   * This field is used to propagate information about the lookahead following
   * the previous match. Since prediction prefers completing the current rule
   * to error recovery efforts, error reporting may occur later than the
   * original point where it was discoverable. The original context is used to
   * compute the true expected sets as though the reporting occurred as early
   * as possible.
   */
  nextTokensContext = null;
  nextTokenState = 0;
  /**
   * The default implementation simply calls {@link endErrorCondition} to
   * ensure that the handler is not in error recovery mode.
   */
  reset(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * This method is called to enter error recovery mode when a recognition
   * exception is reported.
   *
   * @param _recognizer the parser instance
   */
  beginErrorCondition(_recognizer) {
    this.errorRecoveryMode = true;
  }
  inErrorRecoveryMode(_recognizer) {
    return this.errorRecoveryMode;
  }
  /**
   * This method is called to leave error recovery mode after recovering from
   * a recognition exception.
   */
  endErrorCondition(_recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = new IntervalSet();
    this.lastErrorIndex = -1;
  }
  /**
   * The default implementation simply calls {@link endErrorCondition}.
   */
  reportMatch(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * The default implementation returns immediately if the handler is already
   * in error recovery mode. Otherwise, it calls {@link beginErrorCondition}
   * and dispatches the reporting task based on the runtime type of `e`
   * according to the following table.
   *
   * - {@link NoViableAltException}: Dispatches the call to {@link reportNoViableAlternative}
   * - {@link InputMismatchException}: Dispatches the call to {@link reportInputMismatch}
   * - {@link FailedPredicateException}: Dispatches the call to {@link reportFailedPredicate}
   * - All other types: calls {@link Parser.notifyErrorListeners} to report the exception
   */
  reportError(recognizer, e) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    if (e instanceof NoViableAltException) {
      this.reportNoViableAlternative(recognizer, e);
    } else if (e instanceof InputMismatchException) {
      this.reportInputMismatch(recognizer, e);
    } else if (e instanceof FailedPredicateException) {
      this.reportFailedPredicate(recognizer, e);
    } else {
      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
    }
  }
  /**
   * The default implementation resynchronizes the parser by consuming tokens
   * until we find one in the resynchronization set--loosely the set of tokens
   * that can follow the current rule.
   *
   */
  recover(recognizer, _e) {
    if (this.lastErrorIndex === recognizer.inputStream?.index && this.lastErrorStates.contains(recognizer.state)) {
      recognizer.consume();
    }
    this.lastErrorIndex = recognizer.inputStream?.index ?? 0;
    this.lastErrorStates.addOne(recognizer.state);
    const followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
  }
  /**
   * The default implementation of {@link ANTLRErrorStrategy.sync} makes sure
   * that the current lookahead symbol is consistent with what were expecting
   * at this point in the ATN. You can call this anytime but ANTLR only
   * generates code to check before subrules/loops and each iteration.
   *
   * Implements Jim Idle's magic sync mechanism in closures and optional
   * subrules. E.g.,
   *
   * ```
   * a : sync ( stuff sync )* ;
   * sync : {consume to what can follow sync} ;
   * ```
   *
   * At the start of a sub rule upon error, {@link sync} performs single
   * token deletion, if possible. If it can't do that, it bails on the current
   * rule and uses the default error recovery, which consumes until the
   * resynchronization set of the current rule.
   *
   * If the sub rule is optional (`(...)?`, `(...)*`, or block
   * with an empty alternative), then the expected set includes what follows
   * the subrule.
   *
   * During loop iteration, it consumes until it sees a token that can start a
   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
   * stay in the loop as long as possible.
   *
   * **ORIGINS**
   *
   * Previous versions of ANTLR did a poor job of their recovery within loops.
   * A single mismatch token or missing token would force the parser to bail
   * out of the entire rules surrounding the loop. So, for rule
   *
   * ```
   * classDef : 'class' ID '{' member* '}'
   * ```
   *
   * input with an extra token between members would force the parser to
   * consume until it found the next class definition rather than the next
   * member definition of the current class.
   *
   * This functionality cost a little bit of effort because the parser has to
   * compare token set at the start of the loop and at each iteration. If for
   * some reason speed is suffering for you, you can turn off this
   * functionality by simply overriding this method as a blank { }.
   *
   */
  sync(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    const s = recognizer.atn.states[recognizer.state];
    const la = recognizer.tokenStream.LA(1);
    const nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(la)) {
      this.nextTokensContext = null;
      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
      return;
    }
    if (nextTokens.contains(Token.EPSILON)) {
      if (this.nextTokensContext === null) {
        this.nextTokensContext = recognizer.context;
        this.nextTokenState = recognizer.state;
      }
      return;
    }
    switch (s.constructor.stateType) {
      case ATNState.BLOCK_START:
      case ATNState.STAR_BLOCK_START:
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_LOOP_ENTRY: {
        if (this.singleTokenDeletion(recognizer) !== null) {
          return;
        }
        throw new InputMismatchException(recognizer);
      }
      case ATNState.PLUS_LOOP_BACK:
      case ATNState.STAR_LOOP_BACK: {
        this.reportUnwantedToken(recognizer);
        const expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
      }
      default:
    }
  }
  /**
   * This is called by {@link reportError} when the exception is a
   * {@link NoViableAltException}.
   *
   * @see reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportNoViableAlternative(recognizer, e) {
    if (e.message.length > 0) {
      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
      return;
    }
    const tokens = recognizer.tokenStream;
    let input;
    if (tokens !== null && e.startToken) {
      if (e.startToken.type === Token.EOF) {
        input = "<EOF>";
      } else {
        input = tokens.getTextFromRange(e.startToken, e.offendingToken);
      }
    } else {
      input = "<unknown input>";
    }
    const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link reportError} when the exception is an {@link InputMismatchException}.
   *
   * @see reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportInputMismatch(recognizer, e) {
    if (e.message.length > 0) {
      recognizer.notifyErrorListeners(e.message, e.offendingToken, e);
      return;
    }
    const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toStringWithVocabulary(recognizer.vocabulary);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link reportError} when the exception is a
   * {@link FailedPredicateException}.
   *
   * @see reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */
  reportFailedPredicate(recognizer, e) {
    const ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
    const msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This method is called to report a syntax error which requires the removal
   * of a token from the input stream. At the time this method is called, the
   * erroneous symbol is current `LT(1)` symbol and has not yet been
   * removed from the input stream. When this method returns,
   * `recognizer` is in error recovery mode.
   *
   * This method is called when {@link singleTokenDeletion} identifies
   * single-token deletion as a viable recovery strategy for a mismatched
   * input error.
   *
   * The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser.notifyErrorListeners}.
   *
   * @param recognizer the parser instance
   */
  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const tokenName = this.getTokenErrorDisplay(t);
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "extraneous input " + tokenName + " expecting " + expecting.toStringWithVocabulary(recognizer.vocabulary);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * This method is called to report a syntax error which requires the
   * insertion of a missing token into the input stream. At the time this
   * method is called, the missing token has not yet been inserted. When this
   * method returns, `recognizer` is in error recovery mode.
   *
   * This method is called when {@link singleTokenInsertion} identifies
   * single-token insertion as a viable recovery strategy for a mismatched
   * input error.
   *
   * The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser.notifyErrorListeners}.
   *
   * @param recognizer the parser instance
   */
  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }
    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "missing " + expecting.toStringWithVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * The default implementation attempts to recover from the mismatched input
   * by using single token insertion and deletion as described below. If the
   * recovery attempt fails, this method throws an
   * {@link InputMismatchException}.
   *
   * **EXTRA TOKEN** (single token deletion)
   *
   * `LA(1)` is not what we are looking for. If `LA(2)` has the
   * right token, however, then assume `LA(1)` is some extra spurious
   * token and delete it. Then consume and return the next token (which was
   * the `LA(2)` token) as the successful result of the match operation.
   *
   * This recovery strategy is implemented by {@link singleTokenDeletion}.
   *
   * **MISSING TOKEN** (single token insertion)
   *
   * If current token (at `LA(1)`) is consistent with what could come
   * after the expected `LA(1)` token, then assume the token is missing
   * and use the parser's {@link TokenFactory} to create it on the fly. The
   * "insertion" is performed by returning the created token as the successful
   * result of the match operation.
   *
   * This recovery strategy is implemented by {@link singleTokenInsertion}.
   *
   * **EXAMPLE**
   *
   * For example, Input `i=(3;` is clearly missing the `')'`. When
   * the parser returns from the nested call to `expr`, it will have
   * call chain:
   *
   * ```
   * stat -> expr -> atom
   * ```
   *
   * and it will be trying to match the `')'` at this point in the
   * derivation:
   *
   * ```
   * => ID '=' '(' INT ')' ('+' atom)* ';'
   * ^
   * ```
   *
   * The attempt to match `')'` will fail when it sees `';'` and
   * call {@link recoverInline}. To recover, it sees that `LA(1)==';'`
   * is in the set of tokens that can follow the `')'` token reference
   * in rule `atom`. It can assume that you forgot the `')'`.
   */
  recoverInline(recognizer) {
    const matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol) {
      recognizer.consume();
      return matchedSymbol;
    }
    if (this.singleTokenInsertion(recognizer)) {
      return this.getMissingSymbol(recognizer);
    }
    throw new InputMismatchException(recognizer);
  }
  /**
   * This method implements the single-token insertion inline error recovery
   * strategy. It is called by {@link recoverInline} if the single-token
   * deletion strategy fails to recover from the mismatched input. If this
   * method returns `true`, `recognizer` will be in error recovery
   * mode.
   *
   * This method determines whether or not single-token insertion is viable by
   * checking if the `LA(1)` input symbol could be successfully matched
   * if it were instead the `LA(2)` symbol. If this method returns
   * `true`, the caller is responsible for creating and inserting a
   * token with the correct type to produce this behavior.
   *
   * @param recognizer the parser instance
   * @returns `true` if single-token insertion is a viable recovery
   * strategy for the current mismatched input, otherwise `false`
   */
  singleTokenInsertion(recognizer) {
    const currentSymbolType = recognizer.tokenStream?.LA(1) ?? -1;
    const atn = recognizer.atn;
    const currentState = atn.states[recognizer.state];
    const next = currentState.transitions[0].target;
    const expectingAtLL2 = atn.nextTokens(next, recognizer.context ?? void 0);
    if (expectingAtLL2.contains(currentSymbolType)) {
      this.reportMissingToken(recognizer);
      return true;
    }
    return false;
  }
  /**
   * This method implements the single-token deletion inline error recovery
   * strategy. It is called by {@link recoverInline} to attempt to recover
   * from mismatched input. If this method returns null, the parser and error
   * handler state will not have changed. If this method returns non-null,
   * `recognizer` will *not* be in error recovery mode since the
   * returned token was a successful match.
   *
   * If the single-token deletion is successful, this method calls
   * {@link reportUnwantedToken} to report the error, followed by
   * {@link Parser.consume} to actually "delete" the extraneous token. Then,
   * before returning {@link reportMatch} is called to signal a successful
   * match.
   *
   * @param recognizer the parser instance
   * @returns the successfully matched {@link Token} instance if single-token
   * deletion successfully recovers from the mismatched input, otherwise
   * `null`
   */
  singleTokenDeletion(recognizer) {
    const nextTokenType = recognizer.tokenStream?.LA(2) ?? -1;
    const expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
      this.reportUnwantedToken(recognizer);
      recognizer.consume();
      const matchedSymbol = recognizer.getCurrentToken();
      this.reportMatch(recognizer);
      return matchedSymbol;
    }
    return null;
  }
  /**
   * Conjure up a missing token during error recovery.
   *
   * The recognizer attempts to recover from single missing
   * symbols. But, actions might refer to that missing symbol.
   * For example, x=ID {f($x);}. The action clearly assumes
   * that there has been an identifier matched previously and that
   * $x points at that token. If that token is missing, but
   * the next token in the stream is what we want we assume that
   * this token is missing and we keep going. Because we
   * have to return some token to replace the missing token,
   * we have to conjure one up. This method gives the user control
   * over the tokens returned for missing tokens. Mostly,
   * you will want to create something special for identifier
   * tokens. For literals such as '{' and ',', the default
   * action in the parser or tree parser works. It simply creates
   * a CommonToken of the appropriate type. The text will be the token.
   * If you change what tokens must be created by the lexer,
   * override this method to create the appropriate tokens.
   */
  getMissingSymbol(recognizer) {
    const currentSymbol = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    let expectedTokenType = Token.INVALID_TYPE;
    if (expecting.length !== 0) {
      expectedTokenType = expecting.minElement;
    }
    let tokenText;
    if (expectedTokenType === Token.EOF) {
      tokenText = "<missing EOF>";
    } else {
      tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
    }
    let current = currentSymbol;
    const lookBack = recognizer.tokenStream?.LT(-1);
    if (current.type === Token.EOF && lookBack !== null) {
      current = lookBack;
    }
    return recognizer.getTokenFactory().create(
      current.source,
      expectedTokenType,
      tokenText,
      Token.DEFAULT_CHANNEL,
      -1,
      -1,
      current.line,
      current.column
    );
  }
  getExpectedTokens(recognizer) {
    return recognizer.getExpectedTokens();
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out. Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   */
  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }
    let s = t.text;
    if (!s) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }
    return this.escapeWSAndQuote(s);
  }
  escapeWSAndQuote(s) {
    s = s.replace(/\n/g, "\\n");
    s = s.replace(/\r/g, "\\r");
    s = s.replace(/\t/g, "\\t");
    return "'" + s + "'";
  }
  /**
   * Compute the error recovery set for the current rule. During
   * rule invocation, the parser pushes the set of tokens that can
   * follow that rule reference on the stack; this amounts to
   * computing FIRST of what follows the rule reference in the
   * enclosing rule. See LinearApproximator.FIRST().
   * This local follow set only includes tokens
   * from within the rule; i.e., the FIRST computation done by
   * ANTLR stops at the end of a rule.
   *
   * EXAMPLE
   *
   * When you find a "no viable alt exception", the input is not
   * consistent with any of the alternatives for rule r. The best
   * thing to do is to consume tokens until you see something that
   * can legally follow a call to r//or* any rule that called r.
   * You don't want the exact set of viable next tokens because the
   * input might just be missing a token--you might consume the
   * rest of the input looking for one of the missing tokens.
   *
   * Consider grammar:
   *
   * a : '[' b ']'
   * | '(' b ')'
   * ;
   * b : c '^' INT ;
   * c : ID
   * | INT
   * ;
   *
   * At each rule invocation, the set of tokens that could follow
   * that rule is pushed on a stack. Here are the various
   * context-sensitive follow sets:
   *
   * FOLLOW(b1_in_a) = FIRST(']') = ']'
   * FOLLOW(b2_in_a) = FIRST(')') = ')'
   * FOLLOW(c_in_b) = FIRST('^') = '^'
   *
   * Upon erroneous input "[]", the call chain is
   *
   * a -> b -> c
   *
   * and, hence, the follow context stack is:
   *
   * depth follow set start of rule execution
   * 0 <EOF> a (from main())
   * 1 ']' b
   * 2 '^' c
   *
   * Notice that ')' is not included, because b would have to have
   * been called from a different context in rule a for ')' to be
   * included.
   *
   * For error recovery, we cannot consider FOLLOW(c)
   * (context-sensitive or otherwise). We need the combined set of
   * all context-sensitive FOLLOW sets--the set of all tokens that
   * could follow any reference in the call chain. We need to
   * resync to one of those tokens. Note that FOLLOW(c)='^' and if
   * we resync'd to that token, we'd consume until EOF. We need to
   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
   * In this case, for input "[]", LA(1) is ']' and in the set, so we would
   * not consume anything. After printing an error, rule c would
   * return normally. Rule b would not find the required '^' though.
   * At this point, it gets a mismatched token error and throws an
   * exception (since LA(1) is not in the viable following token
   * set). The rule exception handler tries to recover, but finds
   * the same recovery set and doesn't consume anything. Rule b
   * exits normally returning to rule a. Now it finds the ']' (and
   * with the successful match exits errorRecovery mode).
   *
   * So, you can see that the parser walks up the call chain looking
   * for the token that was a member of the recovery set.
   *
   * Errors are not generated in errorRecovery mode.
   *
   * ANTLR's error recovery mechanism is based upon original ideas:
   *
   * "Algorithms + Data Structures = Programs" by Niklaus Wirth
   *
   * and
   *
   * "A note on error recovery in recursive descent parsers":
   * http://portal.acm.org/citation.cfm?id=947902.947905
   *
   * Later, Josef Grosch had some good ideas:
   *
   * "Efficient and Comfortable Error Recovery in Recursive Descent
   * Parsers":
   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
   *
   * Like Grosch I implement context-sensitive FOLLOW sets that are combined
   * at run-time upon error to avoid overhead during parsing.
   */
  getErrorRecoverySet(recognizer) {
    const atn = recognizer.atn;
    let ctx = recognizer.context;
    const recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState >= 0) {
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      const follow = atn.nextTokens(rt.followState);
      recoverSet.addSet(follow);
      ctx = ctx.parent;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
  }
  /** Consume tokens until one matches the given token set. */
  consumeUntil(recognizer, set) {
    let ttype = recognizer.tokenStream?.LA(1) ?? -1;
    while (ttype !== Token.EOF && !set.contains(ttype)) {
      recognizer.consume();
      ttype = recognizer.tokenStream?.LA(1) ?? -1;
    }
  }
};

// src/BailErrorStrategy.ts
var BailErrorStrategy = class extends DefaultErrorStrategy {
  static {
    __name(this, "BailErrorStrategy");
  }
  /**
   * Instead of recovering from exception `e`, re-throw it wrapped
   * in a {@link ParseCancellationException} so it is not caught by the
   * rule function catches. Use {@link Exception//getCause()} to get the
   * original {@link RecognitionException}.
   */
  recover(recognizer, e) {
    throw new ParseCancellationException(e);
  }
  /**
   * Make sure we don't attempt to recover inline; if the parser
   * successfully recovers, it won't throw an exception.
   */
  recoverInline(recognizer) {
    const exception = new InputMismatchException(recognizer);
    throw new ParseCancellationException(exception);
  }
  // Make sure we don't attempt to recover from problems in subrules.
  sync(_recognizer) {
  }
};

// src/ListTokenSource.ts
var ListTokenSource = class {
  static {
    __name(this, "ListTokenSource");
  }
  /**
   * The name of the input source. If this value is `null`, a call to
   * {@link #getSourceName} should return the source name used to create the
   * the next token in {@link #tokens} (or the previous token if the end of
   * the input has been reached).
   */
  sourceName;
  tokenFactory = CommonTokenFactory.DEFAULT;
  /**
   * The wrapped collection of {@link Token} objects to return.
   */
  tokens = [];
  /**
   * The index into {@link tokens} of token to return by the next call to
   * {@link #nextToken}. The end of the input is indicated by this value
   * being greater than or equal to the number of items in {@link #tokens}.
   */
  i = 0;
  /**
   * This field caches the EOF token for the token source.
   */
  eofToken = null;
  constructor(tokens, sourceName) {
    this.tokens = tokens;
    this.sourceName = sourceName ?? "";
  }
  get column() {
    if (this.i < this.tokens.length) {
      return this.tokens[this.i].column;
    }
    if (this.eofToken !== null) {
      return this.eofToken.column;
    }
    if (this.tokens.length > 0) {
      const lastToken = this.tokens[this.tokens.length - 1];
      const tokenText = lastToken.text;
      if (tokenText) {
        const lastNewLine = tokenText.lastIndexOf("\n");
        if (lastNewLine >= 0) {
          return tokenText.length - lastNewLine - 1;
        }
      }
      return lastToken.column + lastToken.stop - lastToken.start + 1;
    }
    return 0;
  }
  nextToken() {
    if (this.i >= this.tokens.length) {
      if (this.eofToken === null) {
        let start = -1;
        if (this.tokens.length > 0) {
          const previousStop = this.tokens[this.tokens.length - 1].stop;
          if (previousStop !== -1) {
            start = previousStop + 1;
          }
        }
        const stop = Math.max(-1, start - 1);
        this.eofToken = this.tokenFactory.create(
          [this, this.inputStream],
          Token.EOF,
          "EOF",
          Token.DEFAULT_CHANNEL,
          start,
          stop,
          this.line,
          this.column
        );
      }
      return this.eofToken;
    }
    const t = this.tokens[this.i];
    if (this.i === this.tokens.length - 1 && t.type === Token.EOF) {
      this.eofToken = t;
    }
    this.i++;
    return t;
  }
  get line() {
    if (this.i < this.tokens.length) {
      return this.tokens[this.i].line;
    }
    if (this.eofToken !== null) {
      return this.eofToken.line;
    }
    if (this.tokens.length > 0) {
      const lastToken = this.tokens[this.tokens.length - 1];
      let line = lastToken.line;
      const tokenText = lastToken.text;
      if (tokenText) {
        for (const char of tokenText) {
          if (char === "\n") {
            line++;
          }
        }
      }
      return line;
    }
    return 1;
  }
  get inputStream() {
    if (this.i < this.tokens.length) {
      return this.tokens[this.i].inputStream;
    }
    if (this.eofToken !== null) {
      return this.eofToken.inputStream;
    }
    if (this.tokens.length > 0) {
      return this.tokens[this.tokens.length - 1].inputStream;
    }
    return null;
  }
  getSourceName() {
    if (this.sourceName !== null) {
      return this.sourceName;
    }
    const inputStream = this.inputStream;
    if (inputStream !== null) {
      return inputStream.getSourceName();
    }
    return "List";
  }
};

// src/InterpreterRuleContext.ts
var InterpreterRuleContext = class extends ParserRuleContext {
  static {
    __name(this, "InterpreterRuleContext");
  }
  /** This is the backing field for {@link #getRuleIndex}. */
  #ruleIndex;
  constructor(ruleIndex, parent, invokingStateNumber) {
    super(parent, invokingStateNumber);
    this.#ruleIndex = ruleIndex;
  }
  get ruleIndex() {
    return this.#ruleIndex;
  }
};

// src/TraceListener.ts
var TraceListener = class {
  static {
    __name(this, "TraceListener");
  }
  parser;
  constructor(parser) {
    this.parser = parser;
  }
  enterEveryRule(ctx) {
    console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
  }
  visitTerminal(node) {
    console.log("consume " + node.getSymbol() + " rule " + this.parser.ruleNames[this.parser.context.ruleIndex]);
  }
  exitEveryRule(ctx) {
    console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser.inputStream?.LT(1)?.text);
  }
  visitErrorNode(_node) {
  }
};

// src/Parser.ts
var Parser = class extends Recognizer {
  static {
    __name(this, "Parser");
  }
  /** For testing only. */
  printer = null;
  /**
   * Specifies whether or not the parser should construct a parse tree during
   * the parsing process. The default value is `true`.
   *
   * @see #getBuildParseTree
   * @see #setBuildParseTree
   */
  buildParseTrees = true;
  /**
   * The error handling strategy for the parser. The default value is a new
   * instance of {@link DefaultErrorStrategy}.
   *
   * @see #getErrorHandler
   * @see #setErrorHandler
   */
  errorHandler = new DefaultErrorStrategy();
  /**
   * The {@link ParserRuleContext} object for the currently executing rule.
   * This is always non-null during the parsing process.
   */
  // TODO: make private
  context = null;
  precedenceStack = [];
  /**
   * The list of {@link ParseTreeListener} listeners registered to receive
   * events during the parse.
   *
   * @see #addParseListener
   */
  parseListeners = null;
  /**
   * The number of syntax errors reported during parsing. This value is
   * incremented each time {@link #notifyErrorListeners} is called.
   */
  syntaxErrors = 0;
  /** Indicates parser has matched EOF token. See {@link #exitRule()}. */
  matchedEOF = false;
  /**
   * When {@link #setTrace}`(true)` is called, a reference to the
   * {@link TraceListener} is stored here so it can be easily removed in a
   * later call to {@link #setTrace}`(false)`. The listener itself is
   * implemented as a parser listener so this field is not directly used by
   * other parser methods.
   */
  tracer = null;
  /**
   * This field holds the deserialized {@link ATN} with bypass alternatives, created
   * lazily upon first demand. In 4.10 I changed from map<serializedATNString, ATN>
   * since we only need one per parser object and also it complicates other targets
   * that don't use ATN strings.
   *
   * @see ATNDeserializationOptions#isGenerateRuleBypassTransitions()
   */
  bypassAltsAtnCache = null;
  #inputStream;
  /**
   * This is all the parsing support code essentially. Most of it is error recovery stuff.
   */
  constructor(input) {
    super();
    this.precedenceStack.push(0);
    this.syntaxErrors = 0;
    this.#inputStream = input;
  }
  /** reset the parser's state */
  reset(rewindInputStream = true) {
    if (rewindInputStream) {
      this.inputStream.seek(0);
    }
    this.errorHandler.reset(this);
    this.context = null;
    this.syntaxErrors = 0;
    this.matchedEOF = false;
    this.setTrace(false);
    this.precedenceStack = [];
    this.precedenceStack.push(0);
    if (this.interpreter) {
      this.interpreter.reset();
    }
  }
  /**
   * Match current input symbol against `ttype`. If the symbol type
   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link consume} are
   * called to complete the match process.
   *
   * If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link buildParseTree} is
   * `true` and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
   *
   * @param ttype the token type to match
   * @returns the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * `ttype` and the error strategy could not recover from the
   * mismatched symbol
   */
  match(ttype) {
    let t = this.getCurrentToken();
    if (t.type === ttype) {
      if (ttype === Token.EOF) {
        this.matchedEOF = true;
      }
      this.errorHandler.reportMatch(this);
      this.consume();
    } else {
      t = this.errorHandler.recoverInline(this);
      if (this.buildParseTrees && t.tokenIndex === -1) {
        this.context.addErrorNode(this.createErrorNode(this.context, t));
      }
    }
    return t;
  }
  /**
   * Match current input symbol as a wildcard. If the symbol type matches
   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
   * and {@link consume} are called to complete the match process.
   *
   * If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link buildParseTree} is
   * `true` and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.
   *
   * @returns the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * a wildcard and the error strategy could not recover from the mismatched
   * symbol
   */
  matchWildcard() {
    let t = this.getCurrentToken();
    if (t.type > 0) {
      this.errorHandler.reportMatch(this);
      this.consume();
    } else {
      t = this.errorHandler.recoverInline(this);
      if (this.buildParseTrees && t.tokenIndex === -1) {
        this.context.addErrorNode(this.createErrorNode(this.context, t));
      }
    }
    return t;
  }
  getParseListeners() {
    return this.parseListeners ?? [];
  }
  /**
   * Registers `listener` to receive events during the parsing process.
   *
   * To support output-preserving grammar transformations (including but not
   * limited to left-recursion removal, automated left-factoring, and
   * optimized code generation), calls to listener methods during the parse
   * may differ substantially from calls made by
   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
   * particular, rule entry and exit events may occur in a different order
   * during the parse than after the parser. In addition, calls to certain
   * rule entry methods may be omitted.
   *
   * With the following specific exceptions, calls to listener events are
   * deterministic*, i.e. for identical input the calls to listener
   * methods will be the same.
   *
   * - Alterations to the grammar used to generate code may change the
   * behavior of the listener calls.
   * - Alterations to the command line options passed to ANTLR 4 when
   * generating the parser may change the behavior of the listener calls.
   * - Changing the version of the ANTLR Tool used to generate the parser
   * may change the behavior of the listener calls.
   *
   * @param listener the listener to add
   *
   * @throws NullPointerException if {@code} listener is `null`
   */
  addParseListener(listener) {
    if (listener === null) {
      throw new Error("listener");
    }
    if (this.parseListeners === null) {
      this.parseListeners = [];
    }
    this.parseListeners.push(listener);
  }
  /**
   * Remove `listener` from the list of parse listeners.
   *
   * If `listener` is `null` or has not been added as a parse
   * listener, this method does nothing.
   *
   * @param listener the listener to remove
   */
  removeParseListener(listener) {
    if (this.parseListeners !== null && listener !== null) {
      const idx = this.parseListeners.indexOf(listener);
      if (idx >= 0) {
        this.parseListeners.splice(idx, 1);
      }
      if (this.parseListeners.length === 0) {
        this.parseListeners = null;
      }
    }
  }
  // Remove all parse listeners.
  removeParseListeners() {
    this.parseListeners = null;
  }
  // Notify any parse listeners of an enter rule event.
  triggerEnterRuleEvent() {
    if (this.parseListeners !== null) {
      const ctx = this.context;
      this.parseListeners.forEach((listener) => {
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      });
    }
  }
  /**
   * Notify any parse listeners of an exit rule event.
   *
   * @see //addParseListener
   */
  triggerExitRuleEvent() {
    if (this.parseListeners !== null) {
      const ctx = this.context;
      this.parseListeners.slice(0).reverse().forEach((listener) => {
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      });
    }
  }
  getTokenFactory() {
    return this.inputStream.tokenSource.tokenFactory;
  }
  // Tell our token source and error strategy about a new way to create tokens.
  setTokenFactory(factory) {
    this.inputStream.tokenSource.tokenFactory = factory;
  }
  /**
   * The preferred method of getting a tree pattern. For example, here's a
   * sample use:
   *
   * ```
   * const t = parser.expr();
   * const p = parser.compileParseTreePattern("<ID>+0", MyParser.RULE_expr);
   * const m = p.match(t);
   * const id = m.get("ID");
   * ```
   */
  compileParseTreePattern(pattern, patternRuleIndex, lexer) {
    if (!lexer) {
      if (this.tokenStream !== null) {
        const tokenSource = this.tokenStream.tokenSource;
        if (tokenSource instanceof Lexer) {
          lexer = tokenSource;
        }
      }
    }
    if (!lexer) {
      throw new Error("Parser can't discover a lexer to use");
    }
    const m2 = new ParseTreePatternMatcher(lexer, this);
    return m2.compile(pattern, patternRuleIndex);
  }
  /**
   * The ATN with bypass alternatives is expensive to create so we create it
   * lazily.
   *
   * @throws UnsupportedOperationException if the current parser does not
   * implement the {@link getSerializedATN()} method.
   */
  getATNWithBypassAlts() {
    const serializedAtn = this.serializedATN;
    if (serializedAtn === null) {
      throw new Error("The current parser does not support an ATN with bypass alternatives.");
    }
    if (this.bypassAltsAtnCache !== null) {
      return this.bypassAltsAtnCache;
    }
    const deserializationOptions = { readOnly: false, verifyATN: true, generateRuleBypassTransitions: true };
    this.bypassAltsAtnCache = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
    return this.bypassAltsAtnCache;
  }
  /**
   * Gets the number of syntax errors reported during parsing. This value is
   * incremented each time {@link notifyErrorListeners} is called.
   */
  get numberOfSyntaxErrors() {
    return this.syntaxErrors;
  }
  get inputStream() {
    return this.#inputStream;
  }
  set inputStream(input) {
    this.tokenStream = input;
  }
  get tokenStream() {
    return this.#inputStream;
  }
  /** Set the token stream and reset the parser. */
  set tokenStream(input) {
    this.reset(false);
    this.#inputStream = input;
  }
  /**
   * Match needs to return the current input symbol, which gets put
   * into the label for the associated token ref; e.g., x=ID.
   */
  getCurrentToken() {
    return this.inputStream.LT(1);
  }
  notifyErrorListeners(msg, offendingToken, err) {
    offendingToken = offendingToken ?? null;
    err = err ?? null;
    if (offendingToken === null) {
      offendingToken = this.getCurrentToken();
    }
    this.syntaxErrors += 1;
    const line = offendingToken.line;
    const column = offendingToken.column;
    this.errorListenerDispatch.syntaxError(this, offendingToken, line, column, msg, err);
  }
  /**
   * Consume and return the {@link getCurrentToken current symbol}.
   *
   * E.g., given the following input with `A` being the current
   * lookahead symbol, this function moves the cursor to `B` and returns
   * `A`.
   *
   * ```
   * A B
   * ^
   * ```
   *
   * If the parser is not in error recovery mode, the consumed symbol is added
   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
   * If the parser *is* in error recovery mode, the consumed symbol is
   * added to the parse tree using
   * {@link ParserRuleContext//addErrorNode(Token)}, and
   * {@link ParseTreeListener//visitErrorNode} is called on any parse
   * listeners.
   */
  consume() {
    const o = this.getCurrentToken();
    if (o.type !== Token.EOF) {
      this.tokenStream.consume();
    }
    const hasListener = this.parseListeners !== null && this.parseListeners.length > 0;
    if (this.buildParseTrees || hasListener) {
      let node;
      if (this.errorHandler.inErrorRecoveryMode(this)) {
        node = this.context.addErrorNode(this.createErrorNode(this.context, o));
      } else {
        node = this.context.addTokenNode(o);
      }
      if (hasListener) {
        this.parseListeners.forEach((listener) => {
          if (node instanceof ErrorNode) {
            listener.visitErrorNode(node);
          } else {
            listener.visitTerminal(node);
          }
        });
      }
    }
    return o;
  }
  addContextToParseTree() {
    if (this.context?.parent) {
      this.context.parent.addChild(this.context);
    }
  }
  /**
   * Always called by generated parsers upon entry to a rule. Access field
   * {@link context} get the current context.
   */
  enterRule(localctx, state, _ruleIndex) {
    this.state = state;
    this.context = localctx;
    this.context.start = this.inputStream.LT(1);
    if (this.buildParseTrees) {
      this.addContextToParseTree();
    }
    this.triggerEnterRuleEvent();
  }
  exitRule() {
    if (this.matchedEOF) {
      this.context.stop = this.inputStream.LT(1);
    } else {
      this.context.stop = this.inputStream.LT(-1);
    }
    this.triggerExitRuleEvent();
    this.state = this.context.invokingState;
    this.context = this.context.parent;
  }
  enterOuterAlt(localctx, altNum) {
    localctx.setAltNumber(altNum);
    if (this.buildParseTrees && this.context !== localctx) {
      if (this.context?.parent) {
        this.context.parent.removeLastChild();
        this.context.parent.addChild(localctx);
      }
    }
    this.context = localctx;
  }
  /**
   * Get the precedence level for the top-most precedence rule.
   *
   * @returns The precedence level for the top-most precedence rule, or -1 if
   * the parser context is not nested within a precedence rule.
   */
  getPrecedence() {
    if (this.precedenceStack.length === 0) {
      return -1;
    }
    return this.precedenceStack[this.precedenceStack.length - 1];
  }
  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.state = state;
    this.precedenceStack.push(precedence);
    this.context = localctx;
    this.context.start = this.inputStream.LT(1);
    this.triggerEnterRuleEvent();
  }
  /** Like {@link enterRule} but for recursive rules. */
  pushNewRecursionContext(localctx, state, _ruleIndex) {
    const previous = this.context;
    previous.parent = localctx;
    previous.invokingState = state;
    previous.stop = this.inputStream.LT(-1);
    this.context = localctx;
    this.context.start = previous.start;
    if (this.buildParseTrees) {
      this.context.addChild(previous);
    }
    this.triggerEnterRuleEvent();
  }
  unrollRecursionContexts(parent) {
    this.precedenceStack.pop();
    this.context.stop = this.inputStream.LT(-1);
    const retCtx = this.context;
    const parseListeners = this.getParseListeners();
    if (parseListeners !== null && parseListeners.length > 0) {
      while (this.context !== parent) {
        this.triggerExitRuleEvent();
        this.context = this.context.parent;
      }
    } else {
      this.context = parent;
    }
    retCtx.parent = parent;
    if (this.buildParseTrees && parent !== null) {
      parent.addChild(retCtx);
    }
  }
  getInvokingContext(ruleIndex) {
    let ctx = this.context;
    while (ctx !== null) {
      if (ctx.ruleIndex === ruleIndex) {
        return ctx;
      }
      ctx = ctx.parent;
    }
    return null;
  }
  precpred(_localctx, precedence) {
    return precedence >= this.precedenceStack[this.precedenceStack.length - 1];
  }
  /**
   * Checks whether or not `symbol` can follow the current state in the
   * ATN. The behavior of this method is equivalent to the following, but is
   * implemented such that the complete context-sensitive follow set does not
   * need to be explicitly constructed.
   *
   * ```
   * return getExpectedTokens().contains(symbol);
   * ```
   *
   * @param symbol the symbol type to check
   * @returns `true` if `symbol` can follow the current state in
   * the ATN, otherwise `false`.
   */
  isExpectedToken(symbol) {
    const atn = this.interpreter.atn;
    let ctx = this.context;
    const s = atn.states[this.state];
    let following = atn.nextTokens(s);
    if (following.contains(symbol)) {
      return true;
    }
    if (!following.contains(Token.EPSILON)) {
      return false;
    }
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = atn.nextTokens(rt.followState);
      if (following.contains(symbol)) {
        return true;
      }
      ctx = ctx.parent;
    }
    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Computes the set of input symbols which could follow the current parser
   * state and context, as given by {@link getState} and {@link getContext},
   * respectively.
   *
   * {@link ATN.getExpectedTokens ATN.getExpectedTokens(int, RuleContext)}
   */
  getExpectedTokens() {
    return this.interpreter.atn.getExpectedTokens(this.state, this.context);
  }
  getExpectedTokensWithinCurrentRule() {
    const atn = this.interpreter.atn;
    const s = atn.states[this.state];
    return atn.nextTokens(s);
  }
  /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
  getRuleIndex(ruleName) {
    return this.getRuleIndexMap().get(ruleName) ?? -1;
  }
  /**
   * @returns an array of string of the rule names in your parser instance
   * leading up to a call to the current rule. You could override if
   * you want more details such as the file/line info of where
   * in the ATN a rule is invoked.
   *
   * this is very useful for error messages.
   */
  getRuleInvocationStack(p) {
    p = p ?? null;
    if (p === null) {
      p = this.context;
    }
    const stack = [];
    while (p !== null) {
      const ruleIndex = p.ruleIndex;
      if (ruleIndex < 0) {
        stack.push("n/a");
      } else {
        stack.push(this.ruleNames[ruleIndex]);
      }
      p = p.parent;
    }
    return stack;
  }
  /**
   * For debugging and other purposes.
   *
   * TODO: this differs from the Java version. Change it.
   */
  getDFAStrings() {
    return this.interpreter.decisionToDFA.toString();
  }
  /** For debugging and other purposes. */
  dumpDFA() {
    let seenOne = false;
    for (const dfa of this.interpreter.decisionToDFA) {
      if (dfa.length > 0) {
        if (seenOne) {
          console.log();
        }
        if (this.printer) {
          this.printer.println("Decision " + dfa.decision + ":");
          this.printer.print(dfa.toString(this.vocabulary));
        }
        seenOne = true;
      }
    }
  }
  getSourceName() {
    return this.inputStream.getSourceName();
  }
  getParseInfo() {
    const interp = this.interpreter;
    if (interp instanceof ProfilingATNSimulator) {
      return new ParseInfo(interp);
    }
    return void 0;
  }
  setProfile(profile) {
    const interp = this.interpreter;
    const saveMode = interp.predictionMode;
    if (profile) {
      if (!(interp instanceof ProfilingATNSimulator)) {
        this.interpreter = new ProfilingATNSimulator(this);
      }
    } else if (interp instanceof ProfilingATNSimulator) {
      const sharedContextCache = interp.sharedContextCache;
      if (sharedContextCache) {
        const sim = new ParserATNSimulator(this, this.atn, interp.decisionToDFA, sharedContextCache);
        this.interpreter = sim;
      }
    }
    this.interpreter.predictionMode = saveMode;
  }
  /**
   * During a parse is sometimes useful to listen in on the rule entry and exit
   * events as well as token matches. this is for quick and dirty debugging.
   */
  setTrace(trace) {
    if (!trace) {
      this.removeParseListener(this.tracer);
      this.tracer = null;
    } else {
      if (this.tracer !== null) {
        this.removeParseListener(this.tracer);
      }
      this.tracer = new TraceListener(this);
      this.addParseListener(this.tracer);
    }
  }
  createTerminalNode(parent, t) {
    return new TerminalNode(t);
  }
  createErrorNode(parent, t) {
    return new ErrorNode(t);
  }
};

// src/ParserInterpreter.ts
var ParserInterpreter = class extends Parser {
  static {
    __name(this, "ParserInterpreter");
  }
  rootContext;
  overrideDecisionRoot = null;
  parentContextStack = [];
  overrideDecisionAlt = -1;
  overrideDecisionReached = false;
  decisionToDFA;
  sharedContextCache = new PredictionContextCache();
  pushRecursionContextStates;
  #overrideDecision = -1;
  #overrideDecisionInputIndex = -1;
  #grammarFileName;
  #atn;
  #ruleNames;
  #vocabulary;
  constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
    super(input);
    this.#grammarFileName = grammarFileName;
    this.#atn = atn;
    this.#ruleNames = ruleNames.slice(0);
    this.#vocabulary = vocabulary;
    this.pushRecursionContextStates = new BitSet();
    for (const state of atn.states) {
      if (state instanceof StarLoopEntryState && state.precedenceRuleDecision) {
        this.pushRecursionContextStates.set(state.stateNumber);
      }
    }
    this.decisionToDFA = atn.decisionToState.map((ds, i) => {
      return new DFA(ds, i);
    });
    this.interpreter = new ParserATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
  }
  reset() {
    super.reset();
    this.overrideDecisionReached = false;
    this.overrideDecisionRoot = null;
  }
  get atn() {
    return this.#atn;
  }
  get vocabulary() {
    return this.#vocabulary;
  }
  get ruleNames() {
    return this.#ruleNames;
  }
  get grammarFileName() {
    return this.#grammarFileName;
  }
  get atnState() {
    return this.#atn.states[this.state];
  }
  parse(startRuleIndex) {
    const startRuleStartState = this.#atn.ruleToStartState[startRuleIndex];
    this.rootContext = this.createInterpreterRuleContext(null, ATNState.INVALID_STATE_NUMBER, startRuleIndex);
    if (startRuleStartState.isLeftRecursiveRule) {
      this.enterRecursionRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
    } else {
      this.enterRule(this.rootContext, startRuleStartState.stateNumber, startRuleIndex);
    }
    while (true) {
      const p = this.atnState;
      switch (p.constructor.stateType) {
        case ATNState.RULE_STOP: {
          if (this.context?.isEmpty()) {
            if (startRuleStartState.isLeftRecursiveRule) {
              const result = this.context;
              const parentContext = this.parentContextStack.pop();
              this.unrollRecursionContexts(parentContext[0]);
              return result;
            } else {
              this.exitRule();
              return this.rootContext;
            }
          }
          this.visitRuleStopState(p);
          break;
        }
        default: {
          try {
            this.visitState(p);
          } catch (e) {
            if (e instanceof RecognitionException) {
              this.state = this.#atn.ruleToStopState[p.ruleIndex].stateNumber;
              this.errorHandler.reportError(this, e);
              this.recover(e);
            } else {
              throw e;
            }
          }
          break;
        }
      }
    }
  }
  addDecisionOverride(decision, tokenIndex, forcedAlt) {
    this.#overrideDecision = decision;
    this.#overrideDecisionInputIndex = tokenIndex;
    this.overrideDecisionAlt = forcedAlt;
  }
  get overrideDecision() {
    return this.#overrideDecision;
  }
  get overrideDecisionInputIndex() {
    return this.#overrideDecisionInputIndex;
  }
  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.parentContextStack.push([this.context, localctx.invokingState]);
    super.enterRecursionRule(localctx, state, ruleIndex, precedence);
  }
  get serializedATN() {
    throw new Error("The ParserInterpreter does not support the serializedATN property.");
  }
  visitState(p) {
    let predictedAlt = 1;
    if (p instanceof DecisionState) {
      predictedAlt = this.visitDecisionState(p);
    }
    const transition = p.transitions[predictedAlt - 1];
    switch (transition.transitionType) {
      case Transition.EPSILON:
        if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target.constructor.stateType === ATNState.LOOP_END)) {
          const parentContext = this.parentContextStack[this.parentContextStack.length - 1];
          const localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this.context.ruleIndex);
          this.pushNewRecursionContext(
            localctx,
            this.#atn.ruleToStartState[p.ruleIndex].stateNumber,
            this.context.ruleIndex
          );
        }
        break;
      case Transition.ATOM:
        this.match(transition.label.minElement);
        break;
      case Transition.RANGE:
      case Transition.SET:
      case Transition.NOT_SET:
        if (!transition.matches(this.inputStream.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {
          this.recoverInline();
        }
        this.matchWildcard();
        break;
      case Transition.WILDCARD:
        this.matchWildcard();
        break;
      case Transition.RULE:
        const ruleStartState = transition.target;
        const ruleIndex = ruleStartState.ruleIndex;
        const newContext = this.createInterpreterRuleContext(this.context, p.stateNumber, ruleIndex);
        if (ruleStartState.isLeftRecursiveRule) {
          this.enterRecursionRule(
            newContext,
            ruleStartState.stateNumber,
            ruleIndex,
            transition.precedence
          );
        } else {
          this.enterRule(newContext, transition.target.stateNumber, ruleIndex);
        }
        break;
      case Transition.PREDICATE:
        const predicateTransition = transition;
        if (!this.sempred(this.context, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
          throw new FailedPredicateException(this);
        }
        break;
      case Transition.ACTION:
        const actionTransition = transition;
        this.action(this.context, actionTransition.ruleIndex, actionTransition.actionIndex);
        break;
      case Transition.PRECEDENCE:
        if (!this.precpred(this.context, transition.precedence)) {
          const precedence = transition.precedence;
          throw new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
        }
        break;
      default:
        throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
    }
    this.state = transition.target.stateNumber;
  }
  visitDecisionState(p) {
    let predictedAlt = 1;
    if (p.transitions.length > 1) {
      this.errorHandler.sync(this);
      const decision = p.decision;
      if (decision === this.#overrideDecision && this.inputStream.index === this.#overrideDecisionInputIndex && !this.overrideDecisionReached) {
        predictedAlt = this.overrideDecisionAlt;
        this.overrideDecisionReached = true;
      } else {
        predictedAlt = this.interpreter.adaptivePredict(this.inputStream, decision, this.context);
      }
    }
    return predictedAlt;
  }
  createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
    return new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
  }
  visitRuleStopState(p) {
    const ruleStartState = this.#atn.ruleToStartState[p.ruleIndex];
    if (ruleStartState.isLeftRecursiveRule) {
      const [parentContext, state] = this.parentContextStack.pop();
      this.unrollRecursionContexts(parentContext);
      this.state = state;
    } else {
      this.exitRule();
    }
    const ruleTransition = this.#atn.states[this.state].transitions[0];
    this.state = ruleTransition.followState.stateNumber;
  }
  recover(e) {
    const i = this.inputStream.index;
    this.errorHandler.recover(this, e);
    if (this.inputStream.index === i) {
      const tok = e.offendingToken;
      if (!tok) {
        throw new Error("Expected exception to have an offending token");
      }
      const source = tok.tokenSource;
      const stream = source?.inputStream ?? null;
      const sourcePair = [source, stream];
      if (e instanceof InputMismatchException) {
        const expectedTokens = e.getExpectedTokens();
        if (!expectedTokens) {
          throw new Error("Expected the exception to provide expected tokens");
        }
        let expectedTokenType = Token.INVALID_TYPE;
        if (expectedTokens.length !== 0) {
          expectedTokenType = expectedTokens.minElement;
        }
        const errToken = this.getTokenFactory().create(
          sourcePair,
          expectedTokenType,
          tok.text,
          Token.DEFAULT_CHANNEL,
          -1,
          -1,
          tok.line,
          tok.column
        );
        this.context.addErrorNode(this.createErrorNode(this.context, errToken));
      } else {
        const errToken = this.getTokenFactory().create(
          sourcePair,
          Token.INVALID_TYPE,
          tok.text,
          Token.DEFAULT_CHANNEL,
          -1,
          -1,
          tok.line,
          tok.column
        );
        this.context.addErrorNode(this.createErrorNode(this.context, errToken));
      }
    }
  }
  recoverInline() {
    return this.errorHandler.recoverInline(this);
  }
};

// src/misc/MultiMap.ts
var MultiMap = class extends Map {
  static {
    __name(this, "MultiMap");
  }
  map(key, value) {
    let elementsForKey = this.get(key);
    if (!elementsForKey) {
      elementsForKey = new Array();
      this.set(key, elementsForKey);
    }
    elementsForKey.push(value);
  }
  getPairs() {
    const pairs = new Array();
    for (const key of this.keys()) {
      const keys = this.get(key) ?? [];
      for (const value of keys) {
        pairs.push([key, value]);
      }
    }
    return pairs;
  }
  toString() {
    const entries = [];
    this.forEach((value, key) => {
      entries.push(`${key}=[${value.join(", ")}]`);
    });
    return `{${entries.join(", ")}}`;
  }
};

// src/tree/pattern/CannotInvokeStartRuleError.ts
var CannotInvokeStartRuleError = class extends Error {
  static {
    __name(this, "CannotInvokeStartRuleError");
  }
  constructor(e) {
    super();
    this.cause = e;
  }
};

// src/tree/pattern/RuleTagToken.ts
var RuleTagToken = class {
  static {
    __name(this, "RuleTagToken");
  }
  /** The name of the label associated with the rule tag. */
  label;
  /** The name of the parser rule associated with this rule tag. */
  ruleName;
  /**
   * The token type for the current token. This is the token type assigned to
   * the bypass alternative for the rule during ATN deserialization.
   */
  bypassTokenType;
  constructor(ruleName, bypassTokenType, label) {
    this.ruleName = ruleName;
    this.bypassTokenType = bypassTokenType;
    this.label = label;
  }
  /**
   * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
   */
  get channel() {
    return Token.DEFAULT_CHANNEL;
  }
  /**
   * This method returns the rule tag formatted with `<` and `>`
   * delimiters.
   */
  get text() {
    if (this.label !== void 0) {
      return "<" + this.label + ":" + this.ruleName + ">";
    }
    return "<" + this.ruleName + ">";
  }
  /**
   * Rule tag tokens have types assigned according to the rule bypass
   * transitions created during ATN deserialization.
   */
  get type() {
    return this.bypassTokenType;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns 0.
   */
  get line() {
    return 0;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns -1.
   */
  get column() {
    return -1;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns -1.
   */
  get tokenIndex() {
    return -1;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns -1.
   */
  get start() {
    return -1;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns -1.
   */
  get stop() {
    return -1;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns `null`.
   */
  get tokenSource() {
    return null;
  }
  /**
   * The implementation for {@link RuleTagToken} always returns `null`.
   */
  get inputStream() {
    return null;
  }
  /**
   * The implementation for {@link RuleTagToken} returns a string of the form
   * `ruleName:bypassTokenType`.
   */
  toString() {
    return this.ruleName + ":" + this.bypassTokenType;
  }
};

// src/tree/pattern/StartRuleDoesNotConsumeFullPatternError.ts
var StartRuleDoesNotConsumeFullPatternError = class extends Error {
  static {
    __name(this, "StartRuleDoesNotConsumeFullPatternError");
  }
};

// src/tree/pattern/TagChunk.ts
var TagChunk = class extends Chunk {
  static {
    __name(this, "TagChunk");
  }
  tag;
  label;
  constructor(...args) {
    let label;
    let tag;
    if (args.length === 1) {
      tag = args[0];
    } else {
      label = args[0];
      tag = args[1];
    }
    super();
    if (!tag) {
      throw new Error("tag cannot be null or empty");
    }
    this.label = label;
    this.tag = tag;
  }
  /**
   * @returns a text representation of the tag chunk. Labeled tags
   * are returned in the form `label:tag`, and unlabeled tags are
   * returned as just the tag name.
   */
  toString() {
    if (this.label !== void 0) {
      return this.label + ":" + this.tag;
    }
    return this.tag;
  }
};

// src/tree/pattern/TextChunk.ts
var TextChunk = class extends Chunk {
  static {
    __name(this, "TextChunk");
  }
  text;
  /**
   * Constructs a new instance of {@link TextChunk} with the specified text.
   *
   * @param text The text of this chunk.
   */
  constructor(text) {
    super();
    this.text = text;
  }
  /**
   * @returns the result of {@link #getText()} in single quotes.
   */
  toString() {
    return "'" + this.text + "'";
  }
};

// src/tree/pattern/TokenTagToken.ts
var TokenTagToken = class extends CommonToken {
  static {
    __name(this, "TokenTagToken");
  }
  tokenName;
  /**
   * The name of the label associated with the rule tag, or undefined if this is an unlabeled rule tag.
   */
  label;
  constructor(tokenName, type, label) {
    super({ type, source: CommonToken.EMPTY_SOURCE });
    this.tokenName = tokenName;
    this.label = label;
  }
  /**
   *
   * @returns the token tag formatted with `<` and `>` delimiters.
   */
  get text() {
    if (this.label !== void 0) {
      return "<" + this.label + ":" + this.tokenName + ">";
    }
    return "<" + this.tokenName + ">";
  }
  /**
   * @returns a string of the form `tokenName:type`.
   */
  toString() {
    return this.tokenName + ":" + this.type;
  }
};

// src/tree/pattern/ParseTreePatternMatcher.ts
var ParseTreePatternMatcher = class {
  static {
    __name(this, "ParseTreePatternMatcher");
  }
  start = "<";
  stop = ">";
  escape = "\\";
  // e.g., \< and \> must escape BOTH!
  /**
   * This is the backing field for {@link #getLexer()}.
   */
  lexer;
  /**
   * This is the backing field for {@link #getParser()}.
   */
  parser;
  /**
   * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
   * {@link Parser} object. The lexer input stream is altered for tokenizing
   * the tree patterns. The parser is used as a convenient mechanism to get
   * the grammar name, plus token, rule names.
   */
  constructor(lexer, parser) {
    this.lexer = lexer;
    this.parser = parser;
  }
  /**
   * Set the delimiters used for marking rule and token tags within concrete
   * syntax used by the tree pattern parser.
   *
   * @param start The start delimiter.
   * @param stop The stop delimiter.
   * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
   *
   * @throws Error if `start` is `null` or empty.
   * @throws Error if `stop` is `null` or empty.
   */
  setDelimiters(start, stop, escapeLeft) {
    if (start === null || start.length === 0) {
      throw new Error("start cannot be null or empty");
    }
    if (stop === null || stop.length === 0) {
      throw new Error("stop cannot be null or empty");
    }
    this.start = start;
    this.stop = stop;
    this.escape = escapeLeft;
  }
  matches(...args) {
    switch (args.length) {
      case 2: {
        const [tree, pattern] = args;
        const labels = new MultiMap();
        const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
        return mismatchedNode === null;
      }
      case 3: {
        const [tree, pattern, patternRuleIndex] = args;
        const p = this.compile(pattern, patternRuleIndex);
        return this.matches(tree, p);
      }
      default: {
        throw new Error("Invalid number of arguments");
      }
    }
  }
  match(...args) {
    switch (args.length) {
      case 2: {
        const [tree, pattern] = args;
        const labels = new MultiMap();
        const mismatchedNode = this.matchImpl(tree, pattern.getPatternTree(), labels);
        return new ParseTreeMatch(tree, pattern, labels, mismatchedNode);
      }
      case 3: {
        const [tree, pattern, patternRuleIndex] = args;
        const p = this.compile(pattern, patternRuleIndex);
        return this.match(tree, p);
      }
      default: {
        throw new Error("Invalid number of arguments");
      }
    }
  }
  /**
   * For repeated use of a tree pattern, compile it to a
   * {@link ParseTreePattern} using this method.
   */
  compile(pattern, patternRuleIndex) {
    const tokenList = this.tokenize(pattern);
    const tokenSrc = new ListTokenSource(tokenList);
    const tokens = new CommonTokenStream(tokenSrc);
    const parserInterp = new ParserInterpreter(
      this.parser.grammarFileName,
      this.parser.vocabulary,
      this.parser.ruleNames,
      this.parser.getATNWithBypassAlts(),
      tokens
    );
    parserInterp.removeErrorListeners();
    let tree = null;
    try {
      parserInterp.errorHandler = new BailErrorStrategy();
      tree = parserInterp.parse(patternRuleIndex);
    } catch (error) {
      if (error instanceof ParseCancellationException) {
        throw error.cause;
      } else if (error instanceof RecognitionException) {
        throw error;
      } else if (error instanceof Error) {
        throw new CannotInvokeStartRuleError(error);
      } else {
        throw error;
      }
    }
    if (tokens.LA(1) !== Token.EOF) {
      throw new StartRuleDoesNotConsumeFullPatternError();
    }
    return new ParseTreePattern(this, pattern, patternRuleIndex, tree);
  }
  /**
   * Used to convert the tree pattern string into a series of tokens. The
   * input stream is reset.
   */
  getLexer() {
    return this.lexer;
  }
  /**
   * Used to collect to the grammar file name, token names, rule names for
   * used to parse the pattern into a parse tree.
   */
  getParser() {
    return this.parser;
  }
  // ---- SUPPORT CODE ----
  tokenize(pattern) {
    const chunks = this.split(pattern);
    const tokens = new Array();
    for (const chunk of chunks) {
      if (chunk instanceof TagChunk) {
        const tagChunk = chunk;
        const char = tagChunk.tag[0];
        if (char === char.toUpperCase()) {
          const ttype = this.parser.getTokenType(tagChunk.tag);
          if (ttype === Token.INVALID_TYPE) {
            throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
          }
          const t = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
          tokens.push(t);
        } else {
          if (char === char.toLowerCase()) {
            const ruleIndex = this.parser.getRuleIndex(tagChunk.tag);
            if (ruleIndex === -1) {
              throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
            }
            const ruleImaginaryTokenType = this.parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
            tokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
          } else {
            throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
          }
        }
      } else {
        const textChunk = chunk;
        const input = CharStream.fromString(textChunk.text);
        this.lexer.inputStream = input;
        let t = this.lexer.nextToken();
        while (t.type !== Token.EOF) {
          tokens.push(t);
          t = this.lexer.nextToken();
        }
      }
    }
    return tokens;
  }
  /**
   * Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}.
   */
  split(pattern) {
    let p = 0;
    const n2 = pattern.length;
    const chunks = new Array();
    const starts = new Array();
    const stops = new Array();
    while (p < n2) {
      if (p === pattern.indexOf(this.escape + this.start, p)) {
        p += this.escape.length + this.start.length;
      } else {
        if (p === pattern.indexOf(this.escape + this.stop, p)) {
          p += this.escape.length + this.stop.length;
        } else {
          if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else {
            if (p === pattern.indexOf(this.stop, p)) {
              stops.push(p);
              p += this.stop.length;
            } else {
              p++;
            }
          }
        }
      }
    }
    if (starts.length > stops.length) {
      throw new Error("unterminated tag in pattern: " + pattern);
    }
    if (starts.length < stops.length) {
      throw new Error("missing start tag in pattern: " + pattern);
    }
    const tagCount = starts.length;
    for (let i = 0; i < tagCount; i++) {
      if (starts[i] >= stops[i]) {
        throw new Error("tag delimiters out of order in pattern: " + pattern);
      }
    }
    if (tagCount === 0) {
      const text = pattern.substring(0, n2);
      chunks.push(new TextChunk(text));
    }
    if (tagCount > 0 && starts[0] > 0) {
      const text = pattern.substring(0, starts[0]);
      chunks.push(new TextChunk(text));
    }
    for (let i = 0; i < tagCount; i++) {
      const tag = pattern.substring(starts[i] + this.start.length, stops[i]);
      let ruleOrToken = tag;
      let label;
      const colon = tag.indexOf(":");
      if (colon >= 0) {
        label = tag.substring(0, colon);
        ruleOrToken = tag.substring(colon + 1, tag.length);
      }
      chunks.push(new TagChunk(label, ruleOrToken));
      if (i + 1 < tagCount) {
        const text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
        chunks.push(new TextChunk(text));
      }
    }
    if (tagCount > 0) {
      const afterLastTag = stops[tagCount - 1] + this.stop.length;
      if (afterLastTag < n2) {
        const text = pattern.substring(afterLastTag, n2);
        chunks.push(new TextChunk(text));
      }
    }
    for (let i = 0; i < chunks.length; i++) {
      const c = chunks[i];
      if (c instanceof TextChunk) {
        const tc = c;
        const unescaped = tc.text.replaceAll(this.escape, "");
        if (unescaped.length < tc.text.length) {
          chunks[i] = new TextChunk(unescaped);
        }
      }
    }
    return chunks;
  }
  /**
   * Recursively walk `tree` against `patternTree`, filling
   * `match.`{@link ParseTreeMatch#labels labels}.
   *
   * @returns the first node encountered in `tree` which does not match
   * a corresponding node in `patternTree`, or `null` if the match
   * was successful. The specific node returned depends on the matching
   * algorithm used by the implementation, and may be overridden.
   */
  matchImpl(tree, patternTree, labels) {
    if (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {
      const t1 = tree;
      const t2 = patternTree;
      let mismatchedNode;
      if (t1.getSymbol().type === t2.getSymbol().type) {
        if (t2.getSymbol() instanceof TokenTagToken) {
          const tokenTagToken = t2.getSymbol();
          labels.map(tokenTagToken.tokenName, tree);
          if (tokenTagToken.label !== void 0) {
            labels.map(tokenTagToken.label, tree);
          }
        } else {
          if (t1.getText() === t2.getText()) {
          } else {
            if (!mismatchedNode) {
              mismatchedNode = t1;
            }
          }
        }
      } else {
        if (!mismatchedNode) {
          mismatchedNode = t1;
        }
      }
      return mismatchedNode;
    }
    if (tree instanceof ParserRuleContext && patternTree instanceof ParserRuleContext) {
      let mismatchedNode;
      const ruleTagToken = this.getRuleTagToken(patternTree);
      if (ruleTagToken) {
        if (tree.ruleIndex === patternTree.ruleIndex) {
          labels.map(ruleTagToken.ruleName, tree);
          if (ruleTagToken.label) {
            labels.map(ruleTagToken.label, tree);
          }
        } else {
          if (!mismatchedNode) {
            mismatchedNode = tree;
          }
        }
        return mismatchedNode;
      }
      if (tree.getChildCount() !== patternTree.getChildCount()) {
        if (!mismatchedNode) {
          mismatchedNode = tree;
        }
        return mismatchedNode;
      }
      const n2 = tree.getChildCount();
      for (let i = 0; i < n2; i++) {
        const childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
        if (childMatch) {
          return childMatch;
        }
      }
      return mismatchedNode;
    }
    return tree;
  }
  /**
   * Is `t` `(expr <expr>)` subtree?
   */
  getRuleTagToken(t) {
    if (t instanceof ParserRuleContext) {
      if (t.getChildCount() === 1 && t.getChild(0) instanceof TerminalNode) {
        const c = t.getChild(0);
        if (c.getSymbol() instanceof RuleTagToken) {
          return c.getSymbol();
        }
      }
    }
    return void 0;
  }
};

// src/DiagnosticErrorListener.ts
var DiagnosticErrorListener = class extends BaseErrorListener {
  static {
    __name(this, "DiagnosticErrorListener");
  }
  /**
   * When `true`, only exactly known ambiguities are reported.
   */
  exactOnly;
  constructor(exactOnly) {
    super();
    this.exactOnly = exactOnly ?? true;
  }
  reportAmbiguity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) => {
    if (this.exactOnly && !exact) {
      return;
    }
    const decision = this.getDecisionDescription(recognizer, dfa);
    const conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
    const message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
    recognizer.notifyErrorListeners(message, null, null);
  }, "reportAmbiguity");
  reportAttemptingFullContext = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _conflictingAlts, _configs) => {
    const decision = this.getDecisionDescription(recognizer, dfa);
    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
    const message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
    recognizer.notifyErrorListeners(message, null, null);
  }, "reportAttemptingFullContext");
  reportContextSensitivity = /* @__PURE__ */ __name((recognizer, dfa, startIndex, stopIndex, _prediction, _configs) => {
    const decision = this.getDecisionDescription(recognizer, dfa);
    const text = recognizer.tokenStream?.getTextFromInterval(Interval.of(startIndex, stopIndex));
    const message = `reportContextSensitivity d=${decision}, input='${text}'`;
    recognizer.notifyErrorListeners(message, null, null);
  }, "reportContextSensitivity");
  getDecisionDescription = /* @__PURE__ */ __name((recognizer, dfa) => {
    const decision = dfa.decision;
    const ruleIndex = dfa.atnStartState.ruleIndex;
    const ruleNames = recognizer.ruleNames;
    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
      return decision.toString();
    }
    const ruleName = ruleNames[ruleIndex];
    if (ruleName.length === 0) {
      return decision.toString();
    }
    return `${decision} (${ruleName})`;
  }, "getDecisionDescription");
  /**
   * Computes the set of conflicting or ambiguous alternatives from a
   * configuration set, if that information was not already provided by the
   * parser.
   *
   * @param reportedAlts The set of conflicting or ambiguous alternatives, as
   * reported by the parser.
   * @param configs The conflicting or ambiguous configuration set.
   * @returns Returns `reportedAlts` if it is not `null`, otherwise
   * returns the set of alternatives represented in `configs`.
   */
  getConflictingAlts = /* @__PURE__ */ __name((reportedAlts, configs) => {
    if (reportedAlts) {
      return reportedAlts;
    }
    const result = new BitSet();
    for (let i = 0; i < configs.configs.length; i++) {
      result.set(configs.configs[i].alt);
    }
    return result;
  }, "getConflictingAlts");
};

// src/LexerInterpreter.ts
var LexerInterpreter = class extends Lexer {
  static {
    __name(this, "LexerInterpreter");
  }
  decisionToDFA;
  sharedContextCache = new PredictionContextCache();
  #grammarFileName;
  #atn;
  #ruleNames;
  #channelNames;
  #modeNames;
  #vocabulary;
  constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
    super(input);
    if (atn.grammarType !== ATN.LEXER) {
      throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
    }
    this.#grammarFileName = grammarFileName;
    this.#atn = atn;
    this.#ruleNames = ruleNames.slice(0);
    this.#channelNames = channelNames.slice(0);
    this.#modeNames = modeNames.slice(0);
    this.#vocabulary = vocabulary;
    this.decisionToDFA = atn.decisionToState.map((ds, i) => {
      return new DFA(ds, i);
    });
    this.interpreter = new LexerATNSimulator(this, atn, this.decisionToDFA, this.sharedContextCache);
  }
  get atn() {
    return this.#atn;
  }
  get grammarFileName() {
    return this.#grammarFileName;
  }
  get ruleNames() {
    return this.#ruleNames;
  }
  get channelNames() {
    return this.#channelNames;
  }
  get modeNames() {
    return this.#modeNames;
  }
  get vocabulary() {
    return this.#vocabulary;
  }
  get serializedATN() {
    throw new Error("The LexerInterpreter does not support the serializedATN property.");
  }
};

// src/RuntimeMetaData.ts
var RuntimeMetaData = class _RuntimeMetaData {
  static {
    __name(this, "RuntimeMetaData");
  }
  /**
   * A compile-time constant containing the current version of the ANTLR 4
   * runtime library.
   *
   * This compile-time constant value allows generated parsers and other
   * libraries to include a literal reference to the version of the ANTLR 4
   * runtime library the code was compiled against. At each release, we
   * change this value.
   *
   * Version numbers are assumed to have the form
   *
   * major.minor.patch.revision-suffix,
   *
   * with the individual components defined as follows.
   *
   * - major is a required non-negative integer, and is equal to `4` for ANTLR 4.
   * - minor is a required non-negative integer.
   * - patch is an optional non-negative integer. When patch is omitted, the `.` (dot) appearing before it is
   *   also omitted.
   * - revision is an optional non-negative integer, and may only be included when patch is also included.
   *   When revision is omitted, the `.` (dot) appearing before it is also omitted.
   * - suffix is an optional string. When suffix is omitted, the `-` (hyphen-minus) appearing before it is also
   *   omitted.
   */
  static VERSION = "4.13.1";
  /**
   * Gets the currently executing version of the ANTLR 4 runtime library.
   *
   * This method provides runtime access to the {@link VERSION} field, as
   * opposed to directly referencing the field as a compile-time constant.
   *
   * @returns The currently executing version of the ANTLR 4 library
   */
  static getRuntimeVersion() {
    return _RuntimeMetaData.VERSION;
  }
  /**
   * This method provides the ability to detect mismatches between the version
   * of ANTLR 4 used to generate a parser, the version of the ANTLR runtime a
   * parser was compiled against, and the version of the ANTLR runtime which
   * is currently executing.
   *
   * The version check is designed to detect the following two specific
   * scenarios.
   *
   * - The ANTLR Tool version used for code generation does not match the
   * currently executing runtime version.
   * - The ANTLR Runtime version referenced at the time a parser was
   * compiled does not match the currently executing runtime version.
   *
   *
   * Starting with ANTLR 4.3, the code generator emits a call to this method
   * using two constants in each generated lexer and parser: a hard-coded
   * constant indicating the version of the tool used to generate the parser
   * and a reference to the compile-time constant {@link VERSION}. At
   * runtime, this method is called during the initialization of the generated
   * parser to detect mismatched versions, and notify the registered listeners
   * prior to creating instances of the parser.
   *
   *
   * This method does not perform any detection or filtering of semantic
   * changes between tool and runtime versions. It simply checks for a
   * version match and emits an error to stderr if a difference
   * is detected.
   *
   *
   * Note that some breaking changes between releases could result in other
   * types of runtime exceptions, such as a {@link LinkageError}, prior to
   * calling this method. In these cases, the underlying version mismatch will
   * not be reported here. This method is primarily intended to
   * notify users of potential semantic changes between releases that do not
   * result in binary compatibility problems which would be detected by the
   * class loader. As with semantic changes, changes that break binary
   * compatibility between releases are mentioned in the release notes
   * accompanying the affected release.
   *
   *
   * **Additional note for target developers:** The version check
   * implemented by this class is designed to address specific compatibility
   * concerns that may arise during the execution of Java applications. Other
   * targets should consider the implementation of this method in the context
   * of that target's known execution environment, which may or may not
   * resemble the design provided for the Java target.
   *
   * @param generatingToolVersion The version of the tool used to generate a parser.
   * This value may be null when called from user code that was not generated
   * by, and does not reference, the ANTLR 4 Tool itself.
   * @param compileTimeVersion The version of the runtime the parser was
   * compiled against. This should always be passed using a direct reference
   * to {@link VERSION}.
   */
  static checkVersion(generatingToolVersion, compileTimeVersion) {
    const runtimeVersion = _RuntimeMetaData.VERSION;
    let runtimeConflictsWithGeneratingTool = false;
    let runtimeConflictsWithCompileTimeTool = false;
    runtimeConflictsWithGeneratingTool = runtimeVersion !== generatingToolVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(generatingToolVersion);
    runtimeConflictsWithCompileTimeTool = runtimeVersion !== compileTimeVersion && _RuntimeMetaData.getMajorMinorVersion(runtimeVersion) !== _RuntimeMetaData.getMajorMinorVersion(compileTimeVersion);
    if (runtimeConflictsWithGeneratingTool) {
      console.error(`ANTLR Tool version ${generatingToolVersion} used for code generation does not match the current runtime version ${runtimeVersion}`);
    }
    if (runtimeConflictsWithCompileTimeTool) {
      console.error(`ANTLR Runtime version ${compileTimeVersion} used for parser compilation does not match the current runtime version ${runtimeVersion}`);
    }
  }
  /**
   * Gets the major and minor version numbers from a version string. For
   * details about the syntax of the input `version`.
   * E.g., from x.y.z return x.y.
   *
   * @param version The complete version string.
   * @returns A string of the form *major*.*minor* containing
   * only the major and minor components of the version string.
   */
  static getMajorMinorVersion(version) {
    const firstDot = version.indexOf(".");
    const secondDot = firstDot >= 0 ? version.indexOf(".", firstDot + 1) : -1;
    const firstDash = version.indexOf("-");
    let referenceLength = version.length;
    if (secondDot >= 0) {
      referenceLength = Math.min(referenceLength, secondDot);
    }
    if (firstDash >= 0) {
      referenceLength = Math.min(referenceLength, firstDash);
    }
    return version.substring(0, referenceLength);
  }
};

// src/TokenStreamRewriter.ts
var TokenStreamRewriter = class _TokenStreamRewriter {
  static {
    __name(this, "TokenStreamRewriter");
  }
  static DEFAULT_PROGRAM_NAME = "default";
  static PROGRAM_INIT_SIZE = 100;
  static MIN_TOKEN_INDEX = 0;
  /** Our source stream */
  tokens;
  /**
   * You may have multiple, named streams of rewrite operations.
   *  I'm calling these things "programs."
   *  Maps String (name) -> rewrite (List)
   */
  programs = /* @__PURE__ */ new Map();
  /** Map String (program name) -> Integer index */
  lastRewriteTokenIndexes;
  /**
   * @param tokens The token stream to modify
   */
  constructor(tokens) {
    this.tokens = tokens;
  }
  getTokenStream() {
    return this.tokens;
  }
  /**
   * Insert the supplied text after the specified token (or token index)
   */
  insertAfter(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    let index;
    if (typeof tokenOrIndex === "number") {
      index = tokenOrIndex;
    } else {
      index = tokenOrIndex.tokenIndex;
    }
    const rewrites = this.getProgram(programName);
    const op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
    rewrites.push(op);
  }
  /**
   * Insert the supplied text before the specified token (or token index)
   */
  insertBefore(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    let index;
    if (typeof tokenOrIndex === "number") {
      index = tokenOrIndex;
    } else {
      index = tokenOrIndex.tokenIndex;
    }
    const rewrites = this.getProgram(programName);
    const op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
    rewrites.push(op);
  }
  /**
   * Replace the specified token with the supplied text
   */
  replaceSingle(tokenOrIndex, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    this.replace(tokenOrIndex, tokenOrIndex, text, programName);
  }
  /**
   * Replace the specified range of tokens with the supplied text.
   */
  replace(from, to, text, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    if (typeof from !== "number") {
      from = from.tokenIndex;
    }
    if (typeof to !== "number") {
      to = to.tokenIndex;
    }
    if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
      throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
    }
    const rewrites = this.getProgram(programName);
    const op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
    rewrites.push(op);
  }
  /**
   * Delete the specified range of tokens
   */
  delete(from, to, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    if (to == null) {
      to = from;
    }
    this.replace(from, to, null, programName);
  }
  getProgram(name) {
    let is = this.programs.get(name);
    if (is == null) {
      is = this.initializeProgram(name);
    }
    return is;
  }
  initializeProgram(name) {
    const is = [];
    this.programs.set(name, is);
    return is;
  }
  /**
   * @returns the text from the original tokens altered per the instructions given to this rewriter
   */
  getText(intervalOrProgram, programName = _TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
    let interval;
    if (intervalOrProgram instanceof Interval) {
      interval = intervalOrProgram;
    } else {
      interval = new Interval(0, this.tokens.size - 1);
    }
    if (typeof intervalOrProgram === "string") {
      programName = intervalOrProgram;
    }
    const rewrites = this.programs.get(programName);
    let start = interval.start;
    let stop = interval.stop;
    if (stop > this.tokens.size - 1) {
      stop = this.tokens.size - 1;
    }
    if (start < 0) {
      start = 0;
    }
    if (rewrites == null || rewrites.length === 0) {
      return this.tokens.getTextFromInterval(new Interval(start, stop));
    }
    const buf = [];
    const indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
    let i = start;
    while (i <= stop && i < this.tokens.size) {
      const op = indexToOp.get(i);
      indexToOp.delete(i);
      const t = this.tokens.get(i);
      if (op == null) {
        if (t.type !== Token.EOF) {
          buf.push(String(t.text));
        }
        i++;
      } else {
        i = op.execute(buf);
      }
    }
    if (stop === this.tokens.size - 1) {
      for (const op of indexToOp.values()) {
        if (op && op.index >= this.tokens.size - 1) {
          buf.push(String(op.text));
        }
      }
    }
    return buf.join("");
  }
  /**
   * @returns a map from token index to operation
   */
  reduceToSingleOperationPerIndex(rewrites) {
    for (let i = 0; i < rewrites.length; i++) {
      const op = rewrites[i];
      if (op == null) {
        continue;
      }
      if (!(op instanceof ReplaceOp)) {
        continue;
      }
      const rop = op;
      const inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
      for (const iop of inserts) {
        if (iop.index === rop.index) {
          rewrites[iop.instructionIndex] = null;
          rop.text = String(iop.text) + (rop.text != null ? rop.text.toString() : "");
        } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
          rewrites[iop.instructionIndex] = null;
        }
      }
      const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
      for (const prevRop of prevReplaces) {
        if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
          rewrites[prevRop.instructionIndex] = null;
          continue;
        }
        const disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
        if (prevRop.text == null && rop.text == null && !disjoint) {
          rewrites[prevRop.instructionIndex] = null;
          rop.index = Math.min(prevRop.index, rop.index);
          rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
        } else if (!disjoint) {
          throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
        }
      }
    }
    for (let i = 0; i < rewrites.length; i++) {
      const op = rewrites[i];
      if (op == null) {
        continue;
      }
      if (!(op instanceof InsertBeforeOp)) {
        continue;
      }
      const iop = op;
      const prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
      for (const prevIop of prevInserts) {
        if (prevIop.index === iop.index) {
          if (prevIop instanceof InsertAfterOp) {
            iop.text = this.catOpText(prevIop.text, iop.text);
            rewrites[prevIop.instructionIndex] = null;
          } else if (prevIop instanceof InsertBeforeOp) {
            iop.text = this.catOpText(iop.text, prevIop.text);
            rewrites[prevIop.instructionIndex] = null;
          }
        }
      }
      const prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
      for (const rop of prevReplaces) {
        if (iop.index === rop.index) {
          rop.text = this.catOpText(iop.text, rop.text);
          rewrites[i] = null;
          continue;
        }
        if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
          throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
        }
      }
    }
    const m2 = /* @__PURE__ */ new Map();
    for (const op of rewrites) {
      if (op == null) {
        continue;
      }
      if (m2.get(op.index) != null) {
        throw new Error("should only be one op per index");
      }
      m2.set(op.index, op);
    }
    return m2;
  }
  catOpText(a, b) {
    let x = "";
    let y = "";
    if (a != null) {
      x = a.toString();
    }
    if (b != null) {
      y = b.toString();
    }
    return x + y;
  }
  /**
   * Get all operations before an index of a particular kind
   */
  getKindOfOps(rewrites, kind, before) {
    return rewrites.slice(0, before).filter((op) => {
      return op && op instanceof kind;
    });
  }
};
var RewriteOperation = class {
  static {
    __name(this, "RewriteOperation");
  }
  /** What index into rewrites List are we? */
  instructionIndex;
  /** Token buffer index. */
  index;
  text;
  tokens;
  constructor(tokens, index, instructionIndex, text) {
    this.tokens = tokens;
    this.instructionIndex = instructionIndex;
    this.index = index;
    this.text = text === void 0 ? "" : text;
  }
  execute(_buf) {
    return this.index;
  }
  toString() {
    return "<RewriteOperation@" + this.tokens.get(this.index) + ':"' + this.text + '">';
  }
};
var InsertBeforeOp = class extends RewriteOperation {
  static {
    __name(this, "InsertBeforeOp");
  }
  constructor(tokens, index, instructionIndex, text) {
    super(tokens, index, instructionIndex, text);
  }
  /**
   * @returns the index of the next token to operate on
   */
  execute(buf) {
    if (this.text) {
      buf.push(this.text.toString());
    }
    if (this.tokens.get(this.index).type !== Token.EOF) {
      buf.push(String(this.tokens.get(this.index).text));
    }
    return this.index + 1;
  }
  toString() {
    return "<InsertBeforeOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
  }
};
var InsertAfterOp = class extends InsertBeforeOp {
  static {
    __name(this, "InsertAfterOp");
  }
  constructor(tokens, index, instructionIndex, text) {
    super(tokens, index + 1, instructionIndex, text);
  }
  toString() {
    return "<InsertAfterOp@" + this.tokens.get(this.index) + ':"' + this.text + '">';
  }
};
var ReplaceOp = class extends RewriteOperation {
  static {
    __name(this, "ReplaceOp");
  }
  lastIndex;
  constructor(tokens, from, to, instructionIndex, text) {
    super(tokens, from, instructionIndex, text);
    this.lastIndex = to;
  }
  /**
   * @returns the index of the next token to operate on
   */
  execute(buf) {
    if (this.text) {
      buf.push(this.text.toString());
    }
    return this.lastIndex + 1;
  }
  toString() {
    if (this.text == null) {
      return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
    }
    return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
  }
};

// src/UnbufferedTokenStream.ts
var UnbufferedTokenStream = class {
  static {
    __name(this, "UnbufferedTokenStream");
  }
  tokenSource;
  /**
   * A moving window buffer of the data being scanned. While there's a marker,
   * we keep adding to buffer. Otherwise, {@link #consume consume()} resets so
   * we start filling at index 0 again.
   */
  tokens;
  /**
   * The number of tokens currently in {@link #tokens tokens}.
   *
   * This is not the buffer capacity, that's `tokens.length`.
   */
  n;
  /**
   * 0..n-1 index into {@link #tokens tokens} of next token.
   *
   * The `LT(1)` token is `tokens[p]`. If `p == n`, we are
   * out of buffered tokens.
   */
  p = 0;
  /**
   * Count up with {@link #mark mark()} and down with
   * {@link #release release()}. When we `release()` the last mark,
   * `numMarkers` reaches 0 and we reset the buffer. Copy
   * `tokens[p]..tokens[n-1]` to `tokens[0]..tokens[(n-1)-p]`.
   */
  numMarkers = 0;
  /**
   * This is the `LT(-1)` token for the current position.
   */
  lastToken;
  /**
   * When `numMarkers > 0`, this is the `LT(-1)` token for the
   * first token in {@link #tokens}. Otherwise, this is `null`.
   */
  lastTokenBufferStart;
  /**
   * Absolute token index. It's the index of the token about to be read via
   * `LT(1)`. Goes from 0 to the number of tokens in the entire stream,
   * although the stream size is unknown before the end is reached.
   *
   * This value is used to set the token indexes if the stream provides tokens
   * that implement {@link WritableToken}.
   */
  currentTokenIndex = 0;
  constructor(tokenSource, bufferSize) {
    this.tokenSource = tokenSource;
    bufferSize = bufferSize ?? 256;
    this.tokens = new Array(bufferSize);
    this.n = 0;
    this.fill(1);
  }
  get(i) {
    const bufferStartIndex = this.getBufferStartIndex();
    if (i < bufferStartIndex || i >= bufferStartIndex + this.n) {
      throw new Error("get(" + i + ") outside buffer: " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
    }
    return this.tokens[i - bufferStartIndex];
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  LT(i) {
    if (i === -1) {
      return this.lastToken;
    }
    this.sync(i);
    const index = this.p + i - 1;
    if (index < 0) {
      throw new Error("LT(" + i + ") gives negative index");
    }
    if (index >= this.n) {
      return this.tokens[this.n - 1];
    }
    return this.tokens[index];
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  LA(i) {
    return this.LT(i).type;
  }
  getText() {
    return "";
  }
  getTextFromContext(ctx) {
    return this.getTextFromInterval(ctx.getSourceInterval());
  }
  getTextFromInterval(interval) {
    const bufferStartIndex = this.getBufferStartIndex();
    const bufferStopIndex = bufferStartIndex + this.tokens.length - 1;
    const start = interval.start;
    const stop = interval.stop;
    if (start < bufferStartIndex || stop > bufferStopIndex) {
      throw new Error("interval " + interval + " not in token buffer window: " + bufferStartIndex + ".." + bufferStopIndex);
    }
    const a = start - bufferStartIndex;
    const b = stop - bufferStartIndex;
    let result = "";
    for (let i = a; i <= b; i++) {
      const t = this.tokens[i];
      result += t.text;
    }
    return result;
  }
  getTextFromRange(start, stop) {
    return this.getTextFromInterval(Interval.of(start.tokenIndex, stop.tokenIndex));
  }
  consume() {
    if (this.LA(1) === Token.EOF) {
      throw new Error("cannot consume EOF");
    }
    this.lastToken = this.tokens[this.p];
    if (this.p === this.n - 1 && this.numMarkers === 0) {
      this.n = 0;
      this.p = -1;
      this.lastTokenBufferStart = this.lastToken;
    }
    this.p++;
    this.currentTokenIndex++;
    this.sync(1);
  }
  /**
   * Return a marker that we can release later.
   *
   * The specific marker value used for this class allows for some level of
   * protection against misuse where `seek()` is called on a mark or
   * `release()` is called in the wrong order.
   */
  mark() {
    if (this.numMarkers === 0) {
      this.lastTokenBufferStart = this.lastToken;
    }
    const mark = -this.numMarkers - 1;
    this.numMarkers++;
    return mark;
  }
  release(marker) {
    const expectedMark = -this.numMarkers;
    if (marker !== expectedMark) {
      throw new Error("release() called with an invalid marker.");
    }
    this.numMarkers--;
    if (this.numMarkers === 0) {
      if (this.p > 0) {
        this.tokens.copyWithin(0, this.p, this.n);
        this.n = this.n - this.p;
        this.p = 0;
      }
      this.lastTokenBufferStart = this.lastToken;
    }
  }
  get index() {
    return this.currentTokenIndex;
  }
  seek(index) {
    if (index === this.currentTokenIndex) {
      return;
    }
    if (index > this.currentTokenIndex) {
      this.sync(index - this.currentTokenIndex);
      index = Math.min(index, this.getBufferStartIndex() + this.n - 1);
    }
    const bufferStartIndex = this.getBufferStartIndex();
    const i = index - bufferStartIndex;
    if (i < 0) {
      throw new Error("cannot seek to negative index " + index);
    } else {
      if (i >= this.n) {
        throw new Error("seek to index outside buffer: " + index + " not in " + bufferStartIndex + ".." + (bufferStartIndex + this.n));
      }
    }
    this.p = i;
    this.currentTokenIndex = index;
    if (this.p === 0) {
      this.lastToken = this.lastTokenBufferStart;
    } else {
      this.lastToken = this.tokens[this.p - 1];
    }
  }
  get size() {
    throw new Error("Unbuffered stream cannot know its size");
  }
  getSourceName() {
    return this.tokenSource.sourceName;
  }
  setLine(line) {
    this.tokenSource.line = line;
  }
  setColumn(column) {
    this.tokenSource.column = column;
  }
  /**
   * Make sure we have 'need' elements from current position {@link #p p}. Last valid
   * `p` index is `tokens.length-1`.  `p+need-1` is the tokens index 'need' elements
   * ahead.  If we need 1 element, `(p+1-1)==p` must be less than `tokens.length`.
   */
  sync(want) {
    const need = this.p + want - 1 - this.n + 1;
    if (need > 0) {
      this.fill(need);
    }
  }
  /**
   * Add `n` elements to the buffer. Returns the number of tokens
   * actually added to the buffer. If the return value is less than `n`,
   * then EOF was reached before `n` tokens could be added.
   */
  fill(n2) {
    for (let i = 0; i < n2; i++) {
      if (this.n > 0 && this.tokens[this.n - 1].type === Token.EOF) {
        return i;
      }
      const t = this.tokenSource.nextToken();
      this.add(t);
    }
    return n2;
  }
  add(t) {
    if (this.n >= this.tokens.length) {
      this.tokens.length = this.tokens.length * 2;
    }
    if (isWritableToken(t)) {
      t.setTokenIndex(this.getBufferStartIndex() + this.n);
    }
    this.tokens[this.n++] = t;
  }
  getBufferStartIndex() {
    return this.currentTokenIndex - this.p;
  }
};


/***/ }),

/***/ "./src/analysis/analysisCoordinator.ts":
/*!*********************************************!*\
  !*** ./src/analysis/analysisCoordinator.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startAnalysis = startAnalysis;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ./documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
const pasirser_1 = __webpack_require__(/*! @kanji/pasirser */ "../pasirser/dist/index.js");
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
let diagnosticCollection;
const updateTimers = new Map();
const DEBOUNCE_DELAY_MS = 500; // 0.5s
const SEVERITY_LEVEL_MAP = {
    'Error': 0,
    'Warning': 1,
    'Information': 2,
    'Hint': 3,
    'None': 4 // 'None' の場合は何も表示しない
};
/**
 * ファイルの監視を開始し、変更に応じて解析と診断情報の更新を行う司令塔となる関数。
 * @param context 拡張機能のコンテキスト
 */
function startAnalysis(context) {
    diagnosticCollection = vscode.languages.createDiagnosticCollection('Risa/Asir');
    context.subscriptions.push(diagnosticCollection);
    // すべての言語サービスに現在の意味解析設定を適用し、診断を再実行する
    const updateAllServicesValidation = () => {
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_ANALYSIS);
        const semanticValidationEnabled = config.get(C.CONFIG_ENABLE_SEMANTIC_VALIDATION, false);
        const services = documentAnalysisManager_1.analysisManager.getAllServices();
        for (const service of services) {
            service.setSemanticValidation(semanticValidationEnabled);
            // 対応するドキュメントを見つけて診断を即時更新
            const uriString = documentAnalysisManager_1.analysisManager.getUriForService(service);
            if (uriString) {
                const document = vscode.workspace.textDocuments.find(doc => doc.uri.toString() === uriString);
                if (document) {
                    triggerUpdate(document, 0); // 0msディレイで即時実行
                }
            }
        }
    };
    // 起動時に設定を適用
    updateAllServicesValidation();
    // 設定が変更されたら、すべてのサービスに再適用
    context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration(`${C.CONFIG_SECTION_ANALYSIS}.${C.CONFIG_ENABLE_SEMANTIC_VALIDATION}`)) {
            updateAllServicesValidation();
        }
    }));
    let debounceTimer;
    const triggerUpdate = (document, debounceTime = 300) => {
        if (document.languageId !== 'rr') {
            return;
        }
        const uriString = document.uri.toString();
        if (updateTimers.has(uriString)) {
            const existingTimer = updateTimers.get(uriString);
            if (existingTimer) {
                clearTimeout(existingTimer);
            }
        }
        const timer = setTimeout(() => {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            // 設定からインクルードパスなどを取得
            const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR);
            const userIncludePaths = config.get('includePaths', []);
            const userLoadPaths = config.get('loadPaths', []);
            let workspaceRoot;
            const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
            if (workspaceFolder) {
                workspaceRoot = workspaceFolder.uri.fsPath;
            }
            const finalLoadPaths = workspaceRoot ? [workspaceRoot, ...userLoadPaths] : userLoadPaths;
            const systemIncludePaths = config.get(C.CONFIG_SYSTEM_INCLUDE_PATHS, []) || [];
            const loadPaths = config.get(C.CONFIG_LOAD_PATHS, []) || [];
            if (workspaceRoot)
                finalLoadPaths.unshift(workspaceRoot);
            service.updateDocument(document.getText(), systemIncludePaths, finalLoadPaths);
            updateDiagnostics(document.uri, service.getDiagnostics());
            updateTimers.delete(uriString);
        }, DEBOUNCE_DELAY_MS);
        updateTimers.set(uriString, timer);
    };
    // ---- イベントリスナーの登録 ----
    // ファイルが最初に開かれた時
    if (vscode.window.activeTextEditor) {
        triggerUpdate(vscode.window.activeTextEditor.document);
    }
    // ファイルを切り替えた時
    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {
        if (editor) {
            triggerUpdate(editor.document);
        }
    }));
    // ファイルが変更された時
    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(event => {
        triggerUpdate(event.document);
    }));
    // ファイルが閉じられた時
    context.subscriptions.push(vscode.workspace.onDidCloseTextDocument(doc => {
        documentAnalysisManager_1.analysisManager.removeService(doc.uri);
        diagnosticCollection.delete(doc.uri);
        const uriString = doc.uri.toString();
        if (updateTimers.has(uriString)) {
            clearTimeout(updateTimers.get(uriString));
            updateTimers.delete(uriString);
        }
    }));
}
/**
 * Pasirserの診断情報をVSCodeの形式に変換し、UIを更新する。
 * @param uri 対象ドキュメントのURI
 * @param pasirserDiagnostics Pasirserから受け取った診断情報の配列
 */
function updateDiagnostics(uri, pasirserDiagnostics) {
    const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_DIAGNOSTICS);
    const minimumSeveritySetting = config.get(C.CONFIG_DIAGNOSTICS_MINIMUM_SEVERITY, 'Hint');
    const minimumSeverityValue = SEVERITY_LEVEL_MAP[minimumSeveritySetting] ?? 3; // デフォルトはHint
    const vscodeDiagnostics = pasirserDiagnostics
        .filter(d => {
        // 'None' が設定されている場合は、すべての診断をフィルタリング
        if (minimumSeverityValue === SEVERITY_LEVEL_MAP['None']) {
            return false;
        }
        // PasirserDiagnostic の severity を数値にマッピング
        const diagnosticSeverityValue = SEVERITY_LEVEL_MAP[pasirser_1.DiagnosticSeverity[d.severity]] ?? 3; // PasirserDiagnosticSeverityを文字列に変換して比較
        return diagnosticSeverityValue <= minimumSeverityValue;
    })
        .map(d => {
        const range = new vscode.Range(d.range.start.line - 1, d.range.start.character, d.range.end.line - 1, d.range.end.character);
        let severity;
        switch (d.severity) {
            case pasirser_1.DiagnosticSeverity.Error:
                severity = vscode.DiagnosticSeverity.Error;
                break;
            case pasirser_1.DiagnosticSeverity.Warning:
                severity = vscode.DiagnosticSeverity.Warning;
                break;
            case pasirser_1.DiagnosticSeverity.Information:
                severity = vscode.DiagnosticSeverity.Information;
                break;
            case pasirser_1.DiagnosticSeverity.Hint:
                severity = vscode.DiagnosticSeverity.Hint;
                break;
            default:
                severity = vscode.DiagnosticSeverity.Warning;
        }
        const diagnostic = new vscode.Diagnostic(range, d.message, severity);
        diagnostic.source = d.source;
        if (d.tags) {
            console.log(`[Diagnostics] Applying tags to "${d.message}":`, d.tags);
            diagnostic.tags = d.tags.map(tag => {
                if (tag === 1)
                    return vscode.DiagnosticTag.Unnecessary;
                if (tag === 2)
                    return vscode.DiagnosticTag.Deprecated;
                return vscode.DiagnosticTag.Deprecated;
            });
        }
        return diagnostic;
    });
    diagnosticCollection.set(uri, vscodeDiagnostics);
}


/***/ }),

/***/ "./src/analysis/documentAnalysisManager.ts":
/*!*************************************************!*\
  !*** ./src/analysis/documentAnalysisManager.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.analysisManager = exports.DocumentAnalysisManager = void 0;
const pasirser_1 = __webpack_require__(/*! @kanji/pasirser */ "../pasirser/dist/index.js");
/**
 * 開かれているドキュメントごとにLanguageServiceのインスタンスを管理し、
 * 解析処理を一元的に担うクラス。
 */
class DocumentAnalysisManager {
    services = new Map();
    /**
     * 指定されたドキュメントに対応するLanguageServiceインスタンスを取得または作成する。
     * @param uri ドキュメントのURI
     * @returns LanguageServiceのインスタンス
     */
    getService(uri) {
        const uriString = uri.toString();
        let service = this.services.get(uriString);
        if (!service) {
            service = new pasirser_1.LanguageService(uri.fsPath);
            this.services.set(uriString, service);
        }
        return service;
    }
    /**
     * ドキュメントが閉じられた際に、関連するサービスを破棄する。
     * @param uri 閉じられたドキュメントのURI
     */
    removeService(uri) {
        this.services.delete(uri.toString());
    }
    /**
     * 管理しているすべてのLanguageServiceインスタンスの配列を返す。
     * @returns LanguageServiceのインスタンスの配列
     */
    getAllServices() {
        return Array.from(this.services.values());
    }
    /**
     * 指定されたLanguageServiceインスタンスに対応するURI文字列を返す。
     * @param service 検索対象のLanguageServiceインスタンス
     * @returns URI文字列、見つからなければundefined
     */
    getUriForService(service) {
        for (const [uri, s] of this.services.entries()) {
            if (s === service) {
                return uri;
            }
        }
        return undefined;
    }
    /**
     * すべてのサービスを破棄する。
     */
    dispose() {
        this.services.clear();
    }
}
exports.DocumentAnalysisManager = DocumentAnalysisManager;
// シングルトンインスタンスとしてエクスポート
exports.analysisManager = new DocumentAnalysisManager();


/***/ }),

/***/ "./src/commands/debugCommand.ts":
/*!**************************************!*\
  !*** ./src/commands/debugCommand.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debugTerminalClosedResolve = exports.debugTerminalClosedPromise = void 0;
exports.registerDebugCommands = registerDebugCommands;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
const helper_1 = __webpack_require__(/*! ../utils/helper */ "./src/utils/helper.ts");
let currentAsirTerminal = null;
function registerDebugCommands(context, asirOutputChannel, startSessionStatusBarItem, stopSessionStatusBarItem) {
    let disposableStartAsirDebug = vscode.commands.registerCommand(C.COMMAND_START_ASIR_INTERACTIVE, async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showInformationMessage('No active text editor to debug Risa/Asir code from.');
            return;
        }
        const document = editor.document;
        const selection = editor.selection;
        const codeToDebug = document.getText(selection.isEmpty ? undefined : selection);
        if (codeToDebug.trim().length === 0) {
            vscode.window.showInformationMessage('No code selected or current line is empty for debugging.');
            return;
        }
        const tempDir = os.tmpdir();
        const uniqueId = Math.random().toString(36).substring(2, 15);
        const tempFileName = `vscode_asir_debug_${uniqueId}.rr`;
        const windowsTempFilePath = path.join(tempDir, tempFileName);
        try {
            fs.writeFileSync(windowsTempFilePath, codeToDebug + '\n', 'utf8');
        }
        catch (error) {
            vscode.window.showErrorMessage(`Failed to save temporary file for debugging: ${error.message}`);
            return;
        }
        if (!currentAsirTerminal) {
            vscode.window.showInformationMessage('Starting Risa/Asir debug session...');
            const resourceUri = editor.document.uri;
            const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, resourceUri);
            const debugStartupDelay = config.get(C.CONFIG_DEBUG_STARTUP_DELAY, 3000);
            let commandLine;
            const currentOsPlatform = process.platform;
            if (currentOsPlatform === 'win32') {
                const useWslFromWindows = config.get(C.CONFIG_USE_WSL, false);
                if (useWslFromWindows) {
                    const wslDistribution = config.get(C.CONFIG_WSL_DISTRIBUTION, 'Ubuntu');
                    const asirPathLinux = config.get(C.CONFIG_ASIR_PATH_LINUX, 'asir');
                    const bashCommand = `script -q -c '${asirPathLinux}' /dev/null ; exit`;
                    commandLine = `wsl -d ${wslDistribution} -e bash -c "${bashCommand}"`;
                }
                else {
                    const asirPathWindows = config.get(C.CONFIG_ASIR_PATH_WINDOWS, 'asir.exe');
                    commandLine = `"${asirPathWindows}" ; exit`;
                }
            }
            else if (currentOsPlatform === 'darwin' || currentOsPlatform === 'linux') {
                const asirPath = currentOsPlatform === 'darwin' ? config.get(C.CONFIG_ASIR_PATH_MAC, 'asir') : config.get(C.CONFIG_ASIR_PATH_LINUX, 'asir');
                commandLine = `stdbuf -o0 "${asirPath}" ; exit`;
            }
            else {
                vscode.window.showErrorMessage(`Unsupported OS platform: ${currentOsPlatform}`);
                fs.unlinkSync(windowsTempFilePath);
                return;
            }
            currentAsirTerminal = vscode.window.createTerminal({
                name: 'Risa/Asir Interactive',
                shellPath: undefined,
                shellArgs: [],
                cwd: resourceUri ? path.dirname(resourceUri.fsPath) : (vscode.workspace.workspaceFolders?.[0]?.uri.fsPath),
                hideFromUser: false
            });
            context.subscriptions.push(currentAsirTerminal);
            context.subscriptions.push(vscode.window.onDidCloseTerminal(e => {
                if (e === currentAsirTerminal) {
                    vscode.window.showInformationMessage('Risa/Asir debug session terminal closed.');
                    currentAsirTerminal = null;
                    startSessionStatusBarItem.show();
                    stopSessionStatusBarItem.hide();
                    try {
                        fs.unlinkSync(windowsTempFilePath);
                    }
                    catch (err) {
                        console.error(`Failed to delete temporary file: ${err}`);
                    }
                    if (exports.debugTerminalClosedResolve) {
                        (0, exports.debugTerminalClosedResolve)();
                        exports.debugTerminalClosedResolve = undefined;
                        exports.debugTerminalClosedPromise = undefined;
                    }
                }
            }));
            currentAsirTerminal.show(true);
            startSessionStatusBarItem.hide();
            stopSessionStatusBarItem.show();
            currentAsirTerminal.sendText(commandLine);
            await new Promise(resolve => setTimeout(resolve, debugStartupDelay));
        }
        else {
            vscode.window.showInformationMessage('Existing Risa/Asir debug session found. Loading code into it.');
            currentAsirTerminal.show(true);
            const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, editor.document.uri);
            const debugStartupDelay = config.get(C.CONFIG_DEBUG_STARTUP_DELAY, 500);
            await new Promise(resolve => setTimeout(resolve, debugStartupDelay > 0 ? debugStartupDelay / 2 : 500));
        }
        let loadCommand;
        const currentOsPlatform = process.platform;
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, document.uri);
        const useWslFromWindows = config.get(C.CONFIG_USE_WSL, false);
        if (currentOsPlatform === 'win32' && useWslFromWindows) {
            const wslTempFilePath = (0, helper_1.convertWindowsPathToWsl)(windowsTempFilePath);
            loadCommand = `load("${wslTempFilePath}");`;
        }
        else {
            loadCommand = `load("${windowsTempFilePath.replace(/\\/g, '/')}");`;
        }
        asirOutputChannel.appendLine(`> ${loadCommand}`);
        currentAsirTerminal.sendText(loadCommand);
        await new Promise(resolve => setTimeout(resolve, 500));
        const debugStartupDelay = config.get(C.CONFIG_DEBUG_STARTUP_DELAY, 3000);
        vscode.window.showInformationMessage('Code loaded for debugging. Call your function (e.g., `myfunc(1);`) in the "Risa/Asir Debug" terminal and use Ctrl+C then "d" to enter debug mode.' +
            ` If loading fails, try increasing the "Risa/Asir Executor: Debug Startup Delay" setting (currently ${debugStartupDelay}ms).`);
        exports.debugTerminalClosedPromise = new Promise(resolve => {
            exports.debugTerminalClosedResolve = resolve;
        });
        await exports.debugTerminalClosedPromise;
    });
    context.subscriptions.push(disposableStartAsirDebug);
    let disposableStopAsirInteractive = vscode.commands.registerCommand(C.COMMAND_STOP_ASIR_INTERACTIVE, async () => {
        if (!currentAsirTerminal) {
            vscode.window.showInformationMessage('No Risa/Asir debug session is currently running.');
            return;
        }
        vscode.window.showInformationMessage('Stopping Risa/Asir debug session...');
        asirOutputChannel.appendLine('--- Sending \'quit;\' to Risa/Asir debug terminal ---');
        currentAsirTerminal.sendText('quit;');
        const terminalClosedByQuit = new Promise(resolve => {
            let disposableListener = vscode.window.onDidCloseTerminal(e => {
                if (e === currentAsirTerminal) {
                    disposableListener.dispose();
                    resolve();
                }
            });
        });
        const timeout = new Promise(resolve => setTimeout(resolve, 5000));
        await Promise.race([terminalClosedByQuit, timeout]);
        if (currentAsirTerminal) {
            vscode.window.showWarningMessage('Risa/Asir debug terminal did not close gracefully. Disposing it forcefully.');
            asirOutputChannel.appendLine(`--- Forcing termination of Risa/Asir debug terminal... ---`);
            currentAsirTerminal.dispose();
        }
        vscode.window.showInformationMessage('Risa/Asir debug session stopped.');
    });
    context.subscriptions.push(disposableStopAsirInteractive);
}


/***/ }),

/***/ "./src/commands/executionManager.ts":
/*!******************************************!*\
  !*** ./src/commands/executionManager.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerExecutionCommands = registerExecutionCommands;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const util_1 = __webpack_require__(/*! util */ "util");
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
const helper_1 = __webpack_require__(/*! ../utils/helper */ "./src/utils/helper.ts");
const webviewUtils_1 = __webpack_require__(/*! ../utils/webviewUtils */ "./src/utils/webviewUtils.ts");
// This is a workaround to check if a debug session is active.
// A better approach would be to have a centralized state manager.
let currentAsirTerminal = null;
vscode.window.onDidOpenTerminal(t => {
    if (t.name === 'Risa/Asir Interactive') {
        currentAsirTerminal = t;
    }
});
vscode.window.onDidCloseTerminal(t => {
    if (t === currentAsirTerminal) {
        currentAsirTerminal = null;
    }
});
class ExecutionManager {
    process = null;
    context;
    asirOutputChannel;
    asirCancelStatusBarItem;
    constructor(context, asirOutputChannel, asirCancelStatusBarItem) {
        this.context = context;
        this.asirOutputChannel = asirOutputChannel;
        this.asirCancelStatusBarItem = asirCancelStatusBarItem;
    }
    isBusy() {
        return this.process !== null;
    }
    dispose() {
        this.cancel();
    }
    cancel() {
        if (!this.process) {
            return;
        }
        this.asirOutputChannel.appendLine(`--- Cancelling Risa/Asir normal execution process... ---`);
        try {
            const pid = this.process.pid;
            if (pid) {
                if (process.platform === 'win32') {
                    (0, child_process_1.spawn)('taskkill', ['/F', '/T', '/PID', pid.toString()]);
                }
                else {
                    process.kill(-pid, 'SIGKILL');
                }
                vscode.window.showInformationMessage('Risa/Asir normal execution cancelled.');
                this.asirOutputChannel.appendLine(`--- Risa/Asir normal execution successfully cancelled ---`);
            }
        }
        catch (error) {
            console.error('Error during Risa/Asir cancellation:', error);
            vscode.window.showErrorMessage(`Failed to cancel Risa/Asir: ${error.message}.`);
        }
        finally {
            this.process = null;
            this.asirCancelStatusBarItem.hide();
        }
    }
    async start(textToExecute, document) {
        let tempFilePath;
        let cleanupTempFile;
        try {
            ({ tempFilePath, cleanupTempFile } = this._prepareExecution(textToExecute));
            const { command, args, options, displayMessage } = this._buildSpawnArguments(tempFilePath, document);
            await this._launchAndMonitorProcess(command, args, options, displayMessage, textToExecute, cleanupTempFile);
        }
        catch (error) {
            this.process = null;
            this.asirCancelStatusBarItem.hide();
            this.asirOutputChannel.appendLine(`General error during Risa/Asir execution: ${error.message}`);
            vscode.window.showErrorMessage(`An unexpected error occured during Risa/Asir exection: ${error.message}`);
            (0, webviewUtils_1.createResultWebview)(this.context, textToExecute, '', error.message);
        }
    }
    _prepareExecution(textToExecute) {
        const tempDir = os.tmpdir();
        const uniqueId = Math.random().toString(36).substring(2, 15);
        const tempFileName = `vscode_asir_exec_temp_${uniqueId}.rr`;
        const tempFilePath = path.join(tempDir, tempFileName);
        try {
            fs.writeFileSync(tempFilePath, textToExecute + '\n', 'utf8');
        }
        catch (error) {
            vscode.window.showErrorMessage(`Failed to save temporary file for execution: ${error.message}`);
            throw error;
        }
        const cleanupTempFile = () => {
            try {
                fs.unlinkSync(tempFilePath);
            }
            catch (err) {
                console.error(`Failed to delete temporary file: ${err}`);
            }
        };
        return { tempFilePath, cleanupTempFile };
    }
    _buildSpawnArguments(tempFilePath, document) {
        let workspaceRoot;
        const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
        if (workspaceFolder) {
            workspaceRoot = workspaceFolder.uri.fsPath;
        }
        else if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;
        }
        else {
            workspaceRoot = path.dirname(document.uri.fsPath);
        }
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, document.uri);
        let command;
        let args = [];
        let displayMessage;
        let options = { cwd: workspaceRoot };
        const currentOsPlatform = process.platform;
        if (currentOsPlatform === 'win32') {
            const useWslFromWindows = config.get(C.CONFIG_USE_WSL, false);
            if (useWslFromWindows) {
                const wslDistribution = config.get(C.CONFIG_WSL_DISTRIBUTION, 'Ubuntu');
                const asirPathLinux = config.get(C.CONFIG_ASIR_PATH_LINUX, 'asir');
                const wslTempFilePath = (0, helper_1.convertWindowsPathToWsl)(tempFilePath);
                const wslWorkspaceRoot = workspaceRoot ? (0, helper_1.convertWindowsPathToWsl)(workspaceRoot) : '.';
                command = 'wsl';
                const bashCommandString = `bash -c " cd '${wslWorkspaceRoot}' && ${asirPathLinux} -quiet -f '${wslTempFilePath}'"`;
                args = ['-d', wslDistribution, bashCommandString];
                displayMessage = `Executing Risa/Asir WSL (${wslDistribution})...`;
                options.shell = true;
            }
            else {
                const asirPathWindows = config.get(C.CONFIG_ASIR_PATH_WINDOWS);
                command = asirPathWindows;
                args = ['-quiet', '-f', tempFilePath];
                displayMessage = 'Executing Risa/Asir on Windows natively...';
                options.shell = false;
            }
        }
        else if (currentOsPlatform === 'darwin' || currentOsPlatform === 'linux') {
            const asirPath = currentOsPlatform === 'darwin' ? config.get(C.CONFIG_ASIR_PATH_MAC, 'asir') : config.get(C.CONFIG_ASIR_PATH_LINUX, 'asir');
            command = asirPath;
            args = ['-quiet', '-f', tempFilePath];
            displayMessage = `Executing Risa/Asir on ${currentOsPlatform}...`;
            options.detached = true;
            options.shell = true;
        }
        else {
            throw new Error(`Unsupported OS platform: ${currentOsPlatform}`);
        }
        options.maxBuffer = 1024 * 1024 * 100;
        return { command, args, options, displayMessage };
    }
    _launchAndMonitorProcess(command, args, options, displayMessage, originalText, cleanup) {
        return new Promise((resolve, reject) => {
            this.asirOutputChannel.clear();
            this.asirOutputChannel.show(true);
            this.asirOutputChannel.appendLine(`--- ${displayMessage} ---`);
            this.asirCancelStatusBarItem.show();
            this.process = (0, child_process_1.spawn)(command, args, options);
            let outputAccumulator = '';
            let errorAccumulator = '';
            this.process.stdout.on('data', (data) => {
                const decodedString = (process.platform === 'win32' && !options.shell)
                    ? new util_1.TextDecoder('shift-jis').decode(data)
                    : data.toString();
                outputAccumulator += decodedString;
                this.asirOutputChannel.append(decodedString);
            });
            this.process.stderr.on('data', (data) => {
                const errorString = (process.platform === 'win32' && !options.shell)
                    ? new util_1.TextDecoder('shift-jis').decode(data)
                    : data.toString();
                errorAccumulator += errorString;
                this.asirOutputChannel.appendLine(`Error from Risa/Asir: ${errorString}`);
            });
            this.process.on('close', (code) => {
                this.process = null;
                this.asirCancelStatusBarItem.hide();
                cleanup();
                let finalErrorMessage = errorAccumulator;
                let isSuccessfulExit = false;
                const errorLines = errorAccumulator.split('\n');
                const filteredErrorLines = [];
                const timeOutputLines = [];
                const timeRegex = /^\s*[\d\.\-\+eE]+sec(\s*\([\d\.\-\+eE]+sec\))?\s*$/;
                for (const line of errorLines) {
                    if (line.trim().length > 0 && timeRegex.test(line)) {
                        timeOutputLines.push(line);
                    }
                    else {
                        filteredErrorLines.push(line);
                    }
                }
                if (timeOutputLines.length > 0) {
                    const timeOutput = timeOutputLines.join('\n');
                    if (outputAccumulator.length > 0 && !outputAccumulator.endsWith('\n')) {
                        outputAccumulator += '\n';
                    }
                    outputAccumulator += timeOutput;
                }
                finalErrorMessage = filteredErrorLines.join('\n').trim();
                const normalQuitMessage = [
                    /(^|\s)Calling the registered quit callbacks\.\.\.done\.(\s|$)/gm,
                    /(^|\s)return to toplevel(\s|$)/gm
                ];
                normalQuitMessage.forEach(regex => {
                    if (finalErrorMessage.match(regex)) {
                        finalErrorMessage = finalErrorMessage.replace(regex, '').trim();
                    }
                });
                if (errorAccumulator.length > 0 && finalErrorMessage.length === 0) {
                    isSuccessfulExit = true;
                }
                const CANCELLATION_CODES_WIN = [3221225786];
                const CANCELLATION_CODES_UNIX = [130, 143];
                const isCancelledExit = ((typeof code === 'number' && process.platform === 'win32' && CANCELLATION_CODES_WIN.includes(code)) ||
                    (typeof code === 'number' && (process.platform === 'linux' || process.platform === 'darwin') && CANCELLATION_CODES_UNIX.includes(code)));
                if (isSuccessfulExit || (code === 0 && finalErrorMessage.length === 0)) {
                    this.asirOutputChannel.appendLine(`--- Risa/Asir execution finished successfully ---`);
                }
                else if (typeof code !== 'number' || (code !== 0 && !isCancelledExit)) {
                    this.asirOutputChannel.appendLine(`--- Risa/Asir process exited with code ${code} (Error) ---`);
                    vscode.window.showErrorMessage(`Risa/Asir execution failed with code ${code}. Check 'Risa/Asir CLI Output' for details.`);
                }
                (0, webviewUtils_1.createResultWebview)(this.context, originalText, outputAccumulator, finalErrorMessage);
                resolve();
            });
            this.process.on('error', (err) => {
                this.process = null;
                this.asirCancelStatusBarItem.hide();
                cleanup();
                this.asirOutputChannel.appendLine(`Failed to start Risa/Asir process: ${err.message}`);
                vscode.window.showErrorMessage(`Failed to start Risa/Asir: ${err.message}. Check if Risa/Asir is installed correctly and path is set in settings.`);
                (0, webviewUtils_1.createResultWebview)(this.context, originalText, '', err.message);
                reject(err);
            });
        });
    }
}
function registerExecutionCommands(context, asirOutputChannel, asirCancelStatusBarItem, getSessionManager) {
    const manager = new ExecutionManager(context, asirOutputChannel, asirCancelStatusBarItem);
    context.subscriptions.push(manager);
    context.subscriptions.push(vscode.commands.registerCommand(C.COMMAND_EXECUTE_CODE, async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showInformationMessage('No active text editor to execute Risa/Asir code.');
            return;
        }
        const document = editor.document;
        const selection = editor.selection;
        const textToExecute = document.getText(selection.isEmpty ? undefined : selection);
        if (textToExecute.trim().length === 0) {
            vscode.window.showInformationMessage('No code selected or current line is empty.');
            return;
        }
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, document.uri);
        const sessionManager = getSessionManager();
        const useSessionMode = config.get(C.CONFIG_USE_SESSION_MODE, false);
        if (currentAsirTerminal) {
            vscode.window.showInformationMessage('sending code to active Risa/Asir debug session.');
            currentAsirTerminal.sendText(textToExecute + '\n'); // Also add newline here
            currentAsirTerminal.show(true);
            return;
        }
        if (useSessionMode && sessionManager.status === 'active') {
            asirOutputChannel.clear();
            asirOutputChannel.show(true);
            asirOutputChannel.appendLine(`--- Executing in persistent Asir session ---`);
            asirOutputChannel.appendLine(`> ${textToExecute}`);
            try {
                const result = await sessionManager.execute(textToExecute);
                asirOutputChannel.appendLine(`[Session RESULT] ${result}`);
                (0, webviewUtils_1.createResultWebview)(context, textToExecute, result, '');
            }
            catch (error) {
                const errorMessage = error.message || 'An unknown error occurred.';
                vscode.window.showErrorMessage(errorMessage);
                asirOutputChannel.appendLine(`[Session ERROR] ${errorMessage}`);
                (0, webviewUtils_1.createResultWebview)(context, textToExecute, '', errorMessage);
            }
        }
        else if (useSessionMode) {
            vscode.window.showWarningMessage('Asir session is not active. Please start it first or disable session mode.');
            return;
        }
        else {
            if (manager.isBusy()) {
                vscode.window.showWarningMessage('A Risa/Asir execution is already running. Please cancel it first.', 'Cancel')
                    .then(selection => {
                    if (selection === 'Cancel') {
                        vscode.commands.executeCommand(C.COMMAND_CANCEL_EXECUTION);
                    }
                });
                return;
            }
            await manager.start(textToExecute, document);
        }
    }));
    context.subscriptions.push(vscode.commands.registerCommand(C.COMMAND_CANCEL_EXECUTION, () => {
        manager.cancel();
    }));
}


/***/ }),

/***/ "./src/commands/switchModeCommand.ts":
/*!*******************************************!*\
  !*** ./src/commands/switchModeCommand.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateStatusBarMode = updateStatusBarMode;
exports.registerSwitchModeCommand = registerSwitchModeCommand;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
/**
 * ステータスバーの実行モード表示を更新します。
 * @param context 拡張機能のコンテキスト
 * @param asirModeStatusBarItem 更新対象のステータスバーアイテム
 */
async function updateStatusBarMode(context, asirModeStatusBarItem) {
    const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, null);
    const useWsl = config.get(C.CONFIG_USE_WSL, false);
    if (process.platform === 'win32') {
        asirModeStatusBarItem.command = C.COMMAND_SWITCH_EXECUTION_MODE;
        asirModeStatusBarItem.text = `$(sync) Risa/Asir: ${useWsl ? 'WSL' : 'Windows'}`;
        asirModeStatusBarItem.tooltip = `Click to switch Risa/Asir execution mode to ${useWsl ? 'Windows Native' : 'WSL'}`;
        asirModeStatusBarItem.show();
    }
    else {
        asirModeStatusBarItem.hide();
    }
}
/**
 * 実行モードを切り替えるコマンドを登録します。
 * @param context 拡張機能のコンテキスト
 * @param asirModeStatusBarItem 更新対象のステータスバーアイテム
 */
function registerSwitchModeCommand(context, asirModeStatusBarItem) {
    let disposableToggleMode = vscode.commands.registerCommand(C.COMMAND_SWITCH_EXECUTION_MODE, async () => {
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR, null);
        const currentModeIsWsl = config.get(C.CONFIG_USE_WSL, false);
        const newModeIsWsl = !currentModeIsWsl;
        await config.update(C.CONFIG_USE_WSL, newModeIsWsl, vscode.ConfigurationTarget.Workspace);
        updateStatusBarMode(context, asirModeStatusBarItem); // ステータスバーを更新
        vscode.window.showInformationMessage(`Risa/Asir execution mode switched to: ${newModeIsWsl ? 'WSL' : 'Windows Native'}`);
    });
    context.subscriptions.push(disposableToggleMode);
}


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.COMMAND_INTERRUPT_EXECUTION = exports.COMMAND_SWITCH_SESSION_MODE = exports.COMMAND_STOP_ASIR_INTERACTIVE = exports.COMMAND_START_ASIR_INTERACTIVE = exports.COMMAND_SWITCH_EXECUTION_MODE = exports.COMMAND_CANCEL_EXECUTION = exports.COMMAND_EXECUTE_CODE = exports.COMMAND_HELLO_WORLD = exports.CONFIG_LOAD_PATHS = exports.CONFIG_SYSTEM_INCLUDE_PATHS = exports.CONFIG_DIAGNOSTICS_MINIMUM_SEVERITY = exports.CONFIG_ENABLE_SEMANTIC_VALIDATION = exports.CONFIG_USE_SESSION_MODE = exports.CONFIG_DEBUG_STARTUP_DELAY = exports.CONFIG_WSL_DISTRIBUTION = exports.CONFIG_USE_WSL = exports.CONFIG_ASIR_PATH_MAC = exports.CONFIG_ASIR_PATH_LINUX = exports.CONFIG_ASIR_PATH_WINDOWS = exports.CONFIG_SECTION_DIAGNOSTICS = exports.CONFIG_SECTION_ANALYSIS = exports.CONFIG_SECTION_EXECUTOR = void 0;
// Configuration Sections
exports.CONFIG_SECTION_EXECUTOR = 'risaasirExecutor';
exports.CONFIG_SECTION_ANALYSIS = 'risaasir.analysis';
exports.CONFIG_SECTION_DIAGNOSTICS = 'risaasir.diagnostics';
// Configuration Keys
exports.CONFIG_ASIR_PATH_WINDOWS = 'asirPathWindows';
exports.CONFIG_ASIR_PATH_LINUX = 'asirPathLinux';
exports.CONFIG_ASIR_PATH_MAC = 'asirPathMac';
exports.CONFIG_USE_WSL = 'useWslFromWindows';
exports.CONFIG_WSL_DISTRIBUTION = 'wslDistribution';
exports.CONFIG_DEBUG_STARTUP_DELAY = 'debugStartupDelay';
exports.CONFIG_USE_SESSION_MODE = 'useSessionMode';
exports.CONFIG_ENABLE_SEMANTIC_VALIDATION = 'enableSemanticValidation';
exports.CONFIG_DIAGNOSTICS_MINIMUM_SEVERITY = 'minimumSeverity';
exports.CONFIG_SYSTEM_INCLUDE_PATHS = 'systemIncludePaths';
exports.CONFIG_LOAD_PATHS = 'loadPaths';
// Command IDs
exports.COMMAND_HELLO_WORLD = 'risa-enhancers.helloWorld';
exports.COMMAND_EXECUTE_CODE = 'risa_enhancers.executeCode';
exports.COMMAND_CANCEL_EXECUTION = 'risa_enhancers.cancelExecution';
exports.COMMAND_SWITCH_EXECUTION_MODE = 'risa_enhancers.switchExecutionMode';
exports.COMMAND_START_ASIR_INTERACTIVE = 'risa_enhancers.startAsirInteractive';
exports.COMMAND_STOP_ASIR_INTERACTIVE = 'risa_enhancers.stopAsirInteractive';
exports.COMMAND_SWITCH_SESSION_MODE = 'risa_enhancers.switchSessionMode';
exports.COMMAND_INTERRUPT_EXECUTION = 'risa_enhancers.interruptExecution';


/***/ }),

/***/ "./src/data/builtins.ts":
/*!******************************!*\
  !*** ./src/data/builtins.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ASIR_BUILTIN_FUNCTIONS = exports.ASIR_KEYWORDS = void 0;
exports.ASIR_KEYWORDS = [
    'if', 'while', 'for', 'return', 'break', 'continue', 'static', 'struct', 'do', 'else', 'extern',
    'def', 'endmodule', 'function', 'global', 'local', 'localf', 'module',
    'car', 'cdr', 'getopt', 'newstruct', 'map', 'pari', 'quote', 'recmap', 'timer',
    'end', 'quit', 'debug',
];
exports.ASIR_BUILTIN_FUNCTIONS = [
    'comp_f', 'div_minf', 'div_pinf', 'mul_minf', 'mul_pinf', 'sub_minf', 'sub_pinf', 'add_minf', 'add_pinf', 'hugo',
    'nnf', 'subf', 'atnum', 'qe', 'qevar', 'atl', 'compf', 'fopargs', 'fargs', 'fop', 'all', 'ex', 'simpl', 'sha1',
    'ecm_set_addcounter', 'ecm_find_match', 'separate_vect', 'sort_ktarray', 'nextvect1', 'ecm_count_order',
    'ecm_compute_all_key_homo_ff', 'ecm_sub_ff', 'ecm_chsgn_ff', 'ecm_add_ff', 'draw_string', 'draw_obj', 'clear_canvas',
    'open_canvas', 'drawcircle', 'memory_plot', 'memory_conplot', 'memory_ifplot', 'plotoverB', 'plotoverQ', 'plotoverD',
    'plotover', 'conplotQ', 'conplotB', 'conplotD', 'conplot', 'ineqnBxor', 'ineqnQxor', 'ineqnDxor', 'ineqnxor', 'ineqnBor',
    'ineqnQor', 'ineqnDor', 'ineqnor', 'ineqnBand', 'ineqnQand', 'ineqnDand', 'ineqnand', 'ineqnB', 'ineqnQ', 'ineqnD',
    'ineqn', 'ifplotB', 'ifplotQ', 'ifplotD', 'ifplot', 'polarplotD', 'polarplot', 'obj_cp', 'plot', 'ox_execute_function',
    'ox_execute_string', 'ox_evalname', 'ox_setname', 'ox_push_cmd', 'ox_push_cmo', 'ox_push_local', 'ox_push_vl',
    'ox_pops', 'ox_get', 'ox_pop0_cmo', 'ox_pop_cmo', 'ox_pop0_local', 'ox_pop_local', 'ox_pop0_string', 'ox_pop_string',
    'ox_select', 'ox_intr', 'ox_reset', 'ox_sync', 'ox_cmo_rpc', 'ox_rpc', 'ox_shutdown', 'ox_launch_generic',
    'ox_launch_nox', 'ox_launch', 'ox_flush', 'register_server', 'try_accept', 'try_connect', 'try_bind_listen',
    'ox_reduce_102', 'ox_bcast_102', 'ox_recv_102', 'ox_send_102', 'ox_get_rank_102', 'ox_reset_102', 'ox_tcp_connect_102',
    'ox_tcp_accept_102', 'ox_set_rank_102', 'generate_port', 'ox_get_serverinfo', 'ox_recv_raw_cmo', 'ox_send_raw_cmo',
    'cola', 'colx', 'colm', 'rowa', 'rowx', 'rowm', 'mfund', 'disnan', 'drint', 'rint', 'dceil', 'ceil', 'dfloor', 'floor',
    'datan', 'dacos', 'dasin', 'dexp', 'dlog', 'dtan', 'dcos', 'dsin', 'dabs', 'dsqrt', 'im2m', 'm2im', 'newimat', 'sfuhensel',
    'uhensel_incremental', 'uhensel', 'pwr_mod', 'resfmain', 'ftest', 'nullspace_ff', 'nullspace',
    'solve_linear_equation_gf2n', 'range', 'get_struct_name', 'get_element_names', 'put_element_at', 'get_element_at',
    'struct_type', 'arfreg', 'simple_is_eq', 'delete_uc', 'uc', 'vars_recursive', 'vars', 'var', 'readarray', 'ntype', 'type',
    'tstop', 'tstart', 'dcurrenttime', 'currenttime', 'cputime', 'time', 'substf', 'psubst', 'subst_quote', 'substr2np',
    'subst', 'get_function_name', 'funargs_to_quote', 'quote_to_funargs', 'flatten_quote', 'quotetotex_env', 'quotetotex',
    'quotetotex_tb', 'qt_to_bin', 'qt_to_nary', 'nbm_trest', 'nbm_rest', 'nbm_tv', 'nbm_hv', 'nbm_hp_rest', 'nbm_xky_rest',
    'nbm_hxky', 'nbm_index', 'nbm_deg', 'nbp_trest', 'nbp_tc', 'nbp_tt', 'nbp_tm', 'nbp_rest', 'nbp_hc', 'nbp_ht', 'nbp_hm',
    'harmonic_mul', 'shuffle_mul', 'qt_to_nbp', 'nqt_match', 'nqt_comp', 'nqt_weight', 'nqt_match_rewrite', 'qt_match',
    'qt_normalize', 'qt_set_weight', 'qt_set_ord', 'qt_set_coef', 'qt_is_dependent', 'qt_is_function', 'qt_is_integer',
    'qt_is_rational', 'qt_is_number', 'qt_is_coef', 'qt_is_var', 'get_quote_id', 'string_to_tb', 'tb_to_string', 'clear_tb',
    'write_to_tb', 'sub_str', 'str_chr', 'str_len', 'asciitostr', 'strtoascii', 'eval_str', 'strtov', 'rtostr', 'sprintf',
    'srcr', 'nd_res', 'res', 'prim', 'redc', 'red', 'laurent_to_rat', 'rdiff', 'ediff', 'diff', 'dn', 'nm', 'eval_quote',
    'deval', 'vtype', 'call', 'clear_handler', 'list_handler', 'add_handler', 'register_handler', 'funargs_ext', 'funargs',
    'args', 'functor', 'map', 'mapat', 'set_print_function', 'eval_variables_in_quote', 'quotetolist', 'objtoquote', 'print',
    'printf', 'get_next_fft_prime', 'rinvtest_gf2n', 'invtest_gf2n', 'bininv_gf2n', 'squaretest_gf2n', 'multest_gf2n',
    'hfmul_lm', 'fmultest', 'ksquareum', 'kmulum', 'kpwrtab_lm', 'kgeneric_pwrmod_lm', 'kpwrmod_lm', 'is_irred_ddd_gf2',
    'is_irred_gf2', 'b_find_root_gf2n', 'tracemod_gf2n', 'pwrtab_ff', 'generic_pwrmod_ff', 'pwrmod_ff', 'lazy_ff',
    'lazy_lm', 'urembymul_precomp', 'urembymul', 'ureverse', 'udecomp', 'utrunc', 'decomp', 'trunc', 'utmul_ff', 'usquare_ff',
    'umul_ff', 'utmul', 'utmul_specialmod', 'usquare_specialmod', 'umul_specialmod', 'uinv_as_power_series',
    'ureverse_inv_as_power_series', 'usquare', 'umul', 'ktmul', 'ksquare', 'kmul', 'gfpntop', 'ptogfpn', 'gf2ntovect',
    'gf2ntop', 'ptogf2n', 'sfptopsfp', 'sfptop', 'ptosfp', 'sf_log', 'sf_embed', 'sf_minipoly', 'sf_find_root',
    'sf_galois_action', 'lmptop', 'ptolmp', 'mptop', 'ptomp', 're_mv', 'ch_mv', 'mergelist', 'deglist', 'random_ff',
    'field_order_ff', 'field_type_ff', 'characteristic_ff', 'extdeg_ff', 'simp_ff', 'setmod_ff', 'sparsemod_gf2n', 'setmod',
    'mindeg', 'deg', 'coef_gf2n', 'coef', 'coef0', 'delete_vars', 'remove_vars', 'ord', 'maxblen', 'p_mag', 'ranp', 'uadj_coef',
    'reorder', 'homogeneous_part', 'homogeneous_deg', 'mul_trunc', 'quo_trunc', 'headsgn', 'urem', 'ugcd', 'srem_mod',
    'inva_mod', 'sqrm', 'sremm', 'sdivm', 'udiv', 'tdiv', 'sqr', 'gcd_gf2n', 'srem_gf2n', 'sdiv_gf2n', 'prem', 'srem', 'sdiv',
    'poke', 'peek', 'hex_dump', 'get_addr', 'send_progress', 'batch', 'gc', 'pause', 'delete_history', 'flist', 'nez', 'error3',
    'error', 'toplevel', 'nmono', 'copyright', 'version', 'heap', 'shell', 'debug', 'quit', 'end', 'getenv', 'null_command',
    'sleep', 'module_definedp', 'remove_module', 'module_list', 'set_secure_flag', 'set_secure_mode', 'chdir', 'pwd', 'cadr',
    'cddr', 'assoc', 'list', 'replca', 'replcd', 'nconc', 'length', 'reverse', 'append', 'cons', 'cdr', 'car', 'int32ton',
    'ntoint32', 'mt_load', 'mt_save', 'igcdcntl', 'igcdacc', 'igcdeuc', 'igcdbmod', 'igcdbin', 'small_jacobi', 'ishift',
    'ixor', 'ior', 'iand', 'lrandom', 'random', 'lprime', 'prime', 'fac', 'inttorat', 'inv', 'set_upfft', 'set_up2kara',
    'set_uptkara', 'set_upkara', 'ntogf2n', 'gf2nton', 'type_t_NB', 'up2_show_eg', 'up2_init_eg', 'up2_inv', 'ibin', 'ilcm',
    'igcd', 'iqr', 'irem', 'idiv', 'isqrt', 'dp_set_mpi', 'help', 'getpid', 'bload_cmo', 'bsave_cmo', 'get_rootdir', 'bload',
    'bsave', 'output', 'loadfiles', 'which', 'import', 'load', 'access', 'remove_file', 'get_line', 'put_word', 'get_word',
    'put_byte', 'get_byte', 'close_file', 'open_file', 'purge_stdin', 'fprintf', 'nfctr_mod', 'irred_check', 'ddd_tab',
    'sfgcd', 'sfmintdeg', 'sfbfctr', 'sfufctr', 'sffctr', 'sfsqfr', 'modfctr', 'modsqfr', 'agcd', 'afctr', 'sfcont', 'cont',
    'ptozp', 'ufctrhint', 'sqfr', 'lcm', 'gcdz', 'gcd', 'fctr', 'bivariate_hensel_special', 'sumi_symbolic',
    'sumi_updatepairs', 'dp_rref2', 'dpm_simplify_syz', 'dpm_insert_to_zlist', 'dpm_sp_nf', 'dpm_list_to_array',
    'dpm_schreyer_base', 'dp_mono_reduce', 'dp_mono_raddec', 'dp_compute_essential_df', 'dp_compute_last_t',
    'dp_compute_last_w_02', 'dp_compute_last_w', 'dp_minp', 'dp_tdiv', 'dp_idiv', 'dp_sep', 'dpm_redble', 'dp_redble',
    'dp_mbase', 'dpm_td', 'dp_set_sugar', 'dp_sugar', 'dp_mag', 'dp_td', 'dp_symb_add', 'dp_order', 'dp_initial_term',
    'dp_rest', 'dpm_sort', 'dpm_extract', 'dpm_split', 'dpm_shift', 'dpm_rest', 'dpm_hp', 'dpm_hc', 'dpm_ht', 'dpm_hm',
    'dpv_hc', 'dpv_ht', 'dpv_hm', 'dp_hc', 'dp_ht', 'dp_hm', 'dp_lcm', 'dp_subd', 'dp_criB', 'dp_cri2', 'dp_cri1', 'dpm_mod',
    'dpm_dehomo', 'dpm_homo', 'dpm_dtol', 'dpm_dptodpm', 'dpm_ltod', 'dp_ltod', 'dp_rat', 'dp_mod', 'dp_mdtod', 'dp_dtov',
    'dp_vtoe', 'dp_etov', 'dp_dehomo', 'dp_homo', 'dp_dtop', 'dp_ptod', 'homogenize', 'dp_gr_print', 'dp_gr_flags', 'dp_nelim',
    'dp_set_kara', 'dpv_ord', 'dpm_schreyer_frame', 'dpm_set_schreyer_level', 'dpm_set_schreyer', 'dp_ord', 'dp_sort',
    'dp_get_denomlist', 'dp_weyl_set_weight', 'dp_set_top_weight', 'dp_set_module_weight', 'dp_set_weight',
    'dp_inv_or_split', 'dp_monomial_hilbert_poincare_incremental', 'dp_monomial_hilbert_poincare', 'dp_symb_preproc',
    'dp_weyl_f4_mod_main', 'dp_weyl_f4_main', 'dp_weyl_gr_f_main', 'dp_weyl_gr_mod_main', 'dp_weyl_gr_main',
    'dp_weyl_true_nf_and_quotient_marked_mod', 'dp_weyl_true_nf_and_quotient_marked', 'dp_weyl_true_nf_and_quotient_mod',
    'dp_weyl_true_nf_and_quotient', 'dp_weyl_nf_f', 'dp_weyl_nf_mod', 'dpm_weyl_nf', 'dp_weyl_nf', 'dp_weyl_red',
    'dp_weyl_sp', 'dp_weyl_act', 'dp_weyl_mul_mod', 'dp_weyl_mul', 'dp_f4_mod_main', 'dp_f4_main', 'nd_weyl_nf',
    'nd_nf', 'nd_weyl_gr_trace', 'nd_weyl_gr', 'nd_weyl_gr_postproc', 'nd_btog', 'nd_gr_recompute_trace', 'nd_gr_postproc',
    'nd_f4_trace', 'nd_gr_trace', 'nd_weyl_sba', 'nd_sba', 'nd_gr', 'nd_f4', 'dp_gr_checklist', 'dp_gr_f_main',
    'dp_gr_mod_main', 'dp_interreduce', 'dp_gr_main', 'dp_lnf_f', 'dp_nf_tab_mod', 'dp_nf_tab_f', 'dp_lnf_mod',
    'dp_true_nf_and_quotient_marked_mod', 'dp_true_nf_and_quotient_marked', 'dp_true_nf_and_quotient_mod',
    'dp_true_nf_and_quotient', 'dp_true_lnf_mod', 'dp_true_lnf', 'dp_true_nf_marked_mod', 'dp_true_nf_marked_check_mod',
    'dp_true_nf_marked_check', 'dp_true_nf_marked', 'dp_true_nf_mod', 'dp_true_nf', 'dpm_weyl_sp', 'dpm_sp', 'dpm_nf',
    'dpm_weyl_nf_f', 'dpm_nf_f', 'dpm_nf_and_quotient2', 'dpm_nf_and_quotient', 'dp_nf_f', 'dp_nf_mod', 'dp_nf',
    'dp_red_mod', 'dp_red', 'dp_sp_mod', 'dp_sp', 'dp_quo', 'dp_mul_trunc', 'dpm_pos', 'dpm_prim', 'dpm_remove_cont',
    'dpm_ptozp', 'dp_cont', 'dp_red_coef', 'dp_prim', 'dp_ptozp2', 'dp_ptozp', 'sysinfo', 'asir_env', 'ctrl', 'imag', 'real',
    'conj', 'triangleq', 'lusolve_main', 'lusolve_prep', 'mat_col', 'mat_swap_col_destructive', 'mat_swap_row_destructive',
    'nbpoly_up2', 'irredpoly_up2', 'x962_irredpoly_up2', 'nbmul_gf2n', 'mul_mat_vect_int', 'mul_vect_mat_gf2n',
    'bconvmat_gf2n', 'mulmat_gf2n', 'sremainder', 'remainder', 'geninv_sf_swap', 'geninvm_swap', 'geninvm', 'leqm1',
    'leqm', 'invmat', 'nd_det', 'det', 'size', 'ltov', 'vtol', 'qsort', 'sepvect', 'sepmat_destructive', 'memoryplot_to_coord',
    'newbytearray', 'matc', 'matr', 'mat', 'matrix', 'newmat', 'exponent_vector', 'vector', 'vect', 'newvect',
    'indep_rows_mod', 'generic_gauss_elim_mod', 'generic_gauss_elim', 'mat_to_gfmmat', 'lu_gfmmat', 'solve_by_lu_gfmmat',
    'algv', 'alg', 'getalgtree', 'getalg', 'rattoalg', 'algtorat', 'mainalg', 'newalg', 'defpoly', 'invalg_le',
    'invalg_chrem', 'inv_or_split_dalg', 'dptodalg', 'dalgtoup', 'dalgtodp', 'dalgtoalg', 'algtodalg',
    'get_field_generator', 'get_field_defpoly', 'set_field', 'rk_ratmat', 'mpfr_round', 'mpfr_ceil', 'mpfr_floor',
    'mpfr_digamma', 'mpfr_lngamma', 'mpfr_gamma', 'mpfr_li2', 'mpfr_erfc', 'mpfr_erf', 'mpfr_eint', 'mpfr_y1', 'mpfr_y0',
    'mpfr_j1', 'mpfr_j0', 'mpfr_zeta', 'mpfr_ai', 'mpfr_pow', 'mpfr_log', 'mpfr_exp', 'mpfr_atanh', 'mpfr_acosh',
    'mpfr_asinh', 'mpfr_tanh', 'mpfr_cosh', 'mpfr_sinh', 'mpfr_atan', 'mpfr_acos', 'mpfr_asin', 'mpfr_tan', 'mpfr_cos',
    'mpfr_sin', 'todouble', 'setround', 'setbprec', 'setprec', 'eval'
];


/***/ }),

/***/ "./src/data/packages.ts":
/*!******************************!*\
  !*** ./src/data/packages.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ctrlPackages = exports.loadedPackages = void 0;
exports.loadPackageData = loadPackageData;
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
exports.loadedPackages = [];
exports.ctrlPackages = [];
function loadPackageData(context) {
    const packagesFilePath = path.join(context.extensionPath, 'data', 'packages.json');
    try {
        exports.loadedPackages = JSON.parse(fs.readFileSync(packagesFilePath, 'utf8'));
        console.log(`Loaded ${exports.loadedPackages.length} packages from ${packagesFilePath}`);
    }
    catch (error) {
        console.error(`Failed to load packages.json: ${error}`);
    }
    const ctrlPackagesFilePath = path.join(context.extensionPath, 'data', 'ctrl_packages.json');
    try {
        exports.ctrlPackages = JSON.parse(fs.readFileSync(ctrlPackagesFilePath, 'utf8'));
        console.log(`Loaded ${exports.ctrlPackages.length} ctrl packages from ${ctrlPackagesFilePath}`);
    }
    catch (error) {
        console.error(`Failed to load ctrl_packages.json: ${error}`);
    }
}


/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const C = __importStar(__webpack_require__(/*! ./constants */ "./src/constants.ts"));
// 各機能モジュールのインポート
const analysisCoordinator_1 = __webpack_require__(/*! ./analysis/analysisCoordinator */ "./src/analysis/analysisCoordinator.ts");
const completionProvider_1 = __webpack_require__(/*! ./features/completionProvider */ "./src/features/completionProvider.ts");
const wordCompletionProvider_1 = __webpack_require__(/*! ./features/wordCompletionProvider */ "./src/features/wordCompletionProvider.ts");
const hoverProvider_1 = __webpack_require__(/*! ./features/hoverProvider */ "./src/features/hoverProvider.ts");
const definitionProvider_1 = __webpack_require__(/*! ./features/definitionProvider */ "./src/features/definitionProvider.ts");
const formattingProvider_1 = __webpack_require__(/*! ./features/formattingProvider */ "./src/features/formattingProvider.ts");
const renameProvider_1 = __webpack_require__(/*! ./features/renameProvider */ "./src/features/renameProvider.ts");
const documentSymbolProvider_1 = __webpack_require__(/*! ./features/documentSymbolProvider */ "./src/features/documentSymbolProvider.ts");
const semanticTokensProvider_1 = __webpack_require__(/*! ./features/semanticTokensProvider */ "./src/features/semanticTokensProvider.ts");
const debugCommand_1 = __webpack_require__(/*! ./commands/debugCommand */ "./src/commands/debugCommand.ts");
const switchModeCommand_1 = __webpack_require__(/*! ./commands/switchModeCommand */ "./src/commands/switchModeCommand.ts");
const executionManager_1 = __webpack_require__(/*! ./commands/executionManager */ "./src/commands/executionManager.ts");
const packages_1 = __webpack_require__(/*! ./data/packages */ "./src/data/packages.ts");
const cwrapSession_1 = __webpack_require__(/*! ./utils/cwrapSession */ "./src/utils/cwrapSession.ts");
const documentAnalysisManager_1 = __webpack_require__(/*! ./analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
// --- グローバル変数の定義 ---
let sessionManager;
let asirOutputChannel;
// ステータスバーアイテム
let asirModeStatusBarItem;
let asirCancelStatusBarItem;
let executeCodeStatusBarItem;
let startSessionStatusBarItem;
let stopSessionStatusBarItem;
let sessionStatusItem;
let interruptButton;
async function activate(context) {
    console.log('Congratulations, your extension "risa-enhancers" is now active!');
    // 共通のOutputChannelを作成
    asirOutputChannel = vscode.window.createOutputChannel('Risa/Asir CLI Output');
    context.subscriptions.push(asirOutputChannel);
    const executorPath = path.join(context.extensionPath, 'bin');
    sessionManager = new cwrapSession_1.CwrapSessionManager(context, executorPath);
    // --- データファイルの読み込み (必要であれば専用モジュールへ) ---
    (0, packages_1.loadPackageData)(context);
    // --- ステータスバーアイテムの初期化と登録  ---
    initializeStatusBarItems(context);
    updateStatusBarItems(sessionManager.status);
    // 通常実行
    executeCodeStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    executeCodeStatusBarItem.command = C.COMMAND_EXECUTE_CODE;
    executeCodeStatusBarItem.text = '$(play) Execute Risa/Asir';
    executeCodeStatusBarItem.tooltip = 'Execute Risa/Asir code (Webview Output)';
    executeCodeStatusBarItem.hide();
    context.subscriptions.push(executeCodeStatusBarItem);
    // デバッグセッション開始
    startSessionStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 101);
    startSessionStatusBarItem.command = C.COMMAND_START_ASIR_INTERACTIVE;
    startSessionStatusBarItem.text = '$(terminal) Start Risa/Asir Debug Session';
    startSessionStatusBarItem.tooltip = 'Start a new Risa/Asir interactive session';
    startSessionStatusBarItem.show();
    context.subscriptions.push(startSessionStatusBarItem);
    // デバッグセッション停止
    stopSessionStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 98);
    stopSessionStatusBarItem.command = C.COMMAND_STOP_ASIR_INTERACTIVE;
    stopSessionStatusBarItem.text = '$(debug-stop) Stop Risa/Asir Debug Session';
    stopSessionStatusBarItem.tooltip = 'Stop the current Risa/Asir interactive session';
    stopSessionStatusBarItem.hide();
    context.subscriptions.push(stopSessionStatusBarItem);
    // 計算キャンセル
    asirCancelStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 99);
    asirCancelStatusBarItem.command = C.COMMAND_CANCEL_EXECUTION;
    asirCancelStatusBarItem.text = '$(stop) Cancel Risa/Asir';
    asirCancelStatusBarItem.tooltip = 'Click to cancel current Risa/Asir execution';
    asirCancelStatusBarItem.hide();
    context.subscriptions.push(asirCancelStatusBarItem);
    // WSL/Windows モード切り替えボタン
    asirModeStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
    context.subscriptions.push(asirModeStatusBarItem);
    (0, switchModeCommand_1.updateStatusBarMode)(context, asirModeStatusBarItem); // 初期設定
    context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration(`${C.CONFIG_SECTION_EXECUTOR}.${C.CONFIG_USE_WSL}`)) {
            (0, switchModeCommand_1.updateStatusBarMode)(context, asirModeStatusBarItem);
        }
    }));
    // --- 各機能の初期化と登録 ---
    (0, analysisCoordinator_1.startAnalysis)(context);
    (0, completionProvider_1.registerPackageCompletionProvider)(context);
    (0, completionProvider_1.registerSematicCompletionProvider)(context);
    (0, completionProvider_1.registerPathCompletionProvider)(context);
    (0, wordCompletionProvider_1.registerWordCompletionProvider)(context);
    (0, executionManager_1.registerExecutionCommands)(context, asirOutputChannel, asirCancelStatusBarItem, () => sessionManager);
    (0, debugCommand_1.registerDebugCommands)(context, asirOutputChannel, startSessionStatusBarItem, stopSessionStatusBarItem);
    (0, switchModeCommand_1.registerSwitchModeCommand)(context, asirModeStatusBarItem);
    (0, hoverProvider_1.registerHoverProvider)(context);
    (0, definitionProvider_1.registerDefinitionProvider)(context);
    (0, formattingProvider_1.registerFormattingProvider)(context);
    (0, renameProvider_1.registerRenameProvider)(context);
    (0, documentSymbolProvider_1.registerDocumentSymbolProvider)(context);
    (0, semanticTokensProvider_1.registerSemanticTokensProvider)(context);
    // HelloWorld コマンド
    let disposableHelloWorld = vscode.commands.registerCommand(C.COMMAND_HELLO_WORLD, () => {
        vscode.window.showInformationMessage('Hello VS Code from Risa Enhancers!');
    });
    context.subscriptions.push(disposableHelloWorld);
    // セッションモードを切り替えるコマンド
    context.subscriptions.push(vscode.commands.registerCommand(C.COMMAND_SWITCH_SESSION_MODE, async () => {
        const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR);
        const currentMode = config.get(C.CONFIG_USE_SESSION_MODE, false);
        await config.update(C.CONFIG_USE_SESSION_MODE, !currentMode, vscode.ConfigurationTarget.Global);
    }));
    // 計算を中断するコマンド
    context.subscriptions.push(vscode.commands.registerCommand(C.COMMAND_INTERRUPT_EXECUTION, () => {
        sessionManager.interrupt();
    }));
    // 設定が変更されたらセッションを再起動
    context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(async (e) => {
        if (e.affectsConfiguration(`${C.CONFIG_SECTION_EXECUTOR}.${C.CONFIG_USE_SESSION_MODE}`)) {
            await sessionManager.restart();
        }
    }));
    sessionManager.onDidChangeStatus(updateStatusBarItems);
    // 起動時にセッションモードならセッションを開始
    if (vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR).get(C.CONFIG_USE_SESSION_MODE)) {
        await sessionManager.start();
    }
}
// UI要素の初期化
function initializeStatusBarItems(context) {
    sessionStatusItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 101);
    sessionStatusItem.command = C.COMMAND_SWITCH_SESSION_MODE;
    context.subscriptions.push(sessionStatusItem);
    interruptButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 101);
    interruptButton.command = C.COMMAND_INTERRUPT_EXECUTION;
    interruptButton.text = `$(debug-stop) Interrupt Asir`;
    interruptButton.tooltip = 'Interrupt the current Asir calculation';
    context.subscriptions.push(interruptButton);
}
// UIの状態を更新
function updateStatusBarItems(status) {
    const useSessionMode = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR).get(C.CONFIG_USE_SESSION_MODE);
    sessionStatusItem.command = C.COMMAND_SWITCH_SESSION_MODE;
    if (useSessionMode) {
        switch (status) {
            case 'active':
                sessionStatusItem.text = `$(check) Asir Session: On`;
                sessionStatusItem.tooltip = 'Click to switch to Stateless mode';
                break;
            case 'starting':
                sessionStatusItem.text = `$(sync~spin) Asir Session: Starting...`;
                sessionStatusItem.tooltip = 'Session is starting';
                break;
            case 'failed':
                sessionStatusItem.text = `$(error) Asir Session: Off`;
                sessionStatusItem.tooltip = 'Session mode is on, but failed to start. Click to switch to Stateless mode.';
                break;
            case 'stopped':
            case 'stopping':
                sessionStatusItem.text = `$(circle-slash) Asir Session: Off`;
                sessionStatusItem.tooltip = 'Click to switch to Session mode';
                break;
        }
    }
    else {
        sessionStatusItem.text = `$(circle-slash) Asir Session: Off`;
        sessionStatusItem.tooltip = 'Click to switch to Session mode';
    }
    sessionStatusItem.show();
    interruptButton.hide(); // 中断ボタンは計算中に表示
}
// deactivate 
function deactivate() {
    documentAnalysisManager_1.analysisManager.dispose();
    if (asirModeStatusBarItem) {
        asirModeStatusBarItem.dispose();
    }
    if (asirCancelStatusBarItem) {
        asirCancelStatusBarItem.dispose();
    }
    if (startSessionStatusBarItem) {
        startSessionStatusBarItem.dispose();
    }
    if (stopSessionStatusBarItem) {
        stopSessionStatusBarItem.dispose();
    }
    if (executeCodeStatusBarItem) {
        executeCodeStatusBarItem.dispose();
    }
    if (sessionManager) {
        sessionManager.stop();
    }
}


/***/ }),

/***/ "./src/features/completionProvider.ts":
/*!********************************************!*\
  !*** ./src/features/completionProvider.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerPackageCompletionProvider = registerPackageCompletionProvider;
exports.registerSematicCompletionProvider = registerSematicCompletionProvider;
exports.registerPathCompletionProvider = registerPathCompletionProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const packages_1 = __webpack_require__(/*! ../data/packages */ "./src/data/packages.ts");
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
const pasirser_1 = __webpack_require__(/*! @kanji/pasirser */ "../pasirser/dist/index.js");
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
function registerPackageCompletionProvider(context) {
    const provider = vscode.languages.registerCompletionItemProvider('rr', {
        provideCompletionItems(document, position, token, context) {
            const linePrefix = document.lineAt(position).text.substring(0, position.character);
            const packageMatch = linePrefix.match(/(load|import|ctrl)\(\s*(["']([^"']*)?)?$/);
            if (!packageMatch) {
                return undefined;
            }
            const functionName = packageMatch[1];
            const typedText = packageMatch[3] || '';
            let targetPackages = [];
            if (functionName === 'load' || functionName === 'import') {
                targetPackages = packages_1.loadedPackages;
            }
            else if (functionName === 'ctrl') {
                targetPackages = packages_1.ctrlPackages;
            }
            const completionItems = [];
            targetPackages.forEach(pkg => {
                if (pkg.name.startsWith(typedText)) {
                    const item = new vscode.CompletionItem(pkg.name, vscode.CompletionItemKind.Module);
                    item.detail = pkg.description;
                    if (packageMatch[2] && (packageMatch[2].startsWith('"') || packageMatch[2].startsWith("'"))) {
                        item.insertText = pkg.name;
                    }
                    else {
                        item.insertText = new vscode.SnippetString(`"${pkg.name}"`);
                    }
                    completionItems.push(item);
                }
            });
            return completionItems;
        }
    }, '"', '\'');
    context.subscriptions.push(provider);
}
function registerSematicCompletionProvider(context) {
    const provider = vscode.languages.registerCompletionItemProvider('rr', {
        provideCompletionItems(document, position, token) {
            // 1. 解析サービスの取得
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service)
                return [];
            // 2. Pasirser にやらせる
            const semanticItems = service.getCompletions(document.getText(), {
                line: position.line,
                character: position.character
            });
            // 3. VSCode の形式に変換
            return semanticItems.map(item => {
                const vsItem = new vscode.CompletionItem(item.label);
                vsItem.kind = item.kind;
                vsItem.detail = item.detail;
                vsItem.documentation = item.documentation;
                if (item.insertText) {
                    if (item.insertTextFormat === pasirser_1.InsertTextFormat.Snippet) {
                        vsItem.insertText = new vscode.SnippetString(item.insertText);
                    }
                    else {
                        vsItem.insertText = item.insertText;
                    }
                }
                return vsItem;
            });
        }
    }, '.', ':', '>');
    context.subscriptions.push(provider);
}
function registerPathCompletionProvider(context) {
    const provider = vscode.languages.registerCompletionItemProvider('rr', {
        async provideCompletionItems(document, position) {
            const linePrefix = document.lineAt(position).text.substring(0, position.character);
            const pathMatch = linePrefix.match(/(load|import|#include)\s*\(?\s*(["'<])([^"'>]*)$/);
            if (!pathMatch) {
                return undefined;
            }
            ;
            const command = pathMatch[1];
            const delimiter = pathMatch[2];
            const userPath = pathMatch[3];
            const currentDir = path.dirname(document.fileName);
            const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR);
            const systemIncludePaths = config.get(C.CONFIG_SYSTEM_INCLUDE_PATHS, []) || [];
            const loadPaths = config.get(C.CONFIG_LOAD_PATHS, []) || [];
            const searchRoots = [];
            if (path.isAbsolute(userPath)) {
                // 絶対パスの場合はルートを考慮しない
            }
            else {
                if (delimiter === '<' && command === '#include') {
                    systemIncludePaths.forEach(p => searchRoots.push({ dir: p, type: 'System' }));
                }
                else {
                    searchRoots.push({ dir: currentDir, type: 'Relative' });
                    if (command === 'load' || command === 'import') {
                        loadPaths.forEach(p => searchRoots.push({ dir: p, type: 'LoadPath' }));
                    }
                }
            }
            const items = [];
            const scanDirectory = async (rootDir, typeLabel) => {
                let searchDir;
                let searchPrefix;
                if (path.isAbsolute(userPath)) {
                    searchDir = path.dirname(userPath);
                    searchPrefix = path.basename(userPath);
                    if (userPath.endsWith('/') || userPath.endsWith('\\')) {
                        searchDir = userPath;
                        searchPrefix = '';
                    }
                }
                else {
                    const dirPart = path.dirname(userPath);
                    searchDir = path.resolve(rootDir, dirPart);
                    searchPrefix = path.basename(userPath);
                    if (userPath.endsWith('/') || userPath.endsWith('\\')) {
                        searchDir = path.resolve(currentDir, userPath);
                        searchPrefix = '';
                    }
                }
                try {
                    if (!fs.existsSync(searchDir) || !fs.statSync(searchDir).isDirectory()) {
                        return [];
                    }
                    const entries = await fs.promises.readdir(searchDir, { withFileTypes: true });
                    for (const entry of entries) {
                        if (!entry.name.startsWith(searchPrefix))
                            continue;
                        // どっとファイルは除外
                        if (entry.name.startsWith('.') && !searchPrefix.startsWith('.'))
                            continue;
                        // ディレクトリ、.rr,.text,.hファイルのみを候補にする
                        if (entry.isDirectory() || entry.name.endsWith('.rr') || entry.name.endsWith('.txt') || entry.name.endsWith('.h')) {
                            const item = new vscode.CompletionItem(entry.name);
                            if (entry.isDirectory()) {
                                item.kind = vscode.CompletionItemKind.Folder;
                                item.command = { command: 'editor.action.triggerSuggest', title: 'Re-trigger suggestions' };
                            }
                            else {
                                item.kind = vscode.CompletionItemKind.File;
                            }
                            if (typeLabel && typeLabel !== 'Relative') {
                                item.detail = `(${typeLabel}) ${entry.name}`;
                            }
                            item.sortText = entry.isDirectory() ? `0_${entry.name}` : `1_${entry.name}`;
                            items.push(item);
                        }
                    }
                    return items;
                }
                catch (e) {
                    // エラーは無視
                }
            };
            if (path.isAbsolute(userPath)) {
                await scanDirectory('', undefined);
            }
            else {
                for (const root of searchRoots) {
                    await scanDirectory(root.dir, root.type);
                }
            }
            return items;
        }
    }, '"', '/', '\\', '<');
    context.subscriptions.push(provider);
}


/***/ }),

/***/ "./src/features/definitionProvider.ts":
/*!********************************************!*\
  !*** ./src/features/definitionProvider.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerDefinitionProvider = registerDefinitionProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
function registerDefinitionProvider(context) {
    context.subscriptions.push(vscode.languages.registerDefinitionProvider('rr', {
        provideDefinition(document, position, token) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return undefined;
            }
            const pasirserPosition = {
                line: position.line + 1,
                character: position.character
            };
            const definitionLocation = service.getDefinitionLocation(document.getText(), pasirserPosition);
            if (definitionLocation) {
                const targetUri = vscode.Uri.file(definitionLocation.filePath);
                const range = new vscode.Range(definitionLocation.startLine - 1, definitionLocation.startColumn, (definitionLocation.endLine ?? definitionLocation.startLine) - 1, definitionLocation.endColumn ?? definitionLocation.startColumn);
                return new vscode.Location(targetUri, range);
            }
            return undefined;
        }
    }));
}


/***/ }),

/***/ "./src/features/documentSymbolProvider.ts":
/*!************************************************!*\
  !*** ./src/features/documentSymbolProvider.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
// --- ヘルパー関数 ---
function toVscodeSymbolKind(kind) {
    return kind;
}
// --- メイン ---
function registerDocumentSymbolProvider(context) {
    context.subscriptions.push(vscode.languages.registerDocumentSymbolProvider('rr', {
        provideDocumentSymbols(document, token) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return [];
            }
            const symbols = service.getDocumentSymbols();
            const convertToVscodeDocumentSymbol = (pasirserSymbols) => {
                return pasirserSymbols.map(s => {
                    const range = new vscode.Range(s.range.start.line - 1, s.range.start.character, s.range.end.line - 1, s.range.end.character);
                    const selectionRange = new vscode.Range(s.selectionRange.start.line - 1, s.selectionRange.start.character, s.selectionRange.end.line - 1, s.selectionRange.end.character);
                    const vsSymbol = new vscode.DocumentSymbol(s.name, s.detail || '', toVscodeSymbolKind(s.kind), range, selectionRange);
                    if (s.children) {
                        vsSymbol.children = convertToVscodeDocumentSymbol(s.children);
                    }
                    return vsSymbol;
                });
            };
            return convertToVscodeDocumentSymbol(symbols);
        }
    }));
}


/***/ }),

/***/ "./src/features/formattingProvider.ts":
/*!********************************************!*\
  !*** ./src/features/formattingProvider.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerFormattingProvider = registerFormattingProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
function registerFormattingProvider(context) {
    context.subscriptions.push(vscode.languages.registerDocumentFormattingEditProvider('rr', {
        provideDocumentFormattingEdits(document, options, token) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return [];
            }
            const formattedText = service.formatDocument();
            if (formattedText) {
                const fullRange = new vscode.Range(document.positionAt(0), document.positionAt(document.getText().length));
                return [vscode.TextEdit.replace(fullRange, formattedText)];
            }
            return [];
        }
    }));
}


/***/ }),

/***/ "./src/features/hoverProvider.ts":
/*!***************************************!*\
  !*** ./src/features/hoverProvider.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerHoverProvider = registerHoverProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const C = __importStar(__webpack_require__(/*! ../constants */ "./src/constants.ts"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
function registerHoverProvider(context) {
    context.subscriptions.push(vscode.languages.registerHoverProvider('rr', {
        async provideHover(document, position, token) {
            // pasirser　による意味解析
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (service) {
                const info = service.getHoverInfo(document.getText(), {
                    line: position.line,
                    character: position.character
                });
                if (info) {
                    const contents = info.contents.map(c => {
                        const md = new vscode.MarkdownString(c);
                        md.isTrusted = true; // 必要に応じて
                        return md;
                    });
                    let range;
                    if (info.range) {
                        range = new vscode.Range(info.range.start.line, info.range.start.character, info.range.end.line, info.range.end.character);
                    }
                    return new vscode.Hover(contents, range);
                }
            }
            return await provideFileSummaryhover(document, position);
        }
    }));
}
/**
 * load/include されたファイルの概要表示
 */
async function provideFileSummaryhover(document, position) {
    const lineText = document.lineAt(position.line).text;
    const match = lineText.match(/(load|import|#include)\s*\(?\s*(["'<])([^"'>]*)(["'>])?/);
    if (!match)
        return undefined;
    const delimiter = match[2];
    const filePath = match[3];
    const pathIndex = lineText.indexOf(filePath);
    if (position.character < pathIndex || position.character > pathIndex + filePath.length) {
        return undefined;
    }
    const currentDir = path.dirname(document.fileName);
    const config = vscode.workspace.getConfiguration(C.CONFIG_SECTION_EXECUTOR);
    const systemIncludePaths = config.get(C.CONFIG_SYSTEM_INCLUDE_PATHS, []) || [];
    const loadPaths = config.get(C.CONFIG_LOAD_PATHS, []) || [];
    let resolvedPath = null;
    if (path.isAbsolute(filePath)) {
        if (fs.existsSync(filePath))
            resolvedPath = filePath;
    }
    else {
        const searchPaths = [];
        if (delimiter === '<') {
            searchPaths.push(...systemIncludePaths);
        }
        else {
            searchPaths.push(currentDir);
            searchPaths.push(...loadPaths);
        }
        for (const dir of searchPaths) {
            const testPath = path.resolve(dir, filePath);
            if (fs.existsSync(testPath) && fs.statSync(testPath).isFile()) {
                resolvedPath = testPath;
                break;
            }
        }
    }
    if (!resolvedPath)
        return undefined;
    try {
        const content = await fs.promises.readFile(resolvedPath, 'utf-8');
        const lines = content.split('\n');
        const dependencies = [];
        const globalFunctions = [];
        const moduleMap = new Map();
        const structs = [];
        const macros = [];
        let currentModule = null;
        for (const line of lines) {
            const trimLine = line.trim();
            if (trimLine.startsWith('//') || trimLine.startsWith('/*'))
                continue;
            let m;
            // 依存関係 (load, #include 等) の抽出
            if ((m = trimLine.match(/^(load|import|#include)\s*\(?\s*["'<]([^"'>]+)/))) {
                dependencies.push(m[2]);
                continue;
            }
            if ((m = trimLine.match(/^module\s+([a-zA-Z0-9_]+)/))) {
                currentModule = m[1];
                if (!moduleMap.has(currentModule)) {
                    moduleMap.set(currentModule, []);
                }
                continue;
            }
            if (trimLine.match(/^endmodule/)) {
                currentModule = null;
                continue;
            }
            if ((m = trimLine.match(/^def\s+([a-zA-Z0-9_]+)/))) {
                const funcName = m[1];
                if (currentModule) {
                    moduleMap.get(currentModule)?.push(funcName);
                }
                else {
                    globalFunctions.push(funcName);
                }
                continue;
            }
            if ((m = trimLine.match(/^struct\s+([a-zA-Z0-9_]+)/))) {
                structs.push(m[1]);
                continue;
            }
            if ((m = trimLine.match(/^#define\s+([a-zA-Z0-9_]+)/))) {
                macros.push(m[1]);
                continue;
            }
        }
        const md = new vscode.MarkdownString();
        md.appendMarkdown(`**File:** \`${path.basename(resolvedPath)}\`\n\n`);
        if (dependencies.length > 0) {
            md.appendMarkdown(`**Dependencies:** \`${dependencies.join('`, `')}\`\n\n`);
        }
        md.appendMarkdown(`---\n`);
        let hasContent = false;
        if (globalFunctions.length > 0) {
            md.appendMarkdown(`**Functions:** \`${globalFunctions.join(', ')}\`\n\n`);
            hasContent = true;
        }
        if (moduleMap.size > 0) {
            moduleMap.forEach((funcs, modName) => {
                md.appendMarkdown(`**Module ${modName}:** \`${funcs.join(', ')}\`\n\n`);
            });
            hasContent = true;
        }
        if (structs.length > 0) {
            md.appendMarkdown(`**Structs:** \`${structs.join(', ')}\`\n\n`);
            hasContent = true;
        }
        if (macros.length > 0) {
            md.appendMarkdown(`**Macros:** \`${macros.join(', ')}\`\n\n`);
            hasContent = true;
        }
        if (!hasContent && dependencies.length === 0) {
            md.appendMarkdown(`*(No definitions found)*`);
        }
        return new vscode.Hover(md);
    }
    catch (e) {
        return undefined;
    }
}


/***/ }),

/***/ "./src/features/renameProvider.ts":
/*!****************************************!*\
  !*** ./src/features/renameProvider.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerRenameProvider = registerRenameProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
function registerRenameProvider(context) {
    context.subscriptions.push(vscode.languages.registerRenameProvider('rr', {
        provideRenameEdits(document, position, newName, token) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return undefined;
            }
            const pasirserPosition = {
                line: position.line + 1,
                character: position.character
            };
            const renameEdits = service.getRenameEdits(document.getText(), pasirserPosition, newName);
            if (renameEdits) {
                const workspaceEdit = new vscode.WorkspaceEdit();
                const vsEdits = renameEdits.map(edit => {
                    const range = new vscode.Range(edit.range.start.line - 1, edit.range.start.character, edit.range.end.line - 1, edit.range.end.character);
                    return new vscode.TextEdit(range, edit.newText);
                });
                workspaceEdit.set(document.uri, vsEdits);
                return workspaceEdit;
            }
            return undefined;
        }
    }));
}


/***/ }),

/***/ "./src/features/semanticTokensProvider.ts":
/*!************************************************!*\
  !*** ./src/features/semanticTokensProvider.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerSemanticTokensProvider = registerSemanticTokensProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
const tokenTypes = [
    'struct',
    'module',
    'parameter',
    'variable',
    'property',
    'function',
    'macro',
    'keyword',
    'comment',
    'string',
    'number',
    'operator',
    'builtinFunction_keyword',
    'formFunction',
    'builtinFunction_default',
];
const tokenModifiers = [
    'declaration', 'definition', 'readonly', 'static', 'documentation',
];
const legend = new vscode.SemanticTokensLegend(tokenTypes, tokenModifiers);
function registerSemanticTokensProvider(context) {
    context.subscriptions.push(vscode.languages.registerDocumentSemanticTokensProvider('rr', {
        provideDocumentSemanticTokens(document, token) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return new vscode.SemanticTokens(new Uint32Array());
            }
            const tokens = service.getSemanticTokens();
            const builder = new vscode.SemanticTokensBuilder(legend);
            tokens.sort((a, b) => {
                if (a.line !== b.line) {
                    return a.line - b.line;
                }
                return a.character - b.character;
            });
            tokens.forEach(token => {
                builder.push(token.line - 1, token.character, token.length, token.tokenType, token.tokenModifiers);
            });
            return builder.build();
        }
    }, legend));
}


/***/ }),

/***/ "./src/features/wordCompletionProvider.ts":
/*!************************************************!*\
  !*** ./src/features/wordCompletionProvider.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerWordCompletionProvider = registerWordCompletionProvider;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const documentAnalysisManager_1 = __webpack_require__(/*! ../analysis/documentAnalysisManager */ "./src/analysis/documentAnalysisManager.ts");
const pasirser_1 = __webpack_require__(/*! @kanji/pasirser */ "../pasirser/dist/index.js");
// --- ヘルパー関数 ---
function toVscodeCompletionItemKind(kind) {
    return kind;
}
// --- メイン関数 ---
function registerWordCompletionProvider(context) {
    const provider = vscode.languages.registerCompletionItemProvider('rr', {
        provideCompletionItems(document, position, token, context) {
            const service = documentAnalysisManager_1.analysisManager.getService(document.uri);
            if (!service) {
                return [];
            }
            const code = document.getText();
            const pasirserPosition = {
                line: position.line + 1,
                character: position.character
            };
            const pasirserCompletions = service.getCompletions(code, pasirserPosition);
            return pasirserCompletions.map((item) => {
                const completionItem = new vscode.CompletionItem(item.label, toVscodeCompletionItemKind(item.kind));
                completionItem.detail = item.detail;
                completionItem.documentation = item.documentation ? new vscode.MarkdownString(item.documentation) : undefined;
                if (item.insertText && item.insertTextFormat === pasirser_1.InsertTextFormat.Snippet) {
                    completionItem.insertText = new vscode.SnippetString(item.insertText);
                }
                else {
                    completionItem.insertText = item.insertText;
                }
                return completionItem;
            });
        }
    }, '(', // pari
    '"' // ctrl
    );
    context.subscriptions.push(provider);
}


/***/ }),

/***/ "./src/utils/cwrapSession.ts":
/*!***********************************!*\
  !*** ./src/utils/cwrapSession.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CwrapSessionManager = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const openxmclient_1 = __webpack_require__(/*! @kanji/openxmclient */ "../openxmclient/dist/index.js");
class CwrapSessionManager {
    context;
    executorPath;
    _session = null;
    _masterServer = null;
    _status = 'stopped';
    _statusEventEmitter = new vscode.EventEmitter();
    onDidChangeStatus = this._statusEventEmitter.event;
    constructor(context, executorPath) {
        this.context = context;
        this.executorPath = executorPath;
    }
    get session() {
        return this._session;
    }
    get status() {
        return this._status;
    }
    setStatus(newStatus) {
        if (this._status === newStatus)
            return;
        this._status = newStatus;
        this._statusEventEmitter.fire(this._status);
        console.log(`Session status changed to: ${newStatus}`);
    }
    async start() {
        const useSessionMode = vscode.workspace.getConfiguration('risaasirExecutor').get('useSessionMode');
        if (!useSessionMode) {
            console.log('Session mode is disabled. Aborting start.');
            if (this.status !== 'stopped') {
                await this.stop();
            }
            return;
        }
        if (this._status === 'active' || this._status === 'starting') {
            console.log('Session is already active or starting.');
            return;
        }
        this.setStatus('starting');
        const MAX_RETRIES = 3;
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                this._masterServer = await this.startMasterServer();
                this.context.subscriptions.push({ dispose: () => this._masterServer?.kill() });
                this._session = new openxmclient_1.AsirSession();
                await this._session.start(this.executorPath);
                console.log(`Session successfully established on attempt ${attempt}.`);
                this.setStatus('active');
                return;
            }
            catch (error) {
                console.error(`Attempt ${attempt} to start session failed: ${error.message}`);
                await this.stopInternal();
                if (attempt === MAX_RETRIES) {
                    vscode.window.showErrorMessage(`Failed to start Asir session after ${MAX_RETRIES} attempts.`);
                    this.setStatus('failed');
                    return;
                }
                await new Promise(res => setTimeout(res, 500));
            }
        }
    }
    async stop() {
        this.setStatus('stopping');
        await this.stopInternal();
        this.setStatus('stopped');
    }
    async stopInternal() {
        if (this._session) {
            this._session.close();
            this._session = null;
        }
        if (this._masterServer) {
            this._masterServer.kill();
            this._masterServer = null;
        }
    }
    async restart() {
        await this.stop();
        await this.start();
    }
    async execute(command) {
        if (this._status !== 'active' || !this._session) {
            throw new Error('Asir session is not active. Cannot execute command.');
        }
        // ここで実行中の状態管理を追加することも可能
        try {
            const result = await this._session.execute(command);
            return result;
        }
        catch (error) {
            // エラーハンドリング
            throw error;
        }
    }
    interrupt() {
        if (this._status === 'active' && this._session) {
            this._session.interrupt();
            vscode.window.showInformationMessage('Sent interrupt signal to Asir session.');
        }
    }
    startMasterServer() {
        return new Promise((resolve, reject) => {
            const serverCommand = 'ox';
            const serverArgs = ['-ox', 'ox_asir', '-host', '127.0.0.1', '-data', '1300', '-control', '1200', '-insecure'];
            const serverProcess = (0, child_process_1.spawn)(serverCommand, serverArgs);
            const timer = setTimeout(() => {
                serverProcess.kill();
                reject(new Error("Asir server startup timed out."));
            }, 10000);
            serverProcess.on('error', (err) => {
                clearTimeout(timer);
                reject(err);
            });
            serverProcess.on('close', (code) => {
                if (code !== 0) {
                    clearTimeout(timer);
                    reject(new Error(`Master server exited prematurely with code ${code}`));
                }
            });
            let stderrBuffer = '';
            serverProcess.stderr?.on('data', (data) => {
                const messageChunk = data.toString();
                stderrBuffer += messageChunk;
                process.stderr.write(`[Asir Server]: ${messageChunk}`);
                if (stderrBuffer.includes('Port for control message')) {
                    clearTimeout(timer);
                    this.context.subscriptions.push({ dispose: () => serverProcess.kill() });
                    resolve(serverProcess);
                }
            });
        });
    }
}
exports.CwrapSessionManager = CwrapSessionManager;


/***/ }),

/***/ "./src/utils/helper.ts":
/*!*****************************!*\
  !*** ./src/utils/helper.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isMatchingBracket = isMatchingBracket;
exports.isBuiltInOrKeyword = isBuiltInOrKeyword;
exports.convertWindowsPathToWsl = convertWindowsPathToWsl;
const builtins_1 = __webpack_require__(/*! ../data/builtins */ "./src/data/builtins.ts");
// --- 括弧チェックのヘルパー関数 ---
function isMatchingBracket(open, close) {
    return (open === '(' && close === ')') ||
        (open === '[' && close === ']') ||
        (open === '{' && close === '}');
}
// --- 組み込み関数かキーワードかを判定するヘルパー関数 ---
function isBuiltInOrKeyword(name) {
    return builtins_1.ASIR_KEYWORDS.includes(name) || builtins_1.ASIR_BUILTIN_FUNCTIONS.includes(name);
}
// windowsパスをwslパスに変換するヘルパー関数
function convertWindowsPathToWsl(winPath) {
    let wslPath = winPath.replace(/\\/g, '/');
    const driveLetterMatch = wslPath.match(/^([A-Za-z]):\//);
    if (driveLetterMatch) {
        wslPath = `/mnt/${driveLetterMatch[1].toLowerCase()}${wslPath.substring(driveLetterMatch[0].length - 1)}`;
    }
    return wslPath;
}


/***/ }),

/***/ "./src/utils/webviewUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/webviewUtils.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// src/utils/webviewUtils.ts
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createResultWebview = createResultWebview;
exports.getWebviewContent = getWebviewContent;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
/**
 * Escapes special characters in a string for use in HTML.
 * @param unsafe The string to escape.
 * @returns The escaped HTML string.
 */
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
}
/**
 * Risa/Asirの結果を表示するための Webview を作成・表示。
 * @param context 拡張機能コンテキスト
 * @param inputCode 実行したRisa/Asirのコード
 * @param outputResult Risa/Asirの計算結果
 * @param errorResult Risa/Asirのエラーメッセージ
 */
function createResultWebview(context, inputCode, outputResult, errorResult) {
    const panel = vscode.window.createWebviewPanel('risaasirResult', 'Risa/Asir Result', vscode.ViewColumn.Beside, {
        enableScripts: false,
        localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'media'))]
    });
    panel.webview.html = getWebviewContent(inputCode, outputResult, errorResult);
    panel.onDidDispose(() => { }, null, context.subscriptions);
}
/**
 * Webviewに表示するHTMLコンテンツの生成
 * @param inputCode 実行したRisa/Asir のコード
 * @param outputResult Risa/Asirの計算結果
 * @returns HTML 文字列
 */
function getWebviewContent(inputCode, outputResult, errorResult) {
    const escapedInputCode = escapeHtml(inputCode);
    const escapedOutputResult = escapeHtml(outputResult);
    const escapedErrorResult = escapeHtml(errorResult);
    let errorSectionHtml = '';
    if (escapedErrorResult.trim().length > 0) {
        errorSectionHtml = `
            <div class="section">
                <h2>Risa/Asir Error Message</h2>
                <div class="code-block error-block">
                    <div class="content-wrapper">
                        <pre>${escapedErrorResult}</pre>
                    </div>
                </div>
            </div>`;
    }
    const finalHtml = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risa/Asir Result</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 1.5em; line-height: 1.6; }
        h1, h2 { color: var(--vscode-editor-foreground); }
        .section { margin-bottom: 2em; }
        .code-block {
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-editorGroup-border);
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
            color: var(--vscode-editor-foreground);
        }
        .code-block pre {
            font-family: 'SF Mono', Monaco, Consolas, 'Courier New', monospace;
            white-space: pre;
            word-wrap: normal;
            margin: 0;
            padding: 0;
            text-align: left;
        }
        body {
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
        }
        .error-block {
            border-color: var(--vscode-errorForeground);
            background-color: var(--vscode-terminal-ansiBrightBlack);
        }
        .error-block pre {
            color: var(--vscode-errorForeground);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Risa/Asir Computation Result</h1>

    ${errorSectionHtml}

    <div class="section">
        <h2>Input Code</h2>
        <div class="code-block">
            <div class="content-wrapper">
                <pre>${escapedInputCode}</pre>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>Output Result</h2>
        <div class="code-block">
            <div class="content-wrapper">
                <pre>${escapedOutputResult}</pre>
            </div>
        </div>
    </div>
</body>
</html>`;
    return finalHtml;
}


/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/extension.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map